(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define("MathBox", ["THREE"], factory);
	else if(typeof exports === 'object')
		exports["MathBox"] = factory(require("THREE"));
	else
		root["MathBox"] = factory(root["THREE"]);
})(self, function(__WEBPACK_EXTERNAL_MODULE__824__) {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(2016);

module.exports = parseArray;

function parseArray(tokens) {
  var parser = parse();

  for (var i = 0; i < tokens.length; i++) {
    parser(tokens[i]);
  }

  return parser(null);
}


/***/ }),

/***/ 3837:
/***/ ((module) => {

let state, token, tokens, idx;

const original_symbol = {
  nud: function () {
    return this.children && this.children.length ? this : fail("unexpected")();
  },
  led: fail("missing operator"),
};

const symbol_table = {};

function itself() {
  return this;
}

symbol("(ident)").nud = itself;
symbol("(keyword)").nud = itself;
symbol("(builtin)").nud = itself;
symbol("(literal)").nud = itself;
symbol("(end)");

symbol(":");
symbol(";");
symbol(",");
symbol(")");
symbol("]");
symbol("}");

infixr("&&", 30);
infixr("||", 30);
infix("|", 43);
infix("^", 44);
infix("&", 45);
infix("==", 46);
infix("!=", 46);
infix("<", 47);
infix("<=", 47);
infix(">", 47);
infix(">=", 47);
infix(">>", 48);
infix("<<", 48);
infix("+", 50);
infix("-", 50);
infix("*", 60);
infix("/", 60);
infix("%", 60);
infix("?", 20, function (left) {
  this.children = [left, expression(0), (advance(":"), expression(0))];
  this.type = "ternary";
  return this;
});
infix(".", 80, function (left) {
  token.type = "literal";
  state.fake(token);
  this.children = [left, token];
  advance();
  return this;
});
infix("[", 80, function (left) {
  this.children = [left, expression(0)];
  this.type = "binary";
  advance("]");
  return this;
});
infix("(", 80, function (left) {
  this.children = [left];
  this.type = "call";

  if (token.data !== ")")
    while (1) {
      this.children.push(expression(0));
      if (token.data !== ",") break;
      advance(",");
    }
  advance(")");
  return this;
});

prefix("-");
prefix("+");
prefix("!");
prefix("~");
prefix("defined");
prefix("(", function () {
  this.type = "group";
  this.children = [expression(0)];
  advance(")");
  return this;
});
prefix("++");
prefix("--");
suffix("++");
suffix("--");

assignment("=");
assignment("+=");
assignment("-=");
assignment("*=");
assignment("/=");
assignment("%=");
assignment("&=");
assignment("|=");
assignment("^=");
assignment(">>=");
assignment("<<=");

module.exports = function (incoming_state, incoming_tokens) {
  state = incoming_state;
  tokens = incoming_tokens;
  idx = 0;
  let result;

  if (!tokens.length) return;

  advance();
  result = expression(0);
  result.parent = state[0];
  emit(result);

  if (idx < tokens.length) {
    throw new Error("did not use all tokens");
  }

  result.parent.children = [result];

  function emit(node) {
    state.unshift(node, false);
    for (let i = 0, len = node.children.length; i < len; ++i) {
      emit(node.children[i]);
    }
    state.shift();
  }
};

function symbol(id, binding_power) {
  let sym = symbol_table[id];
  binding_power = binding_power || 0;
  if (sym) {
    if (binding_power > sym.lbp) {
      sym.lbp = binding_power;
    }
  } else {
    sym = Object.create(original_symbol);
    sym.id = id;
    sym.lbp = binding_power;
    symbol_table[id] = sym;
  }
  return sym;
}

function expression(rbp) {
  let left,
    t = token;
  advance();

  left = t.nud();
  while (rbp < token.lbp) {
    t = token;
    advance();
    left = t.led(left);
  }
  return left;
}

function infix(id, bp, led) {
  const sym = symbol(id, bp);
  sym.led =
    led ||
    function (left) {
      this.children = [left, expression(bp)];
      this.type = "binary";
      return this;
    };
}

function infixr(id, bp, led) {
  const sym = symbol(id, bp);
  sym.led =
    led ||
    function (left) {
      this.children = [left, expression(bp - 1)];
      this.type = "binary";
      return this;
    };
  return sym;
}

function prefix(id, nud) {
  const sym = symbol(id);
  sym.nud =
    nud ||
    function () {
      this.children = [expression(70)];
      this.type = "unary";
      return this;
    };
  return sym;
}

function suffix(id) {
  const sym = symbol(id, 150);
  sym.led = function (left) {
    this.children = [left];
    this.type = "suffix";
    return this;
  };
}

function assignment(id) {
  return infixr(id, 10, function (left) {
    this.children = [left, expression(9)];
    this.assignment = true;
    this.type = "assign";
    return this;
  });
}

function advance(id) {
  let next, value, type, output;

  if (id && token.data !== id) {
    return state.unexpected("expected `" + id + "`, got `" + token.data + "`");
  }

  if (idx >= tokens.length) {
    token = symbol_table["(end)"];
    return;
  }

  next = tokens[idx++];
  value = next.data;
  type = next.type;

  if (type === "ident") {
    output = state.scope.find(value) || state.create_node();
    type = output.type;
  } else if (type === "builtin") {
    output = symbol_table["(builtin)"];
  } else if (type === "keyword") {
    output = symbol_table["(keyword)"];
  } else if (type === "operator") {
    output = symbol_table[value];
    if (!output) {
      return state.unexpected("unknown operator `" + value + "`");
    }
  } else if (type === "float" || type === "integer") {
    type = "literal";
    output = symbol_table["(literal)"];
  } else {
    return state.unexpected("unexpected token.");
  }

  if (output) {
    if (!output.nud) {
      output.nud = itself;
    }
    if (!output.children) {
      output.children = [];
    }
  }

  output = Object.create(output);
  output.token = next;
  output.type = type;
  if (!output.data) output.data = value;

  return (token = output);
}

function fail(message) {
  return function () {
    return state.unexpected(message);
  };
}


/***/ }),

/***/ 2016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = parser;

const full_parse_expr = __webpack_require__(3837),
  Scope = __webpack_require__(8816);

// singleton!
const Advance = new Object();

const DEBUG = false;

let _ = 0,
  IDENT = _++,
  STMT = _++,
  STMTLIST = _++,
  STRUCT = _++,
  FUNCTION = _++,
  FUNCTIONARGS = _++,
  DECL = _++,
  DECLLIST = _++,
  FORLOOP = _++,
  WHILELOOP = _++,
  IF = _++,
  EXPR = _++,
  PRECISION = _++,
  COMMENT = _++,
  PREPROCESSOR = _++,
  KEYWORD = _++,
  KEYWORD_OR_IDENT = _++,
  RETURN = _++,
  BREAK = _++,
  CONTINUE = _++,
  DISCARD = _++,
  DOWHILELOOP = _++,
  PLACEHOLDER = _++,
  QUANTIFIER = _++;

const DECL_ALLOW_ASSIGN = 0x1,
  DECL_ALLOW_COMMA = 0x2,
  DECL_REQUIRE_NAME = 0x4,
  DECL_ALLOW_INVARIANT = 0x8,
  DECL_ALLOW_STORAGE = 0x10,
  DECL_NO_INOUT = 0x20,
  DECL_ALLOW_STRUCT = 0x40,
  DECL_STATEMENT = 0xff,
  DECL_FUNCTION =
    DECL_STATEMENT &
    ~(
      DECL_ALLOW_ASSIGN |
      DECL_ALLOW_COMMA |
      DECL_NO_INOUT |
      DECL_ALLOW_INVARIANT |
      DECL_REQUIRE_NAME
    ),
  DECL_STRUCT =
    DECL_STATEMENT &
    ~(
      DECL_ALLOW_ASSIGN |
      DECL_ALLOW_INVARIANT |
      DECL_ALLOW_STORAGE |
      DECL_ALLOW_STRUCT
    );

const QUALIFIERS = (/* unused pure expression or super */ null && (["const", "attribute", "uniform", "varying"]));

const NO_ASSIGN_ALLOWED = false,
  NO_COMMA_ALLOWED = false;

// map of tokens to stmt types
const token_map = {
  "block-comment": COMMENT,
  "line-comment": COMMENT,
  preprocessor: PREPROCESSOR,
};

// map of stmt types to human
const stmt_type = (_ = [
  "ident",
  "stmt",
  "stmtlist",
  "struct",
  "function",
  "functionargs",
  "decl",
  "decllist",
  "forloop",
  "whileloop",
  "if",
  "expr",
  "precision",
  "comment",
  "preprocessor",
  "keyword",
  "keyword_or_ident",
  "return",
  "break",
  "continue",
  "discard",
  "do-while",
  "placeholder",
  "quantifier",
]);

function parser() {
  const stmtlist = n(STMTLIST),
    stmt = n(STMT),
    decllist = n(DECLLIST),
    precision = n(PRECISION),
    ident = n(IDENT),
    keyword_or_ident = n(KEYWORD_OR_IDENT),
    fn = n(FUNCTION),
    fnargs = n(FUNCTIONARGS),
    forstmt = n(FORLOOP),
    ifstmt = n(IF),
    whilestmt = n(WHILELOOP),
    returnstmt = n(RETURN),
    dowhilestmt = n(DOWHILELOOP),
    quantifier = n(QUANTIFIER);

  let parse_struct,
    parse_precision,
    parse_quantifier,
    parse_forloop,
    parse_if,
    parse_return,
    parse_whileloop,
    parse_dowhileloop,
    parse_function,
    parse_function_args;

  let check = arguments.length ? [].slice.call(arguments) : [],
    complete = false,
    ended = false,
    depth = 0,
    state = [],
    nodes = [],
    tokens = [],
    whitespace = [],
    errored = false,
    program,
    token,
    node;

  // setup state
  state.shift = special_shift;
  state.unshift = special_unshift;
  state.fake = special_fake;
  state.unexpected = unexpected;
  state.scope = new Scope(state);
  state.create_node = function () {
    const n = mknode(IDENT, token);
    n.parent = reader.program;
    return n;
  };

  setup_stative_parsers();

  // setup root node
  node = stmtlist();
  node.expecting = "(eof)";
  node.mode = STMTLIST;
  node.token = { type: "(program)", data: "(program)" };
  program = node;

  reader.program = program;
  reader.scope = function (scope) {
    if (arguments.length === 1) {
      state.scope = scope;
    }
    return state.scope;
  };

  state.unshift(node);
  return reader;

  function reader(data) {
    if (data === null) {
      return end(), program;
    }

    nodes = [];
    write(data);
    return nodes;
  }

  // stream functions ---------------------------------------------

  function write(input) {
    if (
      input.type === "whitespace" ||
      input.type === "line-comment" ||
      input.type === "block-comment"
    ) {
      whitespace.push(input);
      return;
    }
    tokens.push(input);
    token = token || tokens[0];

    if (token && whitespace.length) {
      token.preceding = token.preceding || [];
      token.preceding = token.preceding.concat(whitespace);
      whitespace = [];
    }

    while (take())
      switch (state[0].mode) {
        case STMT:
          parse_stmt();
          break;
        case STMTLIST:
          parse_stmtlist();
          break;
        case DECL:
          parse_decl();
          break;
        case DECLLIST:
          parse_decllist();
          break;
        case EXPR:
          parse_expr();
          break;
        case STRUCT:
          parse_struct(true, true);
          break;
        case PRECISION:
          parse_precision();
          break;
        case IDENT:
          parse_ident();
          break;
        case KEYWORD:
          parse_keyword();
          break;
        case KEYWORD_OR_IDENT:
          parse_keyword_or_ident();
          break;
        case FUNCTION:
          parse_function();
          break;
        case FUNCTIONARGS:
          parse_function_args();
          break;
        case FORLOOP:
          parse_forloop();
          break;
        case WHILELOOP:
          parse_whileloop();
          break;
        case DOWHILELOOP:
          parse_dowhileloop();
          break;
        case RETURN:
          parse_return();
          break;
        case IF:
          parse_if();
          break;
        case QUANTIFIER:
          parse_quantifier();
          break;
      }
  }

  function end(tokens) {
    if (arguments.length) {
      write(tokens);
    }

    if (state.length > 1) {
      unexpected("unexpected EOF");
      return;
    }

    complete = true;
  }

  function take() {
    if (errored || !state.length) return false;

    return (token = tokens[0]);
  }

  // ----- state manipulation --------

  function special_fake(x) {
    state.unshift(x);
    state.shift();
  }

  function special_unshift(_node, add_child) {
    _node.parent = state[0];

    const ret = [].unshift.call(this, _node);

    add_child = add_child === undefined ? true : add_child;

    if (DEBUG) {
      let pad = "";
      for (let i = 0, len = this.length - 1; i < len; ++i) {
        pad += " |";
      }
      console.log(pad, "\\" + _node.type, _node.token.data);
    }

    if (add_child && node !== _node) node.children.push(_node);
    node = _node;

    return ret;
  }

  function special_shift() {
    let _node = [].shift.call(this),
      okay = check[this.length],
      emit = false;

    if (DEBUG) {
      let pad = "";
      for (let i = 0, len = this.length; i < len; ++i) {
        pad += " |";
      }
      console.log(pad, "/" + _node.type);
    }

    if (check.length) {
      if (typeof check[0] === "function") {
        emit = check[0](_node);
      } else if (okay !== undefined) {
        emit = okay.test ? okay.test(_node.type) : okay === _node.type;
      }
    } else {
      emit = true;
    }

    if (emit && !errored) nodes.push(_node);

    node = _node.parent;
    return _node;
  }

  // parse states ---------------

  function parse_stmtlist() {
    // determine the type of the statement
    // and then start parsing
    return stative(function () {
      state.scope.enter();
      return Advance;
    }, normal_mode)();

    function normal_mode() {
      if (token.data === state[0].expecting) {
        return state.scope.exit(), state.shift();
      }
      switch (token.type) {
        case "preprocessor":
          state.fake(adhoc());
          tokens.shift();
          return;
        default:
          state.unshift(stmt());
          return;
      }
    }
  }

  function parse_stmt() {
    if (state[0].brace) {
      if (token.data !== "}") {
        return unexpected("expected `}`, got " + token.data);
      }
      state[0].brace = false;
      return tokens.shift(), state.shift();
    }
    switch (token.type) {
      case "eof":
        return got_eof();
      case "keyword":
        switch (token.data) {
          case "for":
            return state.unshift(forstmt());
          case "if":
            return state.unshift(ifstmt());
          case "while":
            return state.unshift(whilestmt());
          case "do":
            return state.unshift(dowhilestmt());
          case "break":
            return state.fake(mknode(BREAK, token)), tokens.shift();
          case "continue":
            return state.fake(mknode(CONTINUE, token)), tokens.shift();
          case "discard":
            return state.fake(mknode(DISCARD, token)), tokens.shift();
          case "return":
            return state.unshift(returnstmt());
          case "precision":
            return state.unshift(precision());
        }
        return state.unshift(decl(DECL_STATEMENT));
      case "ident":
        var lookup;
        if ((lookup = state.scope.find(token.data))) {
          if (lookup.parent.type === "struct") {
            // this is strictly untrue, you could have an
            // expr that starts with a struct constructor.
            //      ... sigh
            return state.unshift(decl(DECL_STATEMENT));
          }
          return state.unshift(expr(";"));
        }
      case "operator":
        if (token.data === "{") {
          state[0].brace = true;
          const n = stmtlist();
          n.expecting = "}";
          return tokens.shift(), state.unshift(n);
        }
        if (token.data === ";") {
          return tokens.shift(), state.shift();
        }
      default:
        return state.unshift(expr(";"));
    }
  }

  function got_eof() {
    if (ended) errored = true;
    ended = true;
    return state.shift();
  }

  function parse_decl() {
    const stmt = state[0];

    return stative(
      invariant_or_not,
      storage_or_not,
      parameter_or_not,
      precision_or_not,
      struct_or_type,
      maybe_name,
      maybe_lparen, // lparen means we're a function
      is_decllist,
      done
    )();

    function invariant_or_not() {
      if (token.data === "invariant") {
        if (stmt.flags & DECL_ALLOW_INVARIANT) {
          state.unshift(keyword());
          return Advance;
        } else {
          return unexpected("`invariant` is not allowed here");
        }
      } else {
        state.fake(mknode(PLACEHOLDER, { data: "", position: token.position }));
        return Advance;
      }
    }

    function storage_or_not() {
      if (is_storage(token)) {
        if (stmt.flags & DECL_ALLOW_STORAGE) {
          state.unshift(keyword());
          return Advance;
        } else {
          return unexpected("storage is not allowed here");
        }
      } else {
        state.fake(mknode(PLACEHOLDER, { data: "", position: token.position }));
        return Advance;
      }
    }

    function parameter_or_not() {
      if (is_parameter(token)) {
        if (!(stmt.flags & DECL_NO_INOUT)) {
          state.unshift(keyword());
          return Advance;
        } else {
          return unexpected("parameter is not allowed here");
        }
      } else {
        state.fake(mknode(PLACEHOLDER, { data: "", position: token.position }));
        return Advance;
      }
    }

    function precision_or_not() {
      if (is_precision(token)) {
        state.unshift(keyword());
        return Advance;
      } else {
        state.fake(mknode(PLACEHOLDER, { data: "", position: token.position }));
        return Advance;
      }
    }

    function struct_or_type() {
      if (token.data === "struct") {
        if (!(stmt.flags & DECL_ALLOW_STRUCT)) {
          return unexpected("cannot nest structs");
        }
        state.unshift(struct());
        return Advance;
      }

      if (token.type === "keyword") {
        state.unshift(keyword());
        return Advance;
      }

      const lookup = state.scope.find(token.data);

      if (lookup) {
        state.fake(Object.create(lookup));
        tokens.shift();
        return Advance;
      }
      return unexpected(
        "expected user defined type, struct or keyword, got " + token.data
      );
    }

    function maybe_name() {
      if (token.data === "," && !(stmt.flags & DECL_ALLOW_COMMA)) {
        return state.shift();
      }

      if (token.data === "[") {
        // oh lord.
        state.unshift(quantifier());
        return;
      }

      if (token.data === ")") return state.shift();

      if (token.data === ";") {
        return stmt.stage + 3;
      }

      if (token.type !== "ident" && token.type !== "builtin") {
        return unexpected("expected identifier, got " + token.data);
      }

      stmt.collected_name = tokens.shift();
      return Advance;
    }

    function maybe_lparen() {
      if (token.data === "(") {
        tokens.unshift(stmt.collected_name);
        delete stmt.collected_name;
        state.unshift(fn());
        return stmt.stage + 2;
      }
      return Advance;
    }

    function is_decllist() {
      tokens.unshift(stmt.collected_name);
      delete stmt.collected_name;
      state.unshift(decllist());
      return Advance;
    }

    function done() {
      return state.shift();
    }
  }

  function parse_decllist() {
    // grab ident

    if (token.type === "ident" || token.type === "builtin") {
      const name = token.data;
      state.unshift(ident());
      state.scope.define(name);
      return;
    }

    if (token.type === "operator") {
      if (token.data === ",") {
        // multi-decl!
        if (!(state[1].flags & DECL_ALLOW_COMMA)) {
          return state.shift();
        }

        return tokens.shift();
      } else if (token.data === "=") {
        if (!(state[1].flags & DECL_ALLOW_ASSIGN))
          return unexpected("`=` is not allowed here.");

        tokens.shift();

        state.unshift(expr(",", ";"));
        return;
      } else if (token.data === "[") {
        state.unshift(quantifier());
        return;
      }
    }
    return state.shift();
  }

  function parse_keyword_or_ident() {
    if (token.type === "keyword") {
      state[0].type = "keyword";
      state[0].mode = KEYWORD;
      return;
    }

    if (token.type === "ident") {
      state[0].type = "ident";
      state[0].mode = IDENT;
      return;
    }

    return unexpected(
      "expected keyword or user-defined name, got " + token.data
    );
  }

  function parse_keyword() {
    if (token.type !== "keyword") {
      return unexpected("expected keyword, got " + token.data);
    }

    return state.shift(), tokens.shift();
  }

  function parse_ident() {
    if (token.type !== "ident" && token.type !== "builtin") {
      return unexpected("expected user-defined name, got " + token.data);
    }

    state[0].data = token.data;
    return state.shift(), tokens.shift();
  }

  function parse_expr() {
    const expecting = state[0].expecting;

    state[0].tokens = state[0].tokens || [];

    if (state[0].parenlevel === undefined) {
      state[0].parenlevel = 0;
      state[0].bracelevel = 0;
    }
    if (state[0].parenlevel < 1 && expecting.indexOf(token.data) > -1) {
      return parseexpr(state[0].tokens);
    }
    if (token.data === "(") {
      ++state[0].parenlevel;
    } else if (token.data === ")") {
      --state[0].parenlevel;
    }

    switch (token.data) {
      case "{":
        ++state[0].bracelevel;
        break;
      case "}":
        --state[0].bracelevel;
        break;
      case "(":
        ++state[0].parenlevel;
        break;
      case ")":
        --state[0].parenlevel;
        break;
    }

    if (state[0].parenlevel < 0) return unexpected("unexpected `)`");
    if (state[0].bracelevel < 0) return unexpected("unexpected `}`");

    state[0].tokens.push(tokens.shift());
    return;

    function parseexpr(tokens) {
      try {
        full_parse_expr(state, tokens);
      } catch (err) {
        errored = true;
        throw err;
      }

      return state.shift();
    }
  }

  // node types ---------------

  function n(type) {
    // this is a function factory that suffices for most kinds of expressions and statements
    return function () {
      return mknode(type, token);
    };
  }

  function adhoc() {
    return mknode(token_map[token.type], token, node);
  }

  function decl(flags) {
    const _ = mknode(DECL, token, node);
    _.flags = flags;

    return _;
  }

  function struct(allow_assign, allow_comma) {
    const _ = mknode(STRUCT, token, node);
    _.allow_assign = allow_assign === undefined ? true : allow_assign;
    _.allow_comma = allow_comma === undefined ? true : allow_comma;
    return _;
  }

  function expr() {
    const n = mknode(EXPR, token, node);

    n.expecting = [].slice.call(arguments);
    return n;
  }

  function keyword(default_value) {
    let t = token;
    if (default_value) {
      t = { type: "(implied)", data: "(default)", position: t.position };
    }
    return mknode(KEYWORD, t, node);
  }

  // utils ----------------------------

  function unexpected(str) {
    errored = true;
    throw new Error(
      (str || "unexpected " + state) + " at line " + state[0].token.line
    );
  }

  function assert(type, data) {
    return (
      1,
      assert_null_string_or_array(type, token.type) &&
        assert_null_string_or_array(data, token.data)
    );
  }

  function assert_null_string_or_array(x, y) {
    switch (typeof x) {
      case "string":
        if (y !== x) {
          unexpected("expected `" + x + "`, got " + y + "\n" + token.data);
        }
        return !errored;

      case "object":
        if (x && x.indexOf(y) === -1) {
          unexpected("expected one of `" + x.join("`, `") + "`, got " + y);
        }
        return !errored;
    }
    return true;
  }

  // stative ----------------------------

  function stative() {
    let steps = [].slice.call(arguments),
      step,
      result;

    return function () {
      const current = state[0];

      current.stage || (current.stage = 0);

      step = steps[current.stage];
      if (!step) return unexpected("parser in undefined state!");

      result = step();

      if (result === Advance) return ++current.stage;
      if (result === undefined) return;
      current.stage = result;
    };
  }

  function advance(op, t) {
    t = t || "operator";
    return function () {
      if (!assert(t, op)) return;

      const last = tokens.shift(),
        children = state[0].children,
        last_node = children[children.length - 1];

      if (last_node && last_node.token && last.preceding) {
        last_node.token.succeeding = last_node.token.succeeding || [];
        last_node.token.succeeding = last_node.token.succeeding.concat(
          last.preceding
        );
      }
      return Advance;
    };
  }

  function advance_expr(until) {
    return function () {
      state.unshift(expr(until));
      return Advance;
    };
  }

  function advance_ident(declare) {
    return declare
      ? function () {
          const name = token.data;
          return (
            assert("ident") &&
            (state.unshift(ident()), state.scope.define(name), Advance)
          );
        }
      : function () {
          if (!assert("ident")) return;

          const s = Object.create(state.scope.find(token.data));
          s.token = token;

          return tokens.shift(), Advance;
        };
  }

  function advance_stmtlist() {
    return function () {
      const n = stmtlist();
      n.expecting = "}";
      return state.unshift(n), Advance;
    };
  }

  function maybe_stmtlist(skip) {
    return function () {
      const current = state[0].stage;
      if (token.data !== "{") {
        return state.unshift(stmt()), current + skip;
      }
      return tokens.shift(), Advance;
    };
  }

  function popstmt() {
    return function () {
      return state.shift(), state.shift();
    };
  }

  function setup_stative_parsers() {
    // could also be
    // struct { } decllist
    parse_struct = stative(
      advance("struct", "keyword"),
      function () {
        if (token.data === "{") {
          state.fake(
            mknode(IDENT, { data: "", position: token.position, type: "ident" })
          );
          return Advance;
        }

        return advance_ident(true)();
      },
      function () {
        state.scope.enter();
        return Advance;
      },
      advance("{"),
      function () {
        if (token.type === "preprocessor") {
          state.fake(adhoc());
          tokens.shift();
          return;
        }
        if (token.data === "}") {
          state.scope.exit();
          tokens.shift();
          return state.shift();
        }
        if (token.data === ";") {
          tokens.shift();
          return;
        }
        state.unshift(decl(DECL_STRUCT));
      }
    );

    parse_precision = stative(
      function () {
        return tokens.shift(), Advance;
      },
      function () {
        return (
          assert("keyword", ["lowp", "mediump", "highp"]) &&
          (state.unshift(keyword()), Advance)
        );
      },
      function () {
        return state.unshift(keyword()), Advance;
      },
      function () {
        return state.shift();
      }
    );

    parse_quantifier = stative(
      advance("["),
      advance_expr("]"),
      advance("]"),
      function () {
        return state.shift();
      }
    );

    parse_forloop = stative(
      advance("for", "keyword"),
      advance("("),
      function () {
        let lookup;
        if (token.type === "ident") {
          if (!(lookup = state.scope.find(token.data))) {
            lookup = state.create_node();
          }

          if (lookup.parent.type === "struct") {
            return state.unshift(decl(DECL_STATEMENT)), Advance;
          }
        } else if (token.type === "builtin" || token.type === "keyword") {
          return state.unshift(decl(DECL_STATEMENT)), Advance;
        }
        return advance_expr(";")();
      },
      advance(";"),
      advance_expr(";"),
      advance(";"),
      advance_expr(")"),
      advance(")"),
      maybe_stmtlist(3),
      advance_stmtlist(),
      advance("}"),
      popstmt()
    );

    parse_if = stative(
      advance("if", "keyword"),
      advance("("),
      advance_expr(")"),
      advance(")"),
      maybe_stmtlist(3),
      advance_stmtlist(),
      advance("}"),
      function () {
        if (token.data === "else") {
          return tokens.shift(), state.unshift(stmt()), Advance;
        }
        return popstmt()();
      },
      popstmt()
    );

    parse_return = stative(
      advance("return", "keyword"),
      function () {
        if (token.data === ";") return Advance;
        return state.unshift(expr(";")), Advance;
      },
      function () {
        tokens.shift(), popstmt()();
      }
    );

    parse_whileloop = stative(
      advance("while", "keyword"),
      advance("("),
      advance_expr(")"),
      advance(")"),
      maybe_stmtlist(3),
      advance_stmtlist(),
      advance("}"),
      popstmt()
    );

    parse_dowhileloop = stative(
      advance("do", "keyword"),
      maybe_stmtlist(3),
      advance_stmtlist(),
      advance("}"),
      advance("while", "keyword"),
      advance("("),
      advance_expr(")"),
      advance(")"),
      popstmt()
    );

    parse_function = stative(
      function () {
        for (let i = 1, len = state.length; i < len; ++i)
          if (state[i].mode === FUNCTION) {
            return unexpected(
              "function definition is not allowed within another function"
            );
          }

        return Advance;
      },
      function () {
        if (!assert("ident")) return;

        const name = token.data,
          lookup = state.scope.find(name);

        state.unshift(ident());
        state.scope.define(name);

        state.scope.enter(lookup ? lookup.scope : null);
        return Advance;
      },
      advance("("),
      function () {
        return state.unshift(fnargs()), Advance;
      },
      advance(")"),
      function () {
        // forward decl
        if (token.data === ";") {
          return state.scope.exit(), state.shift(), state.shift();
        }
        return Advance;
      },
      advance("{"),
      advance_stmtlist(),
      advance("}"),
      function () {
        state.scope.exit();
        return Advance;
      },
      function () {
        return state.shift(), state.shift(), state.shift();
      }
    );

    parse_function_args = stative(
      function () {
        if (token.data === "void") {
          state.fake(keyword());
          tokens.shift();
          return Advance;
        }
        if (token.data === ")") {
          state.shift();
          return;
        }
        if (token.data === "struct") {
          state.unshift(struct(NO_ASSIGN_ALLOWED, NO_COMMA_ALLOWED));
          return Advance;
        }
        state.unshift(decl(DECL_FUNCTION));
        return Advance;
      },
      function () {
        if (token.data === ",") {
          tokens.shift();
          return 0;
        }
        if (token.data === ")") {
          state.shift();
          return;
        }
        unexpected("expected one of `,` or `)`, got " + token.data);
      }
    );
  }
}

function mknode(mode, sourcetoken) {
  return {
    mode: mode,
    token: sourcetoken,
    children: [],
    type: stmt_type[mode],
    id: (Math.random() * 0xffffffff).toString(16),
  };
}

function is_storage(token) {
  return (
    token.data === "const" ||
    token.data === "attribute" ||
    token.data === "uniform" ||
    token.data === "varying"
  );
}

function is_parameter(token) {
  return token.data === "in" || token.data === "inout" || token.data === "out";
}

function is_precision(token) {
  return (
    token.data === "highp" || token.data === "mediump" || token.data === "lowp"
  );
}


/***/ }),

/***/ 8816:
/***/ ((module) => {

module.exports = scope;

function scope(state) {
  if (this.constructor !== scope) return new scope(state);

  this.state = state;
  this.scopes = [];
  this.current = null;
}

const cons = scope,
  proto = cons.prototype;

proto.enter = function (s) {
  this.scopes.push((this.current = this.state[0].scope = s || {}));
};

proto.exit = function () {
  this.scopes.pop();
  this.current = this.scopes[this.scopes.length - 1];
};

proto.define = function (str) {
  this.current[str] = this.state[0];
};

proto.find = function (name, fail) {
  for (let i = this.scopes.length - 1; i > -1; --i) {
    if (this.scopes[i].hasOwnProperty(name)) {
      return this.scopes[i][name];
    }
  }

  return null;
};


/***/ }),

/***/ 1073:
/***/ ((module) => {

module.exports = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

/***/ }),

/***/ 996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attributeRules = void 0;
var boolbase_1 = __webpack_require__(1073);
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
}
/**
 * Attribute selectors
 */
exports.attributeRules = {
    equals: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length === value.length &&
                    attr.toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len) === value &&
                next(elem));
        };
    },
    element: function (next, _a, _b) {
        var name = _a.name, value = _a.value, ignoreCase = _a.ignoreCase;
        var adapter = _b.adapter;
        if (/\s/.test(value)) {
            return boolbase_1.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), ignoreCase ? "i" : "");
        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                attr.length >= value.length &&
                regex.test(attr) &&
                next(elem));
        };
    },
    exists: function (next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
    },
    start: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
            return boolbase_1.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= len &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                next(elem);
        };
    },
    end: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
            return boolbase_1.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var _a;
                return ((_a = adapter
                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                next(elem);
        };
    },
    any: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
            return boolbase_1.falseFunc;
        }
        if (data.ignoreCase) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= value.length &&
                    regex_1.test(attr) &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                next(elem);
        };
    },
    not: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
            return function (elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        }
        else if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return ((attr == null ||
                    attr.length !== value.length ||
                    attr.toLowerCase() !== value) &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    },
};


/***/ }),

/***/ 8866:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
var css_what_1 = __webpack_require__(9751);
var boolbase_1 = __webpack_require__(1073);
var sort_1 = __importDefault(__webpack_require__(7353));
var procedure_1 = __webpack_require__(7177);
var general_1 = __webpack_require__(3621);
var subselects_1 = __webpack_require__(1768);
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return (0, subselects_1.ensureIsTag)(next, options.adapter);
}
exports.compile = compile;
function compileUnsafe(selector, options, context) {
    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector, options) : selector;
    return compileToken(token, options, context);
}
exports.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
    return (t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
var DESCENDANT_TOKEN = { type: "descendant" };
var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant",
};
var SCOPE_TOKEN = { type: "pseudo", name: "scope", data: null };
/*
 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
    var adapter = _a.adapter;
    // TODO Use better check if the context is a document
    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
    }));
    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") {
            // Don't continue in else branch
        }
        else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
        }
        else {
            continue;
        }
        t.unshift(SCOPE_TOKEN);
    }
}
function compileToken(token, options, context) {
    var _a;
    token = token.filter(function (t) { return t.length > 0; });
    token.forEach(sort_1.default);
    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    absolutize(token, options, finalContext);
    var shouldTestNextSiblings = false;
    var query = token
        .map(function (rules) {
        if (rules.length >= 2) {
            var first = rules[0], second = rules[1];
            if (first.type !== "pseudo" || first.name !== "scope") {
                // Ignore
            }
            else if (isArrayContext && second.type === "descendant") {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            }
            else if (second.type === "adjacent" ||
                second.type === "sibling") {
                shouldTestNextSiblings = true;
            }
        }
        return compileRules(rules, options, finalContext);
    })
        .reduce(reduceRules, boolbase_1.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
}
exports.compileToken = compileToken;
function compileRules(rules, options, context) {
    var _a;
    return rules.reduce(function (previous, rule) {
        return previous === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
}
function reduceRules(a, b) {
    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
        return a;
    }
    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
        return b;
    }
    return function combine(elem) {
        return a(elem) || b(elem);
    };
}


/***/ }),

/***/ 3621:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileGeneralSelector = void 0;
var attributes_1 = __webpack_require__(996);
var pseudo_selectors_1 = __webpack_require__(8677);
/*
 * All available rules
 */
function compileGeneralSelector(next, selector, options, context, compileToken) {
    var adapter = options.adapter, equals = options.equals;
    switch (selector.type) {
        case "pseudo-element":
            throw new Error("Pseudo-elements are not supported by css-select");
        case "attribute":
            return attributes_1.attributeRules[selector.action](next, selector, options);
        case "pseudo":
            return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        // Tags
        case "tag":
            return function tag(elem) {
                return adapter.getName(elem) === selector.name && next(elem);
            };
        // Traversal
        case "descendant":
            if (options.cacheResults === false ||
                typeof WeakSet === "undefined") {
                return function descendant(elem) {
                    var current = elem;
                    while ((current = adapter.getParent(current))) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            // @ts-expect-error `ElementNode` is not extending object
            // eslint-disable-next-line no-case-declarations
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
                var current = elem;
                while ((current = adapter.getParent(current))) {
                    if (!isFalseCache_1.has(current)) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                        isFalseCache_1.add(current);
                    }
                }
                return false;
            };
        case "_flexibleDescendant":
            // Include element itself, only used while querying an array
            return function flexibleDescendant(elem) {
                var current = elem;
                do {
                    if (adapter.isTag(current) && next(current))
                        return true;
                } while ((current = adapter.getParent(current)));
                return false;
            };
        case "parent":
            return function parent(elem) {
                return adapter
                    .getChildren(elem)
                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
            };
        case "child":
            return function child(elem) {
                var parent = adapter.getParent(elem);
                return parent != null && adapter.isTag(parent) && next(parent);
            };
        case "sibling":
            return function sibling(elem) {
                var siblings = adapter.getSiblings(elem);
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
                        return true;
                    }
                }
                return false;
            };
        case "adjacent":
            return function adjacent(elem) {
                var siblings = adapter.getSiblings(elem);
                var lastElement;
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling)) {
                        lastElement = currentSibling;
                    }
                }
                return !!lastElement && next(lastElement);
            };
        case "universal":
            return next;
    }
}
exports.compileGeneralSelector = compileGeneralSelector;


/***/ }),

/***/ 5366:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
var DomUtils = __importStar(__webpack_require__(9432));
var boolbase_1 = __webpack_require__(1073);
var compile_1 = __webpack_require__(8866);
var subselects_1 = __webpack_require__(1768);
var defaultEquals = function (a, b) { return a === b; };
var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals,
};
function convertOptionFormats(options) {
    var _a, _b, _c, _d;
    /*
     * We force one format of options to the other one.
     */
    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
    var opts = options !== null && options !== void 0 ? options : defaultOptions;
    // @ts-expect-error Same as above.
    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
    // @ts-expect-error `equals` does not exist on `Options`
    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
    return opts;
}
function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
    };
}
/**
 * Compiles the query, returns a function.
 */
exports.compile = wrapCompile(compile_1.compile);
exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
exports._compileToken = wrapCompile(compile_1.compileToken);
function getSelectorFunc(searchFunc) {
    return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
            query = (0, compile_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
    };
}
function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
    /*
     * Add siblings if the query requires them.
     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
     */
    if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems)
        ? adapter.removeSubsets(elems)
        : adapter.getChildren(elems);
}
exports.prepareContext = prepareContext;
function appendNextSiblings(elem, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    var elemsLength = elems.length;
    for (var i = 0; i < elemsLength; i++) {
        var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
    }
    return elems;
}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */
exports.selectAll = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? []
        : options.adapter.findAll(query, elems);
});
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */
exports.selectOne = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? null
        : options.adapter.findOne(query, elems);
});
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */
function is(elem, query, options) {
    var opts = convertOptionFormats(options);
    return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
}
exports.is = is;
/**
 * Alias for selectAll(query, elems, options).
 * @see [compile] for supported selector queries.
 */
exports["default"] = exports.selectAll;
// Export filters, pseudos and aliases to allow users to supply their own.
var pseudo_selectors_1 = __webpack_require__(8677);
Object.defineProperty(exports, "filters", ({ enumerable: true, get: function () { return pseudo_selectors_1.filters; } }));
Object.defineProperty(exports, "pseudos", ({ enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } }));
Object.defineProperty(exports, "aliases", ({ enumerable: true, get: function () { return pseudo_selectors_1.aliases; } }));


/***/ }),

/***/ 7177:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTraversal = exports.procedure = void 0;
exports.procedure = {
    universal: 50,
    tag: 30,
    attribute: 1,
    pseudo: 0,
    "pseudo-element": 0,
    descendant: -1,
    child: -1,
    parent: -1,
    sibling: -1,
    adjacent: -1,
    _flexibleDescendant: -1,
};
function isTraversal(t) {
    return exports.procedure[t.type] < 0;
}
exports.isTraversal = isTraversal;


/***/ }),

/***/ 2968:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
exports.aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])",
};


/***/ }),

/***/ 7689:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filters = void 0;
var nth_check_1 = __importDefault(__webpack_require__(7540));
var boolbase_1 = __webpack_require__(1073);
function getChildFunc(next, adapter) {
    return function (elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
    };
}
exports.filters = {
    contains: function (next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
        };
    },
    icontains: function (next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
            return (next(elem) &&
                adapter.getText(elem).toLowerCase().includes(itext));
        };
    },
    // Location specific methods
    "nth-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    // TODO determine the actual root element
    root: function (next, _rule, _a) {
        var adapter = _a.adapter;
        return function (elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
    },
    scope: function (next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
            // Equivalent to :root
            return exports.filters.root(next, rule, options);
        }
        if (context.length === 1) {
            // NOTE: can't be unpacked, as :has uses this for side-effects
            return function (elem) { return equals(context[0], elem) && next(elem); };
        }
        return function (elem) { return context.includes(elem) && next(elem); };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive"),
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
function dynamicStatePseudo(name) {
    return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
            return boolbase_1.falseFunc;
        }
        return function active(elem) {
            return func(elem) && next(elem);
        };
    };
}


/***/ }),

/***/ 8677:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
/*
 * Pseudo selectors
 *
 * Pseudo selectors are available in three forms:
 *
 * 1. Filters are called when the selector is compiled and return a function
 *  that has to return either false, or the results of `next()`.
 * 2. Pseudos are called on execution. They have to return a boolean.
 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
 *
 * Filters are great if you want to do some pre-processing, or change the call order
 * of `next()` and your code.
 * Pseudos should be used to implement simple checks.
 */
var boolbase_1 = __webpack_require__(1073);
var css_what_1 = __webpack_require__(9751);
var filters_1 = __webpack_require__(7689);
Object.defineProperty(exports, "filters", ({ enumerable: true, get: function () { return filters_1.filters; } }));
var pseudos_1 = __webpack_require__(7221);
Object.defineProperty(exports, "pseudos", ({ enumerable: true, get: function () { return pseudos_1.pseudos; } }));
var aliases_1 = __webpack_require__(2968);
Object.defineProperty(exports, "aliases", ({ enumerable: true, get: function () { return aliases_1.aliases; } }));
var subselects_1 = __webpack_require__(1768);
function compilePseudoSelector(next, selector, options, context, compileToken) {
    var name = selector.name, data = selector.data;
    if (Array.isArray(data)) {
        return subselects_1.subselects[name](next, data, options, context, compileToken);
    }
    if (name in aliases_1.aliases) {
        if (data != null) {
            throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        // The alias has to be parsed here, to make sure options are respected.
        var alias = (0, css_what_1.parse)(aliases_1.aliases[name], options);
        return subselects_1.subselects.is(next, alias, options, context, compileToken);
    }
    if (name in filters_1.filters) {
        return filters_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_1.pseudos) {
        var pseudo_1 = pseudos_1.pseudos[name];
        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
        return pseudo_1 === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : next === boolbase_1.trueFunc
                ? function (elem) { return pseudo_1(elem, options, data); }
                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
    }
    throw new Error("unmatched pseudo-class :".concat(name));
}
exports.compilePseudoSelector = compilePseudoSelector;


/***/ }),

/***/ 7221:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyPseudoArgs = exports.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
exports.pseudos = {
    empty: function (elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function (elem) {
            // FIXME: `getText` call is potentially expensive.
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
        });
    },
    "first-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter
            .getSiblings(elem)
            .find(function (elem) { return adapter.isTag(elem); });
        return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
                return true;
            if (adapter.isTag(siblings[i]))
                break;
        }
        return false;
    },
    "first-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "last-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "only-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter
            .getSiblings(elem)
            .every(function (sibling) {
            return equals(elem, sibling) ||
                !adapter.isTag(sibling) ||
                adapter.getName(sibling) !== elemName;
        });
    },
    "only-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter
            .getSiblings(elem)
            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
    },
};
function verifyPseudoArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2) {
            throw new Error("pseudo-selector :".concat(name, " requires an argument"));
        }
    }
    else if (func.length === 2) {
        throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
    }
}
exports.verifyPseudoArgs = verifyPseudoArgs;


/***/ }),

/***/ 1768:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
var boolbase_1 = __webpack_require__(1073);
var procedure_1 = __webpack_require__(7177);
/** Used as a placeholder for :has. Will be replaced with the actual element. */
exports.PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
    if (next === boolbase_1.falseFunc)
        return boolbase_1.falseFunc;
    return function (elem) { return adapter.isTag(elem) && next(elem); };
}
exports.ensureIsTag = ensureIsTag;
function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1)
        return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
exports.getNextSiblings = getNextSiblings;
var is = function (next, token, options, context, compileToken) {
    var opts = {
        xmlMode: !!options.xmlMode,
        adapter: options.adapter,
        equals: options.equals,
    };
    var func = compileToken(token, opts, context);
    return function (elem) { return func(elem) && next(elem); };
};
/*
 * :not, :has, :is, :matches and :where have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
exports.subselects = {
    is: is,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: is,
    where: is,
    not: function (next, token, options, context, compileToken) {
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: options.adapter,
            equals: options.equals,
        };
        var func = compileToken(token, opts, context);
        if (func === boolbase_1.falseFunc)
            return next;
        if (func === boolbase_1.trueFunc)
            return boolbase_1.falseFunc;
        return function not(elem) {
            return !func(elem) && next(elem);
        };
    },
    has: function (next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: adapter,
            equals: options.equals,
        };
        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
        var context = subselect.some(function (s) {
            return s.some(procedure_1.isTraversal);
        })
            ? [exports.PLACEHOLDER_ELEMENT]
            : undefined;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (compiled === boolbase_1.trueFunc) {
            return function (elem) {
                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
            };
        }
        var hasElement = ensureIsTag(compiled, adapter);
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
        /*
         * `shouldTestNextSiblings` will only be true if the query starts with
         * a traversal (sibling or adjacent). That means we will always have a context.
         */
        if (context) {
            return function (elem) {
                context[0] = elem;
                var childs = adapter.getChildren(elem);
                var nextElements = shouldTestNextSiblings
                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
                return (next(elem) && adapter.existsOne(hasElement, nextElements));
            };
        }
        return function (elem) {
            return next(elem) &&
                adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
    },
};


/***/ }),

/***/ 7353:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var procedure_1 = __webpack_require__(7177);
var attributes = {
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4,
};
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
            continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}
exports["default"] = sortByProcedure;
function getProcedure(token) {
    var proc = procedure_1.procedure[token.type];
    if (token.type === "attribute") {
        proc = attributes[token.action];
        if (proc === attributes.equals && token.name === "id") {
            // Prefer ID selectors (eg. #ID)
            proc = 9;
        }
        if (token.ignoreCase) {
            /*
             * IgnoreCase adds some overhead, prefer "normal" token
             * this is a binary operation, to ensure it's still an int
             */
            proc >>= 1;
        }
    }
    else if (token.type === "pseudo") {
        if (!token.data) {
            proc = 3;
        }
        else if (token.name === "has" || token.name === "contains") {
            proc = 0; // Expensive in any case
        }
        else if (Array.isArray(token.data)) {
            // "matches" and "not"
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                // TODO better handling of complex selectors
                if (token.data[i].length !== 1)
                    continue;
                var cur = getProcedure(token.data[i][0]);
                // Avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc)
                    proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
                proc -= 1;
        }
        else {
            proc = 1;
        }
    }
    return proc;
}


/***/ }),

/***/ 9751:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringify = exports.parse = void 0;
__exportStar(__webpack_require__(675), exports);
var parse_1 = __webpack_require__(675);
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return __importDefault(parse_1).default; } }));
var stringify_1 = __webpack_require__(6868);
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return __importDefault(stringify_1).default; } }));


/***/ }),

/***/ 675:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTraversal = void 0;
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = new Map([
    ["~", "element"],
    ["^", "start"],
    ["$", "end"],
    ["*", "any"],
    ["!", "not"],
    ["|", "hyphen"],
]);
var Traversals = {
    ">": "child",
    "<": "parent",
    "~": "sibling",
    "+": "adjacent",
};
var attribSelectors = {
    "#": ["id", "equals"],
    ".": ["class", "element"],
};
// Pseudos, whose data property is parsed as well.
var unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context",
]);
var traversalNames = new Set(__spreadArray([
    "descendant"
], Object.keys(Traversals).map(function (k) { return Traversals[k]; }), true));
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    return traversalNames.has(selector.type);
}
exports.isTraversal = isTraversal;
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
var quotes = new Set(['"', "'"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    var high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isWhitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse(selector, options) {
    var subselects = [];
    var endIndex = parseSelector(subselects, "" + selector, options, 0);
    if (endIndex < selector.length) {
        throw new Error("Unmatched selector: " + selector.slice(endIndex));
    }
    return subselects;
}
exports["default"] = parse;
function parseSelector(subselects, selector, options, selectorIndex) {
    var _a, _b;
    if (options === void 0) { options = {}; }
    var tokens = [];
    var sawWS = false;
    function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error("Expected name, found " + selector.slice(selectorIndex));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        while (isWhitespace(selector.charAt(selectorIndex + offset)))
            offset++;
        selectorIndex += offset;
    }
    function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charAt(--pos) === "\\")
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    stripWhitespace(0);
    while (selector !== "") {
        var firstChar = selector.charAt(selectorIndex);
        if (isWhitespace(firstChar)) {
            sawWS = true;
            stripWhitespace(1);
        }
        else if (firstChar in Traversals) {
            ensureNotTraversal();
            tokens.push({ type: Traversals[firstChar] });
            sawWS = false;
            stripWhitespace(1);
        }
        else if (firstChar === ",") {
            if (tokens.length === 0) {
                throw new Error("Empty sub-selector");
            }
            subselects.push(tokens);
            tokens = [];
            sawWS = false;
            stripWhitespace(1);
        }
        else if (selector.startsWith("/*", selectorIndex)) {
            var endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
                throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
        }
        else {
            if (sawWS) {
                ensureNotTraversal();
                tokens.push({ type: "descendant" });
                sawWS = false;
            }
            if (firstChar in attribSelectors) {
                var _c = attribSelectors[firstChar], name_1 = _c[0], action = _c[1];
                tokens.push({
                    type: "attribute",
                    name: name_1,
                    action: action,
                    value: getName(1),
                    namespace: null,
                    // TODO: Add quirksMode option, which makes `ignoreCase` `true` for HTML.
                    ignoreCase: options.xmlMode ? null : false,
                });
            }
            else if (firstChar === "[") {
                stripWhitespace(1);
                // Determine attribute name and namespace
                var namespace = null;
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = "";
                    selectorIndex += 1;
                }
                if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    selectorIndex += 2;
                }
                var name_2 = getName(0);
                if (namespace === null &&
                    selector.charAt(selectorIndex) === "|" &&
                    selector.charAt(selectorIndex + 1) !== "=") {
                    namespace = name_2;
                    name_2 = getName(1);
                }
                if ((_a = options.lowerCaseAttributeNames) !== null && _a !== void 0 ? _a : !options.xmlMode) {
                    name_2 = name_2.toLowerCase();
                }
                stripWhitespace(0);
                // Determine comparison operation
                var action = "exists";
                var possibleAction = actionTypes.get(selector.charAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charAt(selectorIndex + 1) !== "=") {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charAt(selectorIndex) === "=") {
                    action = "equals";
                    stripWhitespace(1);
                }
                // Determine value
                var value = "";
                var ignoreCase = null;
                if (action !== "exists") {
                    if (quotes.has(selector.charAt(selectorIndex))) {
                        var quote = selector.charAt(selectorIndex);
                        var sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        var valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace(selector.charAt(selectorIndex)) &&
                                selector.charAt(selectorIndex) !== "]") ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    var forceIgnore = selector.charAt(selectorIndex);
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === "s" || forceIgnore === "S") {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === "i" || forceIgnore === "I") {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                // If `xmlMode` is set, there are no rules; otherwise, use the `caseInsensitiveAttributes` list.
                if (!options.xmlMode) {
                    // TODO: Skip this for `exists`, as there is no value to compare to.
                    ignoreCase !== null && ignoreCase !== void 0 ? ignoreCase : (ignoreCase = caseInsensitiveAttributes.has(name_2));
                }
                if (selector.charAt(selectorIndex) !== "]") {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                var attributeSelector = {
                    type: "attribute",
                    name: name_2,
                    action: action,
                    value: value,
                    namespace: namespace,
                    ignoreCase: ignoreCase,
                };
                tokens.push(attributeSelector);
            }
            else if (firstChar === ":") {
                if (selector.charAt(selectorIndex + 1) === ":") {
                    tokens.push({
                        type: "pseudo-element",
                        name: getName(2).toLowerCase(),
                    });
                    continue;
                }
                var name_3 = getName(1).toLowerCase();
                var data = null;
                if (selector.charAt(selectorIndex) === "(") {
                    if (unpackPseudos.has(name_3)) {
                        if (quotes.has(selector.charAt(selectorIndex + 1))) {
                            throw new Error("Pseudo-selector " + name_3 + " cannot be quoted");
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, options, selectorIndex + 1);
                        if (selector.charAt(selectorIndex) !== ")") {
                            throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
                        }
                        selectorIndex += 1;
                    }
                    else {
                        selectorIndex += 1;
                        var start = selectorIndex;
                        var counter = 1;
                        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
                            if (selector.charAt(selectorIndex) === "(" &&
                                !isEscaped(selectorIndex)) {
                                counter++;
                            }
                            else if (selector.charAt(selectorIndex) === ")" &&
                                !isEscaped(selectorIndex)) {
                                counter--;
                            }
                        }
                        if (counter) {
                            throw new Error("Parenthesis not matched");
                        }
                        data = selector.slice(start, selectorIndex - 1);
                        if (stripQuotesFromPseudos.has(name_3)) {
                            var quot = data.charAt(0);
                            if (quot === data.slice(-1) && quotes.has(quot)) {
                                data = data.slice(1, -1);
                            }
                            data = unescapeCSS(data);
                        }
                    }
                }
                tokens.push({ type: "pseudo", name: name_3, data: data });
            }
            else {
                var namespace = null;
                var name_4 = void 0;
                if (firstChar === "*") {
                    selectorIndex += 1;
                    name_4 = "*";
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    if (selector.charAt(selectorIndex) === "|") {
                        namespace = "";
                        selectorIndex += 1;
                    }
                    name_4 = getName(0);
                }
                else {
                    /*
                     * We have finished parsing the selector.
                     * Remove descendant tokens at the end if they exist,
                     * and return the last index, so that parsing can be
                     * picked up from here.
                     */
                    if (tokens.length &&
                        tokens[tokens.length - 1].type === "descendant") {
                        tokens.pop();
                    }
                    addToken(subselects, tokens);
                    return selectorIndex;
                }
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = name_4;
                    if (selector.charAt(selectorIndex + 1) === "*") {
                        name_4 = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name_4 = getName(1);
                    }
                }
                if (name_4 === "*") {
                    tokens.push({ type: "universal", namespace: namespace });
                }
                else {
                    if ((_b = options.lowerCaseTags) !== null && _b !== void 0 ? _b : !options.xmlMode) {
                        name_4 = name_4.toLowerCase();
                    }
                    tokens.push({ type: "tag", name: name_4, namespace: namespace });
                }
            }
        }
    }
    addToken(subselects, tokens);
    return selectorIndex;
}
function addToken(subselects, tokens) {
    if (subselects.length > 0 && tokens.length === 0) {
        throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
}


/***/ }),

/***/ 6868:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var actionTypes = {
    equals: "",
    element: "~",
    start: "^",
    end: "$",
    any: "*",
    not: "!",
    hyphen: "|",
};
var charsToEscape = new Set(__spreadArray(__spreadArray([], Object.keys(actionTypes)
    .map(function (typeKey) { return actionTypes[typeKey]; })
    .filter(Boolean), true), [
    ":",
    "[",
    "]",
    " ",
    "\\",
    "(",
    ")",
    "'",
], false));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
    return selector.map(stringifySubselector).join(", ");
}
exports["default"] = stringify;
function stringifySubselector(token) {
    return token.map(stringifyToken).join("");
}
function stringifyToken(token) {
    switch (token.type) {
        // Simple types
        case "child":
            return " > ";
        case "parent":
            return " < ";
        case "sibling":
            return " ~ ";
        case "adjacent":
            return " + ";
        case "descendant":
            return " ";
        case "universal":
            return getNamespace(token.namespace) + "*";
        case "tag":
            return getNamespacedName(token);
        case "pseudo-element":
            return "::" + escapeName(token.name);
        case "pseudo":
            if (token.data === null)
                return ":" + escapeName(token.name);
            if (typeof token.data === "string") {
                return ":" + escapeName(token.name) + "(" + escapeName(token.data) + ")";
            }
            return ":" + escapeName(token.name) + "(" + stringify(token.data) + ")";
        case "attribute": {
            if (token.name === "id" &&
                token.action === "equals" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "#" + escapeName(token.value);
            }
            if (token.name === "class" &&
                token.action === "element" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "." + escapeName(token.value);
            }
            var name_1 = getNamespacedName(token);
            if (token.action === "exists") {
                return "[" + name_1 + "]";
            }
            return "[" + name_1 + actionTypes[token.action] + "='" + escapeName(token.value) + "'" + (token.ignoreCase ? "i" : token.ignoreCase === false ? "s" : "") + "]";
        }
    }
}
function getNamespacedName(token) {
    return "" + getNamespace(token.namespace) + escapeName(token.name);
}
function getNamespace(namespace) {
    return namespace !== null
        ? (namespace === "*" ? "*" : escapeName(namespace)) + "|"
        : "";
}
function escapeName(str) {
    return str
        .split("")
        .map(function (c) { return (charsToEscape.has(c) ? "\\" + c : c); })
        .join("");
}


/***/ }),

/***/ 7837:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"],
]);
exports.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"],
]);


/***/ }),

/***/ 7220:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Module dependencies
 */
var ElementType = __importStar(__webpack_require__(9960));
var entities_1 = __webpack_require__(5863);
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = __webpack_require__(7837);
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    if (!attributes)
        return;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return key + "=\"" + (opts.decodeEntities !== false
            ? entities_1.encodeXML(value)
            : value.replace(/"/g, "&quot;")) + "\"";
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
exports["default"] = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " " + attribs;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<" + elem.data + ">";
}
function renderText(elem, opts) {
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (opts.decodeEntities !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
    return "<!--" + elem.data + "-->";
}


/***/ }),

/***/ 9960:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;


/***/ }),

/***/ 7915:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomHandler = void 0;
var domelementtype_1 = __webpack_require__(9960);
var node_1 = __webpack_require__(7790);
__exportStar(__webpack_require__(7790), exports);
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            }
            else {
                lastNode.data += data;
            }
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        }
        else {
            if (normalizeWhitespace) {
                data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;


/***/ }),

/***/ 7790:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __webpack_require__(9960);
var nodeTypes = new Map([
    [domelementtype_1.ElementType.Tag, 1],
    [domelementtype_1.ElementType.Script, 1],
    [domelementtype_1.ElementType.Style, 1],
    [domelementtype_1.ElementType.Directive, 1],
    [domelementtype_1.ElementType.Text, 3],
    [domelementtype_1.ElementType.CDATA, 4],
    [domelementtype_1.ElementType.Comment, 8],
    [domelementtype_1.ElementType.Root, 9],
]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        /**
         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
         * node {@link type}.
         */
        get: function () {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
exports.Node = Node;
/**
 * A node that contains some data.
 */
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node));
exports.DataNode = DataNode;
/**
 * Text within the document.
 */
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
    }
    return Text;
}(DataNode));
exports.Text = Text;
/**
 * Comments within the document.
 */
var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
    }
    return Comment;
}(DataNode));
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
exports.NodeWithChildren = NodeWithChildren;
/**
 * The root node of the document.
 */
var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
    }
    return Document;
}(NodeWithChildren));
exports.Document = Document;
/**
 * An element within the DOM.
 */
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1.ElementType.Script
            : name === "style"
                ? domelementtype_1.ElementType.Style
                : domelementtype_1.ElementType.Tag; }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment(node.data);
    }
    else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ 6996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFeed = void 0;
var stringify_1 = __webpack_require__(3346);
var legacy_1 = __webpack_require__(3905);
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot
        ? null
        : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
}
exports.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function (item) {
            var _a;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
            if (href) {
                entry.link = href;
            }
            var description = fetch("summary", children) || fetch("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        }),
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch("pubDate", children);
            if (pubDate)
                entry.pubDate = new Date(pubDate);
            return entry;
        }),
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
    return (0, legacy_1.getElementsByTagName)("media:content", where).map(function (elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs.medium,
            isDefault: !!attribs.isDefault,
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs.expression) {
            media.expression =
                attribs.expression;
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
    return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where  Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var val = fetch(tagName, where, recurse);
    if (val)
        obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}


/***/ }),

/***/ 4975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __webpack_require__(7915);
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    if (sharedParent === nodeA) {
        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
    }
    return 2 /* PRECEDING */;
}
exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort;


/***/ }),

/***/ 9432:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__webpack_require__(3346), exports);
__exportStar(__webpack_require__(5010), exports);
__exportStar(__webpack_require__(6765), exports);
__exportStar(__webpack_require__(8043), exports);
__exportStar(__webpack_require__(3905), exports);
__exportStar(__webpack_require__(4975), exports);
__exportStar(__webpack_require__(6996), exports);
/** @deprecated Use these methods from `domhandler` directly. */
var domhandler_1 = __webpack_require__(7915);
Object.defineProperty(exports, "isTag", ({ enumerable: true, get: function () { return domhandler_1.isTag; } }));
Object.defineProperty(exports, "isCDATA", ({ enumerable: true, get: function () { return domhandler_1.isCDATA; } }));
Object.defineProperty(exports, "isText", ({ enumerable: true, get: function () { return domhandler_1.isText; } }));
Object.defineProperty(exports, "isComment", ({ enumerable: true, get: function () { return domhandler_1.isComment; } }));
Object.defineProperty(exports, "isDocument", ({ enumerable: true, get: function () { return domhandler_1.isDocument; } }));
Object.defineProperty(exports, "hasChildren", ({ enumerable: true, get: function () { return domhandler_1.hasChildren; } }));


/***/ }),

/***/ 3905:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __webpack_require__(7915);
var querying_1 = __webpack_require__(8043);
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1.isTag;
        }
        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
        }
        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType;


/***/ }),

/***/ 6765:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend;


/***/ }),

/***/ 8043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __webpack_require__(7915);
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find(test, node, recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1.isTag)(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
        }
    }
    return elem;
}
exports.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne(test, nodes) {
    return nodes.some(function (checked) {
        return (0, domhandler_1.isTag)(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children)));
    });
}
exports.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
exports.findAll = findAll;


/***/ }),

/***/ 3346:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __webpack_require__(7915);
var dom_serializer_1 = __importDefault(__webpack_require__(7220));
var domelementtype_1 = __webpack_require__(9960);
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return (0, domhandler_1.hasChildren)(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.getText = getText;
/**
 * Get a node's text content.
 *
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.innerText = innerText;


/***/ }),

/***/ 5010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __webpack_require__(7915);
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    var _a;
    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
        (_a = next, next = _a.next);
    return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
exports.prevElementSibling = prevElementSibling;


/***/ }),

/***/ 4076:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__webpack_require__(9323));
var legacy_json_1 = __importDefault(__webpack_require__(9591));
var xml_json_1 = __importDefault(__webpack_require__(2586));
var decode_codepoint_1 = __importDefault(__webpack_require__(26));
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}


/***/ }),

/***/ 26:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var decode_json_1 = __importDefault(__webpack_require__(3600));
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
}
exports["default"] = decodeCodePoint;


/***/ }),

/***/ 7322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__webpack_require__(2586));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault(__webpack_require__(9323));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
}
exports.escape = escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
exports.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}


/***/ }),

/***/ 5863:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __webpack_require__(4076);
var encode_1 = __webpack_require__(7322);
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__(7322);
Object.defineProperty(exports, "encodeXML", ({ enumerable: true, get: function () { return encode_2.encodeXML; } }));
Object.defineProperty(exports, "encodeHTML", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({ enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } }));
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return encode_2.escape; } }));
Object.defineProperty(exports, "escapeUTF8", ({ enumerable: true, get: function () { return encode_2.escapeUTF8; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeHTML5", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
var decode_2 = __webpack_require__(4076);
Object.defineProperty(exports, "decodeXML", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));
Object.defineProperty(exports, "decodeHTML", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTMLStrict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML5", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML4Strict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeHTML5Strict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeXMLStrict", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));


/***/ }),

/***/ 8460:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = tokenize

var literals100 = __webpack_require__(7529)
  , operators = __webpack_require__(7679)
  , builtins100 = __webpack_require__(2222)
  , literals300es = __webpack_require__(2914)
  , builtins300es = __webpack_require__(9537)

var NORMAL = 999          // <-- never emitted
  , TOKEN = 9999          // <-- never emitted
  , BLOCK_COMMENT = 0
  , LINE_COMMENT = 1
  , PREPROCESSOR = 2
  , OPERATOR = 3
  , INTEGER = 4
  , FLOAT = 5
  , IDENT = 6
  , BUILTIN = 7
  , KEYWORD = 8
  , WHITESPACE = 9
  , EOF = 10
  , HEX = 11

var map = [
    'block-comment'
  , 'line-comment'
  , 'preprocessor'
  , 'operator'
  , 'integer'
  , 'float'
  , 'ident'
  , 'builtin'
  , 'keyword'
  , 'whitespace'
  , 'eof'
  , 'integer'
]

function tokenize(opt) {
  var i = 0
    , total = 0
    , mode = NORMAL
    , c
    , last
    , content = []
    , tokens = []
    , token_idx = 0
    , token_offs = 0
    , line = 1
    , col = 0
    , start = 0
    , isnum = false
    , isoperator = false
    , input = ''
    , len

  opt = opt || {}
  var allBuiltins = builtins100
  var allLiterals = literals100
  if (opt.version === '300 es') {
    allBuiltins = builtins300es
    allLiterals = literals300es
  }

  // cache by name
  var builtinsDict = {}, literalsDict = {}
  for (var i = 0; i < allBuiltins.length; i++) {
    builtinsDict[allBuiltins[i]] = true
  }
  for (var i = 0; i < allLiterals.length; i++) {
    literalsDict[allLiterals[i]] = true
  }

  return function(data) {
    tokens = []
    if (data !== null) return write(data)
    return end()
  }

  function token(data) {
    if (data.length) {
      tokens.push({
        type: map[mode]
      , data: data
      , position: start
      , line: line
      , column: col
      })
    }
  }

  function write(chunk) {
    i = 0

    if (chunk.toString) chunk = chunk.toString()

    input += chunk.replace(/\r\n/g, '\n')
    len = input.length


    var last

    while(c = input[i], i < len) {
      last = i

      switch(mode) {
        case BLOCK_COMMENT: i = block_comment(); break
        case LINE_COMMENT: i = line_comment(); break
        case PREPROCESSOR: i = preprocessor(); break
        case OPERATOR: i = operator(); break
        case INTEGER: i = integer(); break
        case HEX: i = hex(); break
        case FLOAT: i = decimal(); break
        case TOKEN: i = readtoken(); break
        case WHITESPACE: i = whitespace(); break
        case NORMAL: i = normal(); break
      }

      if(last !== i) {
        switch(input[last]) {
          case '\n': col = 0; ++line; break
          default: ++col; break
        }
      }
    }

    total += i
    input = input.slice(i)
    return tokens
  }

  function end(chunk) {
    if(content.length) {
      token(content.join(''))
    }

    mode = EOF
    token('(eof)')
    return tokens
  }

  function normal() {
    content = content.length ? [] : content

    if(last === '/' && c === '*') {
      start = total + i - 1
      mode = BLOCK_COMMENT
      last = c
      return i + 1
    }

    if(last === '/' && c === '/') {
      start = total + i - 1
      mode = LINE_COMMENT
      last = c
      return i + 1
    }

    if(c === '#') {
      mode = PREPROCESSOR
      start = total + i
      return i
    }

    if(/\s/.test(c)) {
      mode = WHITESPACE
      start = total + i
      return i
    }

    isnum = /\d/.test(c)
    isoperator = /[^\w_]/.test(c)

    start = total + i
    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN
    return i
  }

  function whitespace() {
    if(/[^\s]/g.test(c)) {
      token(content.join(''))
      mode = NORMAL
      return i
    }
    content.push(c)
    last = c
    return i + 1
  }

  function preprocessor() {
    if((c === '\r' || c === '\n') && last !== '\\') {
      token(content.join(''))
      mode = NORMAL
      return i
    }
    content.push(c)
    last = c
    return i + 1
  }

  function line_comment() {
    return preprocessor()
  }

  function block_comment() {
    if(c === '/' && last === '*') {
      content.push(c)
      token(content.join(''))
      mode = NORMAL
      return i + 1
    }

    content.push(c)
    last = c
    return i + 1
  }

  function operator() {
    if(last === '.' && /\d/.test(c)) {
      mode = FLOAT
      return i
    }

    if(last === '/' && c === '*') {
      mode = BLOCK_COMMENT
      return i
    }

    if(last === '/' && c === '/') {
      mode = LINE_COMMENT
      return i
    }

    if(c === '.' && content.length) {
      while(determine_operator(content));

      mode = FLOAT
      return i
    }

    if(c === ';' || c === ')' || c === '(') {
      if(content.length) while(determine_operator(content));
      token(c)
      mode = NORMAL
      return i + 1
    }

    var is_composite_operator = content.length === 2 && c !== '='
    if(/[\w_\d\s]/.test(c) || is_composite_operator) {
      while(determine_operator(content));
      mode = NORMAL
      return i
    }

    content.push(c)
    last = c
    return i + 1
  }

  function determine_operator(buf) {
    var j = 0
      , idx
      , res

    do {
      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))
      res = operators[idx]

      if(idx === -1) {
        if(j-- + buf.length > 0) continue
        res = buf.slice(0, 1).join('')
      }

      token(res)

      start += res.length
      content = content.slice(res.length)
      return content.length
    } while(1)
  }

  function hex() {
    if(/[^a-fA-F0-9]/.test(c)) {
      token(content.join(''))
      mode = NORMAL
      return i
    }

    content.push(c)
    last = c
    return i + 1
  }

  function integer() {
    if(c === '.') {
      content.push(c)
      mode = FLOAT
      last = c
      return i + 1
    }

    if(/[eE]/.test(c)) {
      content.push(c)
      mode = FLOAT
      last = c
      return i + 1
    }

    if(c === 'x' && content.length === 1 && content[0] === '0') {
      mode = HEX
      content.push(c)
      last = c
      return i + 1
    }

    if(/[^\d]/.test(c)) {
      token(content.join(''))
      mode = NORMAL
      return i
    }

    content.push(c)
    last = c
    return i + 1
  }

  function decimal() {
    if(c === 'f') {
      content.push(c)
      last = c
      i += 1
    }

    if(/[eE]/.test(c)) {
      content.push(c)
      last = c
      return i + 1
    }

    if ((c === '-' || c === '+') && /[eE]/.test(last)) {
      content.push(c)
      last = c
      return i + 1
    }

    if(/[^\d]/.test(c)) {
      token(content.join(''))
      mode = NORMAL
      return i
    }

    content.push(c)
    last = c
    return i + 1
  }

  function readtoken() {
    if(/[^\d\w_]/.test(c)) {
      var contentstr = content.join('')
      if(literalsDict[contentstr]) {
        mode = KEYWORD
      } else if(builtinsDict[contentstr]) {
        mode = BUILTIN
      } else {
        mode = IDENT
      }
      token(content.join(''))
      mode = NORMAL
      return i
    }
    content.push(c)
    last = c
    return i + 1
  }
}


/***/ }),

/***/ 9537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 300es builtins/reserved words that were previously valid in v100
var v100 = __webpack_require__(2222)

// The texture2D|Cube functions have been removed
// And the gl_ features are updated
v100 = v100.slice().filter(function (b) {
  return !/^(gl\_|texture)/.test(b)
})

module.exports = v100.concat([
  // the updated gl_ constants
    'gl_VertexID'
  , 'gl_InstanceID'
  , 'gl_Position'
  , 'gl_PointSize'
  , 'gl_FragCoord'
  , 'gl_FrontFacing'
  , 'gl_FragDepth'
  , 'gl_PointCoord'
  , 'gl_MaxVertexAttribs'
  , 'gl_MaxVertexUniformVectors'
  , 'gl_MaxVertexOutputVectors'
  , 'gl_MaxFragmentInputVectors'
  , 'gl_MaxVertexTextureImageUnits'
  , 'gl_MaxCombinedTextureImageUnits'
  , 'gl_MaxTextureImageUnits'
  , 'gl_MaxFragmentUniformVectors'
  , 'gl_MaxDrawBuffers'
  , 'gl_MinProgramTexelOffset'
  , 'gl_MaxProgramTexelOffset'
  , 'gl_DepthRangeParameters'
  , 'gl_DepthRange'

  // other builtins
  , 'trunc'
  , 'round'
  , 'roundEven'
  , 'isnan'
  , 'isinf'
  , 'floatBitsToInt'
  , 'floatBitsToUint'
  , 'intBitsToFloat'
  , 'uintBitsToFloat'
  , 'packSnorm2x16'
  , 'unpackSnorm2x16'
  , 'packUnorm2x16'
  , 'unpackUnorm2x16'
  , 'packHalf2x16'
  , 'unpackHalf2x16'
  , 'outerProduct'
  , 'transpose'
  , 'determinant'
  , 'inverse'
  , 'texture'
  , 'textureSize'
  , 'textureProj'
  , 'textureLod'
  , 'textureOffset'
  , 'texelFetch'
  , 'texelFetchOffset'
  , 'textureProjOffset'
  , 'textureLodOffset'
  , 'textureProjLod'
  , 'textureProjLodOffset'
  , 'textureGrad'
  , 'textureGradOffset'
  , 'textureProjGrad'
  , 'textureProjGradOffset'
])


/***/ }),

/***/ 2222:
/***/ ((module) => {

module.exports = [
  // Keep this list sorted
  'abs'
  , 'acos'
  , 'all'
  , 'any'
  , 'asin'
  , 'atan'
  , 'ceil'
  , 'clamp'
  , 'cos'
  , 'cross'
  , 'dFdx'
  , 'dFdy'
  , 'degrees'
  , 'distance'
  , 'dot'
  , 'equal'
  , 'exp'
  , 'exp2'
  , 'faceforward'
  , 'floor'
  , 'fract'
  , 'gl_BackColor'
  , 'gl_BackLightModelProduct'
  , 'gl_BackLightProduct'
  , 'gl_BackMaterial'
  , 'gl_BackSecondaryColor'
  , 'gl_ClipPlane'
  , 'gl_ClipVertex'
  , 'gl_Color'
  , 'gl_DepthRange'
  , 'gl_DepthRangeParameters'
  , 'gl_EyePlaneQ'
  , 'gl_EyePlaneR'
  , 'gl_EyePlaneS'
  , 'gl_EyePlaneT'
  , 'gl_Fog'
  , 'gl_FogCoord'
  , 'gl_FogFragCoord'
  , 'gl_FogParameters'
  , 'gl_FragColor'
  , 'gl_FragCoord'
  , 'gl_FragData'
  , 'gl_FragDepth'
  , 'gl_FragDepthEXT'
  , 'gl_FrontColor'
  , 'gl_FrontFacing'
  , 'gl_FrontLightModelProduct'
  , 'gl_FrontLightProduct'
  , 'gl_FrontMaterial'
  , 'gl_FrontSecondaryColor'
  , 'gl_LightModel'
  , 'gl_LightModelParameters'
  , 'gl_LightModelProducts'
  , 'gl_LightProducts'
  , 'gl_LightSource'
  , 'gl_LightSourceParameters'
  , 'gl_MaterialParameters'
  , 'gl_MaxClipPlanes'
  , 'gl_MaxCombinedTextureImageUnits'
  , 'gl_MaxDrawBuffers'
  , 'gl_MaxFragmentUniformComponents'
  , 'gl_MaxLights'
  , 'gl_MaxTextureCoords'
  , 'gl_MaxTextureImageUnits'
  , 'gl_MaxTextureUnits'
  , 'gl_MaxVaryingFloats'
  , 'gl_MaxVertexAttribs'
  , 'gl_MaxVertexTextureImageUnits'
  , 'gl_MaxVertexUniformComponents'
  , 'gl_ModelViewMatrix'
  , 'gl_ModelViewMatrixInverse'
  , 'gl_ModelViewMatrixInverseTranspose'
  , 'gl_ModelViewMatrixTranspose'
  , 'gl_ModelViewProjectionMatrix'
  , 'gl_ModelViewProjectionMatrixInverse'
  , 'gl_ModelViewProjectionMatrixInverseTranspose'
  , 'gl_ModelViewProjectionMatrixTranspose'
  , 'gl_MultiTexCoord0'
  , 'gl_MultiTexCoord1'
  , 'gl_MultiTexCoord2'
  , 'gl_MultiTexCoord3'
  , 'gl_MultiTexCoord4'
  , 'gl_MultiTexCoord5'
  , 'gl_MultiTexCoord6'
  , 'gl_MultiTexCoord7'
  , 'gl_Normal'
  , 'gl_NormalMatrix'
  , 'gl_NormalScale'
  , 'gl_ObjectPlaneQ'
  , 'gl_ObjectPlaneR'
  , 'gl_ObjectPlaneS'
  , 'gl_ObjectPlaneT'
  , 'gl_Point'
  , 'gl_PointCoord'
  , 'gl_PointParameters'
  , 'gl_PointSize'
  , 'gl_Position'
  , 'gl_ProjectionMatrix'
  , 'gl_ProjectionMatrixInverse'
  , 'gl_ProjectionMatrixInverseTranspose'
  , 'gl_ProjectionMatrixTranspose'
  , 'gl_SecondaryColor'
  , 'gl_TexCoord'
  , 'gl_TextureEnvColor'
  , 'gl_TextureMatrix'
  , 'gl_TextureMatrixInverse'
  , 'gl_TextureMatrixInverseTranspose'
  , 'gl_TextureMatrixTranspose'
  , 'gl_Vertex'
  , 'greaterThan'
  , 'greaterThanEqual'
  , 'inversesqrt'
  , 'length'
  , 'lessThan'
  , 'lessThanEqual'
  , 'log'
  , 'log2'
  , 'matrixCompMult'
  , 'max'
  , 'min'
  , 'mix'
  , 'mod'
  , 'normalize'
  , 'not'
  , 'notEqual'
  , 'pow'
  , 'radians'
  , 'reflect'
  , 'refract'
  , 'sign'
  , 'sin'
  , 'smoothstep'
  , 'sqrt'
  , 'step'
  , 'tan'
  , 'texture2D'
  , 'texture2DLod'
  , 'texture2DProj'
  , 'texture2DProjLod'
  , 'textureCube'
  , 'textureCubeLod'
  , 'texture2DLodEXT'
  , 'texture2DProjLodEXT'
  , 'textureCubeLodEXT'
  , 'texture2DGradEXT'
  , 'texture2DProjGradEXT'
  , 'textureCubeGradEXT'
]


/***/ }),

/***/ 2914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v100 = __webpack_require__(7529)

module.exports = v100.slice().concat([
   'layout'
  , 'centroid'
  , 'smooth'
  , 'case'
  , 'mat2x2'
  , 'mat2x3'
  , 'mat2x4'
  , 'mat3x2'
  , 'mat3x3'
  , 'mat3x4'
  , 'mat4x2'
  , 'mat4x3'
  , 'mat4x4'
  , 'uvec2'
  , 'uvec3'
  , 'uvec4'
  , 'samplerCubeShadow'
  , 'sampler2DArray'
  , 'sampler2DArrayShadow'
  , 'isampler2D'
  , 'isampler3D'
  , 'isamplerCube'
  , 'isampler2DArray'
  , 'usampler2D'
  , 'usampler3D'
  , 'usamplerCube'
  , 'usampler2DArray'
  , 'coherent'
  , 'restrict'
  , 'readonly'
  , 'writeonly'
  , 'resource'
  , 'atomic_uint'
  , 'noperspective'
  , 'patch'
  , 'sample'
  , 'subroutine'
  , 'common'
  , 'partition'
  , 'active'
  , 'filter'
  , 'image1D'
  , 'image2D'
  , 'image3D'
  , 'imageCube'
  , 'iimage1D'
  , 'iimage2D'
  , 'iimage3D'
  , 'iimageCube'
  , 'uimage1D'
  , 'uimage2D'
  , 'uimage3D'
  , 'uimageCube'
  , 'image1DArray'
  , 'image2DArray'
  , 'iimage1DArray'
  , 'iimage2DArray'
  , 'uimage1DArray'
  , 'uimage2DArray'
  , 'image1DShadow'
  , 'image2DShadow'
  , 'image1DArrayShadow'
  , 'image2DArrayShadow'
  , 'imageBuffer'
  , 'iimageBuffer'
  , 'uimageBuffer'
  , 'sampler1DArray'
  , 'sampler1DArrayShadow'
  , 'isampler1D'
  , 'isampler1DArray'
  , 'usampler1D'
  , 'usampler1DArray'
  , 'isampler2DRect'
  , 'usampler2DRect'
  , 'samplerBuffer'
  , 'isamplerBuffer'
  , 'usamplerBuffer'
  , 'sampler2DMS'
  , 'isampler2DMS'
  , 'usampler2DMS'
  , 'sampler2DMSArray'
  , 'isampler2DMSArray'
  , 'usampler2DMSArray'
])


/***/ }),

/***/ 7529:
/***/ ((module) => {

module.exports = [
  // current
    'precision'
  , 'highp'
  , 'mediump'
  , 'lowp'
  , 'attribute'
  , 'const'
  , 'uniform'
  , 'varying'
  , 'break'
  , 'continue'
  , 'do'
  , 'for'
  , 'while'
  , 'if'
  , 'else'
  , 'in'
  , 'out'
  , 'inout'
  , 'float'
  , 'int'
  , 'uint'
  , 'void'
  , 'bool'
  , 'true'
  , 'false'
  , 'discard'
  , 'return'
  , 'mat2'
  , 'mat3'
  , 'mat4'
  , 'vec2'
  , 'vec3'
  , 'vec4'
  , 'ivec2'
  , 'ivec3'
  , 'ivec4'
  , 'bvec2'
  , 'bvec3'
  , 'bvec4'
  , 'sampler1D'
  , 'sampler2D'
  , 'sampler3D'
  , 'samplerCube'
  , 'sampler1DShadow'
  , 'sampler2DShadow'
  , 'struct'

  // future
  , 'asm'
  , 'class'
  , 'union'
  , 'enum'
  , 'typedef'
  , 'template'
  , 'this'
  , 'packed'
  , 'goto'
  , 'switch'
  , 'default'
  , 'inline'
  , 'noinline'
  , 'volatile'
  , 'public'
  , 'static'
  , 'extern'
  , 'external'
  , 'interface'
  , 'long'
  , 'short'
  , 'double'
  , 'half'
  , 'fixed'
  , 'unsigned'
  , 'input'
  , 'output'
  , 'hvec2'
  , 'hvec3'
  , 'hvec4'
  , 'dvec2'
  , 'dvec3'
  , 'dvec4'
  , 'fvec2'
  , 'fvec3'
  , 'fvec4'
  , 'sampler2DRect'
  , 'sampler3DRect'
  , 'sampler2DRectShadow'
  , 'sizeof'
  , 'cast'
  , 'namespace'
  , 'using'
]


/***/ }),

/***/ 7679:
/***/ ((module) => {

module.exports = [
    '<<='
  , '>>='
  , '++'
  , '--'
  , '<<'
  , '>>'
  , '<='
  , '>='
  , '=='
  , '!='
  , '&&'
  , '||'
  , '+='
  , '-='
  , '*='
  , '/='
  , '%='
  , '&='
  , '^^'
  , '^='
  , '|='
  , '('
  , ')'
  , '['
  , ']'
  , '.'
  , '!'
  , '~'
  , '*'
  , '/'
  , '%'
  , '+'
  , '-'
  , '<'
  , '>'
  , '&'
  , '^'
  , '|'
  , '?'
  , ':'
  , '='
  , ','
  , ';'
  , '{'
  , '}'
]


/***/ }),

/***/ 9932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var tokenize = __webpack_require__(8460)

module.exports = tokenizeString

function tokenizeString(str, opt) {
  var generator = tokenize(opt)
  var tokens = []

  tokens = tokens.concat(generator(str))
  tokens = tokens.concat(generator(null))

  return tokens
}


/***/ }),

/***/ 8552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 1989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(1789),
    hashDelete = __webpack_require__(401),
    hashGet = __webpack_require__(7667),
    hashHas = __webpack_require__(1327),
    hashSet = __webpack_require__(1866);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 8407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(7040),
    listCacheDelete = __webpack_require__(4125),
    listCacheGet = __webpack_require__(2117),
    listCacheHas = __webpack_require__(7518),
    listCacheSet = __webpack_require__(4705);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 7071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 3369:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(4785),
    mapCacheDelete = __webpack_require__(1285),
    mapCacheGet = __webpack_require__(6000),
    mapCacheHas = __webpack_require__(9916),
    mapCacheSet = __webpack_require__(5265);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 3818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 8525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 8668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(3369),
    setCacheAdd = __webpack_require__(619),
    setCacheHas = __webpack_require__(2385);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ 6384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407),
    stackClear = __webpack_require__(7465),
    stackDelete = __webpack_require__(3779),
    stackGet = __webpack_require__(7599),
    stackHas = __webpack_require__(4758),
    stackSet = __webpack_require__(4309);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 2705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 1149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 7412:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ 4963:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 4636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(2545),
    isArguments = __webpack_require__(5694),
    isArray = __webpack_require__(1469),
    isBuffer = __webpack_require__(4144),
    isIndex = __webpack_require__(5776),
    isTypedArray = __webpack_require__(6719);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 2488:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 2908:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ 4865:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(9465),
    eq = __webpack_require__(7813);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ 8470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(7813);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 4037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(8363),
    keys = __webpack_require__(3674);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ 3886:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(8363),
    keysIn = __webpack_require__(1704);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ 9465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(8777);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ 5990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(6384),
    arrayEach = __webpack_require__(7412),
    assignValue = __webpack_require__(4865),
    baseAssign = __webpack_require__(4037),
    baseAssignIn = __webpack_require__(3886),
    cloneBuffer = __webpack_require__(4626),
    copyArray = __webpack_require__(278),
    copySymbols = __webpack_require__(8805),
    copySymbolsIn = __webpack_require__(1911),
    getAllKeys = __webpack_require__(8234),
    getAllKeysIn = __webpack_require__(6904),
    getTag = __webpack_require__(4160),
    initCloneArray = __webpack_require__(3824),
    initCloneByTag = __webpack_require__(9148),
    initCloneObject = __webpack_require__(8517),
    isArray = __webpack_require__(1469),
    isBuffer = __webpack_require__(4144),
    isMap = __webpack_require__(6688),
    isObject = __webpack_require__(3218),
    isSet = __webpack_require__(2928),
    keys = __webpack_require__(3674),
    keysIn = __webpack_require__(1704);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ 3118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(3218);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ 4055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(2488),
    isArray = __webpack_require__(1469);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 4239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705),
    getRawTag = __webpack_require__(9607),
    objectToString = __webpack_require__(2333);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 9454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(2492),
    isObjectLike = __webpack_require__(7005);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(6384),
    equalArrays = __webpack_require__(7114),
    equalByTag = __webpack_require__(8351),
    equalObjects = __webpack_require__(6096),
    getTag = __webpack_require__(4160),
    isArray = __webpack_require__(1469),
    isBuffer = __webpack_require__(4144),
    isTypedArray = __webpack_require__(6719);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ 5588:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(4160),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ 8458:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(3560),
    isMasked = __webpack_require__(5346),
    isObject = __webpack_require__(3218),
    toSource = __webpack_require__(346);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 9221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(4160),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ 8749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isLength = __webpack_require__(1780),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(5726),
    nativeKeys = __webpack_require__(6916);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 313:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(3218),
    isPrototype = __webpack_require__(5726),
    nativeKeysIn = __webpack_require__(3498);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ 2545:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 1717:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 4757:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ 4318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(1149);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ 4626:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(5639);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ 7157:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(4318);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ 3147:
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ 419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ 7133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(4318);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ 278:
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ 8363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(4865),
    baseAssignValue = __webpack_require__(9465);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ 8805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(8363),
    getSymbols = __webpack_require__(9551);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ 1911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(8363),
    getSymbolsIn = __webpack_require__(1442);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ 4429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 8777:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ 7114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(8668),
    arraySome = __webpack_require__(2908),
    cacheHas = __webpack_require__(4757);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ 8351:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705),
    Uint8Array = __webpack_require__(1149),
    eq = __webpack_require__(7813),
    equalArrays = __webpack_require__(7114),
    mapToArray = __webpack_require__(8776),
    setToArray = __webpack_require__(1814);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ 6096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(8234);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ 1957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ 8234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(4055),
    getSymbols = __webpack_require__(9551),
    keys = __webpack_require__(3674);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 6904:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(4055),
    getSymbolsIn = __webpack_require__(1442),
    keysIn = __webpack_require__(1704);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ 5050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(7019);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(8458),
    getValue = __webpack_require__(7801);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 5924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(5569);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ 9607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 9551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(4963),
    stubArray = __webpack_require__(479);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 1442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(2488),
    getPrototype = __webpack_require__(5924),
    getSymbols = __webpack_require__(9551),
    stubArray = __webpack_require__(479);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ 4160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(8552),
    Map = __webpack_require__(7071),
    Promise = __webpack_require__(3818),
    Set = __webpack_require__(8525),
    WeakMap = __webpack_require__(577),
    baseGetTag = __webpack_require__(4239),
    toSource = __webpack_require__(346);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 7801:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 1789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 401:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 7667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 1327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 1866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 3824:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ 9148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(4318),
    cloneDataView = __webpack_require__(7157),
    cloneRegExp = __webpack_require__(3147),
    cloneSymbol = __webpack_require__(419),
    cloneTypedArray = __webpack_require__(7133);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ 8517:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(3118),
    getPrototype = __webpack_require__(5924),
    isPrototype = __webpack_require__(5726);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ 5776:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 7019:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 5346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(4429);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 5726:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 7040:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 4125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 2117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 7518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 4705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 4785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(1989),
    ListCache = __webpack_require__(8407),
    Map = __webpack_require__(7071);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 1285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 6000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 9916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 5265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 8776:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ 4536:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 6916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(5569);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 3498:
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ 1167:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(1957);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 2333:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 5569:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 5639:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(1957);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 619:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ 2385:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ 1814:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ 7465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 3779:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 7599:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 4758:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 4309:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407),
    Map = __webpack_require__(7071),
    MapCache = __webpack_require__(3369);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 346:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 361:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(5990);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ 7813:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 5694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(9454),
    isObjectLike = __webpack_require__(7005);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 1469:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 8612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(3560),
    isLength = __webpack_require__(1780);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 4144:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(5639),
    stubFalse = __webpack_require__(5062);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 8446:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(939);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),

/***/ 3560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isObject = __webpack_require__(3218);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 1780:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 6688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(5588),
    baseUnary = __webpack_require__(1717),
    nodeUtil = __webpack_require__(1167);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ 3218:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 7005:
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 2928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(9221),
    baseUnary = __webpack_require__(1717),
    nodeUtil = __webpack_require__(1167);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ 6719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(8749),
    baseUnary = __webpack_require__(1717),
    nodeUtil = __webpack_require__(1167);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 3674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(4636),
    baseKeys = __webpack_require__(280),
    isArrayLike = __webpack_require__(8612);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 1704:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(4636),
    baseKeysIn = __webpack_require__(313),
    isArrayLike = __webpack_require__(8612);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ 479:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 5062:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 9769:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = void 0;
var boolbase_1 = __webpack_require__(1073);
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function compile(parsed) {
    var a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    var b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */
    if (b < 0 && a <= 0)
        return boolbase_1.falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1)
        return function (index) { return index <= b; };
    if (a === 0)
        return function (index) { return index === b; };
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1)
        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */
    var absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    var bMod = ((b % absA) + absA) % absA;
    return a > 1
        ? function (index) { return index >= b && index % absA === bMod; }
        : function (index) { return index <= b && index % absA === bMod; };
}
exports.compile = compile;


/***/ }),

/***/ 7540:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = exports.parse = void 0;
var parse_1 = __webpack_require__(7766);
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return parse_1.parse; } }));
var compile_1 = __webpack_require__(9769);
Object.defineProperty(exports, "compile", ({ enumerable: true, get: function () { return compile_1.compile; } }));
/**
 * Parses and compiles a formula to a highly optimized function.
 * Combination of `parse` and `compile`.
 *
 * If the formula doesn't match any elements,
 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
 * Otherwise, a function accepting an _index_ is returned, which returns
 * whether or not the passed _index_ matches the formula.
 *
 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
 *
 * @param formula The formula to compile.
 * @example
 * const check = nthCheck("2n+3");
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function nthCheck(formula) {
    return (0, compile_1.compile)((0, parse_1.parse)(formula));
}
exports["default"] = nthCheck;


/***/ }),

/***/ 7766:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = void 0;
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
var whitespace = new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
        return [2, 0];
    }
    else if (formula === "odd") {
        return [2, 1];
    }
    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    var idx = 0;
    var a = 0;
    var sign = readSign();
    var number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
        }
        else {
            sign = number = 0;
        }
    }
    // Throw if there is anything else
    if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('" + formula + "')");
    }
    return [a, sign * number];
    function readSign() {
        if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
        }
        if (formula.charAt(idx) === "+") {
            idx++;
        }
        return 1;
    }
    function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length &&
            formula.charCodeAt(idx) >= ZERO &&
            formula.charCodeAt(idx) <= NINE) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
        }
        // Return `null` if we didn't read anything.
        return idx === start ? null : value;
    }
    function skipWhitespace() {
        while (idx < formula.length &&
            whitespace.has(formula.charCodeAt(idx))) {
            idx++;
        }
    }
}
exports.parse = parse;


/***/ }),

/***/ 3981:
/***/ ((__unused_webpack_module, exports) => {

/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
exports.make = function (x) {
  if (x == null) {
    x = [];
  }
  if (!(x instanceof Array)) {
    x = [+x != null ? +x : 0];
  }
  return x;
};

exports.nest = (a, b) => a.concat(b);

exports.compare = function (a, b) {
  const n = Math.min(a.length, b.length);
  for (
    let i = 0, end = n, asc = 0 <= end;
    asc ? i < end : i > end;
    asc ? i++ : i--
  ) {
    const p = a[i];
    const q = b[i];
    if (p > q) {
      return -1;
    }
    if (p < q) {
      return 1;
    }
  }
  a = a.length;
  b = b.length;
  if (a > b) {
    return -1;
  } else if (a < b) {
    return 1;
  } else {
    return 0;
  }
};

exports.max = function (a, b) {
  if (exports.compare(a, b) > 0) {
    return b;
  } else {
    return a;
  }
};


/***/ }),

/***/ 3466:
/***/ (function(module) {

// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){ true?module.exports=e():0})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});


/***/ }),

/***/ 824:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__824__;

/***/ }),

/***/ 3600:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');

/***/ }),

/***/ 9323:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');

/***/ }),

/***/ 9591:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');

/***/ }),

/***/ 2586:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Context": () => (/* binding */ src_Context),
  "DOM": () => (/* binding */ src_DOM),
  "Model": () => (/* binding */ src_Model),
  "Overlay": () => (/* binding */ src_Overlay),
  "Primitives": () => (/* binding */ Primitives),
  "Render": () => (/* binding */ Render),
  "Shaders": () => (/* binding */ Shaders),
  "Stage": () => (/* binding */ Stage),
  "Util": () => (/* binding */ Util),
  "e": () => (/* binding */ e),
  "mathBox": () => (/* binding */ mathBox),
  "version": () => (/* binding */ version),
  "π": () => (/* binding */ π),
  "τ": () => (/* binding */ τ)
});

// NAMESPACE OBJECT: ./src/util/pretty.js
var pretty_namespaceObject = {};
__webpack_require__.r(pretty_namespaceObject);
__webpack_require__.d(pretty_namespaceObject, {
  "JSX": () => (JSX),
  "format": () => (prettyFormat),
  "markup": () => (prettyMarkup),
  "number": () => (prettyNumber),
  "print": () => (prettyPrint)
});

// NAMESPACE OBJECT: ./src/model/index.js
var src_model_namespaceObject = {};
__webpack_require__.r(src_model_namespaceObject);
__webpack_require__.d(src_model_namespaceObject, {
  "Attributes": () => (Attributes),
  "Group": () => (Group),
  "Guard": () => (Guard),
  "Model": () => (Model),
  "Node": () => (node_Node)
});

// NAMESPACE OBJECT: ./src/util/vdom.js
var vdom_namespaceObject = {};
__webpack_require__.r(vdom_namespaceObject);
__webpack_require__.d(vdom_namespaceObject, {
  "Types": () => (Types),
  "apply": () => (apply),
  "createClass": () => (createClass),
  "element": () => (vdom_element),
  "hint": () => (hint),
  "recycle": () => (recycle)
});

// NAMESPACE OBJECT: ./src/overlay/index.js
var src_overlay_namespaceObject = {};
__webpack_require__.r(src_overlay_namespaceObject);
__webpack_require__.d(src_overlay_namespaceObject, {
  "Classes": () => (Classes),
  "Factory": () => (OverlayFactory),
  "Overlay": () => (Overlay)
});

// NAMESPACE OBJECT: ./src/util/three.js
var three_namespaceObject = {};
__webpack_require__.r(three_namespaceObject);
__webpack_require__.d(three_namespaceObject, {
  "paramToArrayStorage": () => (paramToArrayStorage),
  "paramToGL": () => (paramToGL),
  "swizzleToEulerOrder": () => (swizzleToEulerOrder),
  "transformComposer": () => (transformComposer)
});

// NAMESPACE OBJECT: ./src/util/data.js
var data_namespaceObject = {};
__webpack_require__.r(data_namespaceObject);
__webpack_require__.d(data_namespaceObject, {
  "getDimensions": () => (getDimensions),
  "getLerpEmitter": () => (getLerpEmitter),
  "getLerpThunk": () => (getLerpThunk),
  "getSizes": () => (getSizes),
  "getStreamer": () => (getStreamer),
  "getThunk": () => (getThunk),
  "makeEmitter": () => (makeEmitter),
  "repeatCall": () => (repeatCall)
});

// NAMESPACE OBJECT: ./src/util/glsl.js
var glsl_namespaceObject = {};
__webpack_require__.r(glsl_namespaceObject);
__webpack_require__.d(glsl_namespaceObject, {
  "binaryOperator": () => (binaryOperator),
  "constant": () => (constant),
  "extendVec": () => (extendVec),
  "identity": () => (identity),
  "injectVec4": () => (injectVec4),
  "invertSwizzleVec4": () => (invertSwizzleVec4),
  "mapByte2FloatOffset": () => (mapByte2FloatOffset),
  "sample2DArray": () => (glsl_sample2DArray),
  "swizzleVec4": () => (swizzleVec4),
  "toType": () => (toType),
  "truncateVec": () => (truncateVec)
});

// NAMESPACE OBJECT: ./src/util/axis.js
var axis_namespaceObject = {};
__webpack_require__.r(axis_namespaceObject);
__webpack_require__.d(axis_namespaceObject, {
  "addOrigin": () => (addOrigin),
  "recenterAxis": () => (recenterAxis),
  "setDimension": () => (setDimension),
  "setDimensionNormal": () => (setDimensionNormal),
  "setOrigin": () => (setOrigin)
});

// NAMESPACE OBJECT: ./src/util/js.js
var js_namespaceObject = {};
__webpack_require__.r(js_namespaceObject);
__webpack_require__.d(js_namespaceObject, {
  "clone": () => (clone),
  "merge": () => (merge),
  "parseQuoted": () => (parseQuoted)
});

// NAMESPACE OBJECT: ./src/util/ease.js
var ease_namespaceObject = {};
__webpack_require__.r(ease_namespaceObject);
__webpack_require__.d(ease_namespaceObject, {
  "binary": () => (binary),
  "clamp": () => (clamp),
  "cosine": () => (cosine),
  "hold": () => (hold)
});

// NAMESPACE OBJECT: ./src/util/ticks.js
var util_ticks_namespaceObject = {};
__webpack_require__.r(util_ticks_namespaceObject);
__webpack_require__.d(util_ticks_namespaceObject, {
  "linear": () => (linear),
  "log": () => (log),
  "make": () => (make)
});

// NAMESPACE OBJECT: ./src/primitives/types/index.js
var primitives_types_namespaceObject = {};
__webpack_require__.r(primitives_types_namespaceObject);
__webpack_require__.d(primitives_types_namespaceObject, {
  "Classes": () => (classes_Classes),
  "Helpers": () => (Helpers),
  "Traits": () => (Traits),
  "Types": () => (types_typed_Types)
});

// NAMESPACE OBJECT: ./src/primitives/index.js
var primitives_namespaceObject = {};
__webpack_require__.r(primitives_namespaceObject);
__webpack_require__.d(primitives_namespaceObject, {
  "Factory": () => (PrimitiveFactory),
  "Primitive": () => (Primitive),
  "Types": () => (primitives_Types)
});

// NAMESPACE OBJECT: ./src/render/index.js
var src_render_namespaceObject = {};
__webpack_require__.r(src_render_namespaceObject);
__webpack_require__.d(src_render_namespaceObject, {
  "Classes": () => (render_classes_Classes),
  "Factory": () => (RenderFactory),
  "Scene": () => (Scene)
});

// NAMESPACE OBJECT: ./node_modules/shadergraph/src/graph/index.js
var src_graph_namespaceObject = {};
__webpack_require__.r(src_graph_namespaceObject);
__webpack_require__.d(src_graph_namespaceObject, {
  "Graph": () => (Graph),
  "IN": () => (IN),
  "Node": () => (graph_node_Node),
  "OUT": () => (OUT),
  "Outlet": () => (Outlet)
});

// NAMESPACE OBJECT: ./node_modules/shadergraph/src/linker/index.js
var linker_namespaceObject = {};
__webpack_require__.r(linker_namespaceObject);
__webpack_require__.d(linker_namespaceObject, {
  "Layout": () => (Layout),
  "Program": () => (Program),
  "Snippet": () => (Snippet),
  "assemble": () => (assemble),
  "compare": () => (linker_priority.compare),
  "link": () => (link_link),
  "load": () => (load),
  "make": () => (linker_priority.make),
  "max": () => (linker_priority.max),
  "nest": () => (linker_priority.nest)
});

// NAMESPACE OBJECT: ./node_modules/shadergraph/src/visualize/markup.js
var markup_namespaceObject = {};
__webpack_require__.r(markup_namespaceObject);
__webpack_require__.d(markup_namespaceObject, {
  "merge": () => (markup_merge),
  "overlay": () => (overlay),
  "process": () => (process)
});

// NAMESPACE OBJECT: ./node_modules/shadergraph/src/visualize/index.js
var visualize_namespaceObject = {};
__webpack_require__.r(visualize_namespaceObject);
__webpack_require__.d(visualize_namespaceObject, {
  "inspect": () => (inspect),
  "markup": () => (markup),
  "serialize": () => (visualize_serialize),
  "visualize": () => (visualize)
});

// NAMESPACE OBJECT: ./node_modules/shadergraph/src/factory/index.js
var src_factory_namespaceObject = {};
__webpack_require__.r(src_factory_namespaceObject);
__webpack_require__.d(src_factory_namespaceObject, {
  "Factory": () => (Factory),
  "Material": () => (Material),
  "cache": () => (cache),
  "hash": () => (hash),
  "library": () => (library),
  "queue": () => (queue)
});

// NAMESPACE OBJECT: ./node_modules/shadergraph/src/glsl/index.js
var src_glsl_namespaceObject = {};
__webpack_require__.r(src_glsl_namespaceObject);
__webpack_require__.d(src_glsl_namespaceObject, {
  "RETURN_ARG": () => (RETURN_ARG),
  "SHADOW_ARG": () => (SHADOW_ARG),
  "body": () => (body),
  "build": () => (build),
  "call": () => (call),
  "compile": () => (compile_compile),
  "dedupe": () => (dedupe),
  "define": () => (generate_define),
  "defuse": () => (defuse),
  "fn": () => (fn),
  "hoist": () => (hoist),
  "invoke": () => (invoke),
  "lines": () => (lines),
  "link": () => (generate_link),
  "links": () => (links),
  "list": () => (list),
  "parse": () => (parse),
  "same": () => (same),
  "statements": () => (statements),
  "unshadow": () => (unshadow),
  "walk": () => (walk)
});

// NAMESPACE OBJECT: ./src/shaders/index.js
var shaders_namespaceObject = {};
__webpack_require__.r(shaders_namespaceObject);
__webpack_require__.d(shaders_namespaceObject, {
  "Factory": () => (factory_Factory),
  "Snippets": () => (Snippets)
});

// NAMESPACE OBJECT: ./src/stage/index.js
var stage_namespaceObject = {};
__webpack_require__.r(stage_namespaceObject);
__webpack_require__.d(stage_namespaceObject, {
  "API": () => (API),
  "Animator": () => (Animator),
  "Controller": () => (Controller)
});

// NAMESPACE OBJECT: ./src/util/index.js
var util_namespaceObject = {};
__webpack_require__.r(util_namespaceObject);
__webpack_require__.d(util_namespaceObject, {
  "Axis": () => (util_Axis),
  "Data": () => (util_Data),
  "Ease": () => (Ease),
  "GLSL": () => (GLSL),
  "JS": () => (JS),
  "Pretty": () => (Pretty),
  "Three": () => (Three),
  "Ticks": () => (util_Ticks),
  "VDOM": () => (VDOM)
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/api.js
class Api {
  static apply(object) {
    object.set = function (options) {
      const o = this.options || {};

      // Diff out changes
      const changes = Object.entries(options).reduce(function (
        result,
        [key, value]
      ) {
        if (o[key] !== value) result[key] = value;
        return result;
      },
      {});

      this.options = Object.assign(o, changes);

      // Notify
      this.trigger({ type: "change", options: options, changes: changes });
    };

    object.get = function () {
      return this.options;
    };

    object.api = function (object, context) {
      if (!object) {
        object = {};
      }

      // Append context argument to API methods
      context &&
        Object.entries(object).forEach(function ([key, callback]) {
          if (typeof callback === "function") {
            object[key] = (...args) => callback(...args, context);
          }
        });

      object.set = this.set.bind(this);
      object.get = this.get.bind(this);

      return object;
    };
  }
}

// EXTERNAL MODULE: external "THREE"
var external_THREE_ = __webpack_require__(824);
;// CONCATENATED MODULE: ./node_modules/threestrap/src/binder.js


class Binder {
  static bind(context, globals) {
    return function (key, object) {
      // Prepare object
      if (!object.__binds) {
        object.__binds = [];
      }

      // Set base target
      let fallback = context;

      if (Array.isArray(key)) {
        fallback = key[0];
        key = key[1];
      }

      // Match key
      const match = /^([^.:]*(?:\.[^.:]+)*)?(?::(.*))?$/.exec(key);
      const path = match[1].split(/\./g);

      const name = path.pop();
      const dest = match[2] || name;

      // Whitelisted objects
      const selector = path.shift();

      let target =
        {
          this: object,
        }[selector] ||
        globals[selector] ||
        context[selector] ||
        fallback;

      // Look up keys
      while (target && (key = path.shift())) {
        target = target[key];
      }

      // Attach event handler at last level
      if (target && (target.on || target.addEventListener)) {
        const callback = function (event) {
          object[dest] && object[dest](event, context);
        };

        // Polyfill for both styles of event listener adders
        Binder._polyfill(target, ["addEventListener", "on"], function (method) {
          target[method](name, callback);
        });

        // Store bind for removal later
        const bind = { target: target, name: name, callback: callback };
        object.__binds.push(bind);

        // Return callback
        return callback;
      } else {
        throw "Cannot bind '" + key + "' in " + this.__name;
      }
    };
  }

  static unbind() {
    return function (object) {
      // Remove all binds belonging to object
      if (object.__binds) {
        object.__binds.forEach(
          function (bind) {
            // Polyfill for both styles of event listener removers
            Binder._polyfill(
              bind.target,
              ["removeEventListener", "off"],
              function (method) {
                bind.target[method](bind.name, bind.callback);
              }
            );
          }.bind(this)
        );

        object.__binds = [];
      }
    };
  }

  static apply(object) {
    object.trigger = Binder._trigger;
    object.triggerOnce = Binder._triggerOnce;

    object.hasEventListener = external_THREE_.EventDispatcher.prototype.hasEventListener;
    object.addEventListener = external_THREE_.EventDispatcher.prototype.addEventListener;
    object.removeEventListener = external_THREE_.EventDispatcher.prototype.removeEventListener;

    object.on = object.addEventListener;
    object.off = object.removeEventListener;
    object.dispatchEvent = object.trigger;
  }

  static _triggerOnce(event) {
    this.trigger(event);
    if (this._listeners) {
      delete this._listeners[event.type];
    }
  }

  static _trigger(event) {
    if (this._listeners === undefined) return;

    const type = event.type;
    let listeners = this._listeners[type];
    if (listeners !== undefined) {
      listeners = listeners.slice();
      const length = listeners.length;

      event.target = this;
      for (let i = 0; i < length; i++) {
        // add original target as parameter for convenience
        listeners[i].call(this, event, this);
      }
    }
  }

  static _polyfill(object, methods, callback) {
    methods.map(function (_method) {
      return object.method;
    });
    if (methods.length) callback(methods[0]);
  }
}

;// CONCATENATED MODULE: ./node_modules/threestrap/src/bootstrap.js



function isString(str) {
  return str && typeof str.valueOf() === "string";
}

/**
 * Like Array.prototype.forEach, but allows the callback to return false to
 * abort the loop
 */
const each = (array, cb) => {
  let i = 0;
  for (const item of array) {
    const success = cb(item, i, array);
    if (success === false) break;
    i++
  }
}

class Bootstrap {
  static initClass() {
    this.Plugins = {};
    this.Aliases = {};
  }

  static registerPlugin(name, spec) {
    const ctor = function (options) {
      Bootstrap.Plugin.call(this, options);
      this.__name = name;
    };
    ctor.prototype = Object.assign(new Bootstrap.Plugin(), spec);

    this.Plugins[name] = ctor;
  }

  static unregisterPlugin(name) {
    delete this.Plugins[name];
  }

  static registerAlias(name, plugins) {
    this.Aliases[name] = plugins;
  }

  static unregisterAlias(name) {
    delete this.Aliases[name];
  }

  constructor(options) {
    if (options) {
      let args = [].slice.apply(arguments);
      options = {};

      // (element, ...)
      if (args[0] instanceof Node) {
        const node = args[0];
        args = args.slice(1);
        options.element = node;
      }

      // (..., plugin, plugin, plugin)
      if (isString(args[0])) {
        options.plugins = args;
      } else if (Array.isArray(args[0])) {
        // (..., [plugin, plugin, plugin])
        options.plugins = args[0];
      } else if (args[0]) {
        // (..., options)

        // else, merge any arguments on the right that have NOT been set into the
        // options dict on the left.
        options = Object.assign({}, args[0], options);
      }
    }

    // Apply defaults
    const defaultOpts = {
      init: true,
      element: document.body,
      plugins: ["core"],
      aliases: {},
      plugindb: Bootstrap.Plugins || {},
      aliasdb: Bootstrap.Aliases || {},
    };

    this.__options = Object.assign({}, defaultOpts, options || {});

    // Hidden state
    this.__inited = false;
    this.__destroyed = false;
    this.__installed = [];

    // Query element
    let element = this.__options.element;
    if (element === "" + element) {
      element = document.querySelector(element);
    }

    // Global context
    this.plugins = {};
    this.element = element;

    // Update cycle
    this.trigger = this.trigger.bind(this);
    this.frame = this.frame.bind(this);
    this.events = ["pre", "update", "render", "post"].map(function (type) {
      return { type: type };
    });

    // Auto-init
    if (this.__options.init) {
      this.init();
    }
  }

  init() {
    if (this.__inited) return;
    this.__inited = true;

    // Install plugins
    this.install(this.__options.plugins);
  }

  destroy() {
    if (!this.__inited) return;
    if (this.__destroyed) return;
    this.__destroyed = true;

    // Notify of imminent destruction
    this.trigger({ type: "destroy" });

    // Then uninstall plugins
    this.uninstall();
  }

  frame() {
    this.events.map(this.trigger);
  }

  resolve(plugins) {
    plugins = Array.isArray(plugins) ? plugins : [plugins];

    // Resolve alias database
    const o = this.__options;
    const aliases = Object.assign({}, o.aliasdb, o.aliases);

    // Remove inline alias defs from plugins
    const pred = function (name) {
      const key = name.split(":");
      if (!key[1]) return true;
      aliases[key[0]] = [key[1]];
      return false;
    };
    plugins = plugins.filter(pred);

    // Unify arrays
    Object.entries(aliases).forEach(function ([key, alias]) {
      aliases[key] = Array.isArray(alias) ? alias : [alias];
    });

    // Look up aliases recursively
    function recurse(list, out, level) {
      if (level >= 256) throw "Plug-in alias recursion detected.";
      list = list.filter(pred);
      list.forEach(function (name) {
        const alias = aliases[name];
        if (!alias) {
          out.push(name);
        } else {
          out = out.concat(recurse(alias, [], level + 1));
        }
      });
      return out;
    }

    return recurse(plugins, [], 0);
  }

  install(plugins) {
    plugins = Array.isArray(plugins) ? plugins : [plugins];

    // Resolve aliases
    plugins = this.resolve(plugins);

    // Install in order
    each(plugins, (name) => this.__install(name))

    // Fire off ready event
    this.__ready();
  }

  uninstall(plugins) {
    if (plugins) {
      plugins = Array.isArray(plugins) ? plugins : [plugins];

      // Resolve aliases
      plugins = this.resolve(plugins);
    }

    // Uninstall in reverse order
    (plugins || this.__installed)
      .reverse()
      .forEach((p) => this.__uninstall(p));
  }

  __install(name) {
    // Sanity check
    const ctor = this.__options.plugindb[name];
    if (!ctor)
      throw "[three.install] Cannot install. '" + name + "' is not registered.";

    if (this.plugins[name])
      return console.warn("[three.install] " + name + " is already installed.");

    // Construct
    const Plugin = ctor;
    const plugin = new Plugin(this.__options[name] || {}, name);
    this.plugins[name] = plugin;

    // Install
    const flag = plugin.install(this);
    this.__installed.push(plugin);

    // Then notify
    this.trigger({ type: "install", plugin: plugin });

    // Allow early abort
    return flag;
  }

  __uninstall(name) {
    // Sanity check
    const plugin = isString(name) ? this.plugins[name] : name;
    if (!plugin) {
      console.warn("[three.uninstall] " + name + "' is not installed.");
      return;
    }

    name = plugin.__name;

    // Uninstall
    plugin.uninstall(this);
    this.__installed = this.__installed.filter((p) => p !== plugin);
    delete this.plugins[name];

    // Then notify
    this.trigger({ type: "uninstall", plugin: plugin });
  }

  __ready() {
    // Notify and remove event handlers
    this.triggerOnce({ type: "ready" });
  }
}
Bootstrap.initClass();

// Plugin Creation

Bootstrap.Plugin = function (options) {
  this.options = Object.assign({}, this.defaults, options || {});
};

Bootstrap.Plugin.prototype = {
  listen: [],
  defaults: {},
  install: function (_three) {},
  uninstall: function (_three) {},
};

Binder.apply(Bootstrap.prototype);
Binder.apply(Bootstrap.Plugin.prototype);
Api.apply(Bootstrap.Plugin.prototype);

;// CONCATENATED MODULE: ./src/splash.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */

// Threestrap plugin



Bootstrap.registerPlugin("splash", {
  defaults: {
    color: "mono",
    fancy: true,
  },

  listen: [
    "ready",
    "mathbox/init:init",
    "mathbox/progress:progress",
    "mathbox/destroy:destroy",
  ],

  uninstall() {
    return this.destroy();
  },

  ready(event, three) {
    if (three.MathBox && !this.div) {
      // TODO woah seems wrong!!!
      return this.init(event, three);
    }
  },

  init(event, three) {
    let div;
    this.destroy();

    const { color } = this.options;
    const html = `\
<div class="mathbox-loader mathbox-splash-${color}">
  <div class="mathbox-logo">
    <div> <div></div><div></div><div></div> </div>
    <div> <div></div><div></div><div></div> </div>
  </div>
  <div class="mathbox-progress"><div></div></div>
</div>\
`;

    this.div = div = document.createElement("div");
    div.innerHTML = html;
    three.element.appendChild(div);

    const x = Math.random() * 2 - 1;
    const y = Math.random() * 2 - 1;
    const z = Math.random() * 2 - 1;
    const l = 1 / Math.sqrt(x * x + y * y + z * z);

    this.loader = div.querySelector(".mathbox-loader");
    this.bar = div.querySelector(".mathbox-progress > div");
    this.gyro = div.querySelectorAll(".mathbox-logo > div");
    this.transforms = [
      "rotateZ(22deg) rotateX(24deg) rotateY(30deg)",
      "rotateZ(11deg) rotateX(12deg) rotateY(15deg) scale3d(.6, .6, .6)",
    ];
    this.random = [x * l, y * l, z * l];
    this.start = three.Time.now;
    return (this.timer = null);
  },

  // Update splash screen state and animation
  progress(event, three) {
    if (!this.div) {
      return;
    }

    const { current, total } = event;

    // Display splash screen
    const visible = current < total;
    clearTimeout(this.timer);
    if (visible) {
      this.loader.classList.remove("mathbox-exit");
      this.loader.style.display = "block";
    } else {
      this.loader.classList.add("mathbox-exit");
      this.timer = setTimeout(() => {
        return (this.loader.style.display = "none");
      }, 150);
    }

    // Update splash progress
    const width =
      current < total
        ? Math.round((1000 * current) / total) * 0.1 + "%"
        : "100%";
    this.bar.style.width = width;

    if (this.options.fancy) {
      // Spinny gyros
      const weights = this.random;

      // Lerp clock speed
      const f = Math.max(0, Math.min(1, three.Time.now - this.start));
      const increment = function (transform, j) {
        if (j == null) {
          j = 0;
        }
        return transform.replace(
          /(-?[0-9.e]+)deg/g,
          (_, n) => +n + weights[j++] * f * three.Time.step * 60 + "deg"
        );
      };

      return (() => {
        const result = [];
        for (let i = 0; i < this.gyro.length; i++) {
          let t;
          const el = this.gyro[i];
          this.transforms[i] = t = increment(this.transforms[i]);
          result.push((el.style.transform = el.style.WebkitTransform = t));
        }
        return result;
      })();
    }
  },

  destroy() {
    if (this.div != null) {
      this.div.remove();
    }
    return (this.div = null);
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/aliases.js


Bootstrap.registerAlias("empty", [
  "fallback",
  "bind",
  "renderer",
  "size",
  "fill",
  "loop",
  "time",
]);

Bootstrap.registerAlias("core", [
  "empty",
  "scene",
  "camera",
  "render",
  "warmup",
]);

Bootstrap.registerAlias("VR", ["core", "cursor", "fullscreen", "render:vr"]);

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/bind.js



Bootstrap.registerPlugin("bind", {
  install: function (three) {
    const globals = {
      three: three,
      window: window,
    };

    three.bind = Binder.bind(three, globals);
    three.unbind = Binder.unbind(three);

    three.bind("install:bind", this);
    three.bind("uninstall:unbind", this);
  },

  uninstall: function (three) {
    three.unbind(this);

    delete three.bind;
    delete three.unbind;
  },

  bind: function (event, three) {
    const plugin = event.plugin;
    const listen = plugin.listen;

    listen &&
      listen.forEach(function (key) {
        three.bind(key, plugin);
      });
  },

  unbind: function (event, three) {
    three.unbind(event.plugin);
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/camera.js



Bootstrap.registerPlugin("camera", {
  defaults: {
    near: 0.01,
    far: 10000,

    type: "perspective",
    fov: 60,
    aspect: null,

    // type: 'orthographic',
    left: -1,
    right: 1,
    bottom: -1,
    top: 1,

    klass: null,
    parameters: null,
  },

  listen: ["resize", "this.change"],

  install: function (three) {
    three.Camera = this.api();
    three.camera = null;

    this.aspect = 1;
    this.change({}, three);
  },

  uninstall: function (three) {
    delete three.Camera;
    delete three.camera;
  },

  change: function (event, three) {
    const o = this.options;
    const old = three.camera;

    if (!three.camera || event.changes.type || event.changes.klass) {
      const klass =
        o.klass ||
        {
          perspective: external_THREE_.PerspectiveCamera,
          orthographic: external_THREE_.OrthographicCamera,
        }[o.type] ||
        external_THREE_.Camera;

      three.camera = o.parameters ? new klass(o.parameters) : new klass();
    }

    Object.entries(o).forEach(
      function ([key]) {
        if (Object.prototype.hasOwnProperty.call(three.camera, key))
          three.camera[key] = o[key];
      }.bind(this)
    );

    this.update(three);

    old === three.camera ||
      three.trigger({
        type: "camera",
        camera: three.camera,
      });
  },

  resize: function (event, three) {
    this.aspect = event.viewWidth / Math.max(1, event.viewHeight);

    this.update(three);
  },

  update: function (three) {
    three.camera.aspect = this.options.aspect || this.aspect;
    three.camera.updateProjectionMatrix();
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/fallback.js


Bootstrap.registerPlugin("fallback", {
  defaults: {
    force: false,
    fill: true,
    begin:
      '<div class="threestrap-fallback" style="display: table; width: 100%; height: 100%;' +
      'box-sizing: border-box; border: 1px dashed rgba(0, 0, 0, .25);">' +
      '<div style="display: table-cell; padding: 10px; vertical-align: middle; text-align: center;">',
    end: "</div></div>",
    message:
      "<big><strong>This example requires WebGL</strong></big><br>" +
      'Visit <a target="_blank" href="http://get.webgl.org/">get.webgl.org</a> for more info</a>',
  },

  install: function (three) {
    let cnv, gl;
    try {
      cnv = document.createElement("canvas");
      gl = cnv.getContext("webgl") || cnv.getContext("experimental-webgl");
      if (!gl || this.options.force) {
        throw "WebGL unavailable.";
      }
      three.fallback = false;
    } catch (e) {
      const message = this.options.message;
      const begin = this.options.begin;
      const end = this.options.end;
      const fill = this.options.fill;

      const div = document.createElement("div");
      div.innerHTML = begin + message + end;

      this.children = [];

      while (div.childNodes.length > 0) {
        this.children.push(div.firstChild);
        three.element.appendChild(div.firstChild);
      }

      if (fill) {
        three.install("fill");
      }

      this.div = div;
      three.fallback = true;
      return false; // Abort install
    }
  },

  uninstall: function (three) {
    if (this.children) {
      this.children.forEach(function (child) {
        child.parentNode.removeChild(child);
      });
      this.children = null;
    }

    delete three.fallback;
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/fill.js


Bootstrap.registerPlugin("fill", {
  defaults: {
    block: true,
    body: true,
    layout: true,
  },

  install: function (three) {
    function is(element) {
      const h = element.style.height;
      return h == "auto" || h == "";
    }

    function set(element) {
      element.style.height = "100%";
      element.style.margin = 0;
      element.style.padding = 0;
      return element;
    }

    if (this.options.body && three.element == document.body) {
      // Fix body height if we're naked
      this.applied = [three.element, document.documentElement]
        .filter(is)
        .map(set);
    }

    if (this.options.block && three.canvas) {
      three.canvas.style.display = "block";
      this.block = true;
    }

    if (this.options.layout && three.element) {
      const style = window.getComputedStyle(three.element);
      if (style.position == "static") {
        three.element.style.position = "relative";
        this.layout = true;
      }
    }
  },

  uninstall: function (three) {
    if (this.applied) {
      const set = function (element) {
        element.style.height = "";
        element.style.margin = "";
        element.style.padding = "";
        return element;
      };

      this.applied.map(set);
      delete this.applied;
    }

    if (this.block && three.canvas) {
      three.canvas.style.display = "";
      delete this.block;
    }

    if (this.layout && three.element) {
      three.element.style.position = "";
      delete this.layout;
    }
  },

  change: function (three) {
    this.uninstall(three);
    this.install(three);
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/loop.js


Bootstrap.registerPlugin("loop", {
  defaults: {
    start: true,
    each: 1,
  },

  listen: ["ready"],

  install: function (three) {
    this.running = false;
    this.lastRequestId = null;

    three.Loop = this.api(
      {
        start: this.start.bind(this),
        stop: this.stop.bind(this),
        running: false,
        window: window,
      },
      three
    );

    this.events = ["pre", "update", "render", "post"].map(function (type) {
      return { type: type };
    });
  },

  uninstall: function (three) {
    this.stop(three);
  },

  ready: function (event, three) {
    if (this.options.start) this.start(three);
  },

  start: function (three) {
    if (this.running) return;

    three.Loop.running = this.running = true;

    const trigger = three.trigger.bind(three);
    const loop = function () {
      if (!this.running) return;
      this.lastRequestId = three.Loop.window.requestAnimationFrame(loop);
      this.events.map(trigger);
    }.bind(this);

    this.lastRequestId = three.Loop.window.requestAnimationFrame(loop);

    three.trigger({ type: "start" });
  },

  stop: function (three) {
    if (!this.running) return;
    three.Loop.running = this.running = false;

    three.Loop.window.cancelAnimationFrame(this.lastRequestId);
    this.lastRequestId = null;

    three.trigger({ type: "stop" });
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/render.js


Bootstrap.registerPlugin("render", {
  listen: ["render"],

  render: function (event, three) {
    if (three.scene && three.camera) {
      three.renderer.render(three.scene, three.camera);
    }
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/renderer.js



Bootstrap.registerPlugin("renderer", {
  defaults: {
    klass: external_THREE_.WebGL1Renderer,
    parameters: {
      depth: true,
      stencil: true,
      preserveDrawingBuffer: true,
      antialias: true,
    },
  },

  listen: ["resize"],

  install: function (three) {
    // Instantiate Three renderer
    const renderer = (three.renderer = new this.options.klass(
      this.options.parameters
    ));
    three.canvas = renderer.domElement;

    // Add to DOM
    three.element.appendChild(renderer.domElement);
  },

  uninstall: function (three) {
    // Remove from DOM
    three.element.removeChild(three.renderer.domElement);

    delete three.renderer;
    delete three.canvas;
  },

  resize: function (event, three) {
    const renderer = three.renderer;
    const el = renderer.domElement;

    // Resize renderer to render size if it's a canvas
    if (el && el.tagName == "CANVAS") {
      renderer.setSize(event.renderWidth, event.renderHeight, false);
    }
    // Or view size if it's just a DOM element or multi-renderer
    else {
      if (renderer.setRenderSize) {
        renderer.setRenderSize(event.renderWidth, event.renderHeight);
      }
      renderer.setSize(event.viewWidth, event.viewHeight, false);
    }
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/scene.js



Bootstrap.registerPlugin("scene", {
  install: function (three) {
    three.scene = new external_THREE_.Scene();
  },

  uninstall: function (three) {
    delete three.scene;
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/size.js


Bootstrap.registerPlugin("size", {
  defaults: {
    width: null,
    height: null,
    aspect: null,
    scale: 1,
    maxRenderWidth: Infinity,
    maxRenderHeight: Infinity,
    devicePixelRatio: true,
  },

  listen: [
    "window.resize:queue",
    "element.resize:queue",
    "this.change:queue",
    "ready:resize",
    "pre:pre",
  ],

  install: function (three) {
    three.Size = this.api({
      renderWidth: 0,
      renderHeight: 0,
      viewWidth: 0,
      viewHeight: 0,
    });

    this.resized = false;
  },

  uninstall: function (three) {
    delete three.Size;
  },

  queue: function (_event, _three) {
    this.resized = true;
  },

  pre: function (event, three) {
    if (!this.resized) return;
    this.resized = false;
    this.resize(event, three);
  },

  resize: function (event, three) {
    const options = this.options;
    const element = three.element;
    const renderer = three.renderer;

    let w,
      h,
      ew,
      eh,
      rw,
      rh,
      aspect,
      ratio,
      ml = 0,
      mt = 0;

    // Measure element
    w = ew =
      options.width === undefined || options.width == null
        ? element.offsetWidth || element.innerWidth || 0
        : options.width;

    h = eh =
      options.height === undefined || options.height == null
        ? element.offsetHeight || element.innerHeight || 0
        : options.height;

    // Force aspect ratio
    aspect = w / h;
    if (options.aspect) {
      if (options.aspect > aspect) {
        h = Math.round(w / options.aspect);
        mt = Math.floor((eh - h) / 2);
      } else {
        w = Math.round(h * options.aspect);
        ml = Math.floor((ew - w) / 2);
      }
      aspect = w / h;
    }

    // Get device pixel ratio
    ratio = 1;
    if (options.devicePixelRatio && typeof window != "undefined") {
      ratio = window.devicePixelRatio || 1;
    }

    // Apply scale and resolution max
    rw = Math.round(
      Math.min(w * ratio * options.scale, options.maxRenderWidth)
    );
    rh = Math.round(
      Math.min(h * ratio * options.scale, options.maxRenderHeight)
    );

    // Retain aspect ratio
    const raspect = rw / rh;
    if (raspect > aspect) {
      rw = Math.round(rh * aspect);
    } else {
      rh = Math.round(rw / aspect);
    }

    // Measure final pixel ratio
    ratio = rh / h;

    // Resize and position renderer element
    const style = renderer.domElement.style;
    style.width = w + "px";
    style.height = h + "px";
    style.marginLeft = ml + "px";
    style.marginTop = mt + "px";

    // Notify
    Object.assign(three.Size, {
      renderWidth: rw,
      renderHeight: rh,
      viewWidth: w,
      viewHeight: h,
      aspect: aspect,
      pixelRatio: ratio,
    });

    three.trigger({
      type: "resize",
      renderWidth: rw,
      renderHeight: rh,
      viewWidth: w,
      viewHeight: h,
      aspect: aspect,
      pixelRatio: ratio,
    });
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/time.js


Bootstrap.registerPlugin("time", {
  defaults: {
    speed: 1, // Clock speed
    warmup: 0, // Wait N frames before starting clock
    timeout: 1, // Timeout in seconds. Pause if no tick happens in this time.
  },

  listen: ["pre:tick", "this.change"],

  now: function () {
    return +new Date() / 1000;
  },

  install: function (three) {
    three.Time = this.api({
      now: this.now(), // Time since 1970 in seconds

      clock: 0, // Adjustable clock that counts up from 0 seconds
      step: 1 / 60, // Clock step in seconds

      frames: 0, // Framenumber
      time: 0, // Real time in seconds
      delta: 1 / 60, // Frame step in seconds

      average: 0, // Average frame time in seconds
      fps: 0, // Average frames per second
    });

    this.last = 0;
    this.time = 0;
    this.clock = 0;
    this.wait = this.options.warmup;

    this.clockStart = 0;
    this.timeStart = 0;
  },

  tick: function (event, three) {
    const speed = this.options.speed;
    const timeout = this.options.timeout;

    const api = three.Time;
    const now = (api.now = this.now());
    const last = this.last;
    let time = this.time;
    let clock = this.clock;

    if (last) {
      let delta = (api.delta = now - last);
      const average = api.average || delta;

      if (delta > timeout) {
        delta = 0;
      }

      const step = delta * speed;

      time += delta;
      clock += step;

      if (api.frames > 0) {
        api.average = average + (delta - average) * 0.1;
        api.fps = 1 / average;
      }

      api.step = step;
      api.clock = clock - this.clockStart;
      api.time = time - this.timeStart;

      api.frames++;

      if (this.wait-- > 0) {
        this.clockStart = clock;
        this.timeStart = time;
        api.clock = 0;
        api.step = 1e-100;
      }
    }

    this.last = now;
    this.clock = clock;
    this.time = time;
  },

  uninstall: function (three) {
    delete three.Time;
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/warmup.js


Bootstrap.registerPlugin("warmup", {
  defaults: {
    delay: 2,
  },

  listen: ["ready", "post"],

  ready: function (event, three) {
    three.renderer.domElement.style.visibility = "hidden";
    this.frame = 0;
    this.hidden = true;
  },

  post: function (event, three) {
    if (this.hidden && this.frame >= this.options.delay) {
      three.renderer.domElement.style.visibility = "visible";
      this.hidden = false;
    }
    this.frame++;
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/core/index.js












;// CONCATENATED MODULE: ./node_modules/threestrap/src/extra/controls.js



Bootstrap.registerPlugin("controls", {
  listen: ["update", "resize", "camera", "this.change"],

  defaults: {
    klass: null,
    parameters: {},
  },

  install: function (three) {
    if (!this.options.klass) throw "Must provide class for `controls.klass`";

    three.controls = null;

    this._camera = three.camera || new external_THREE_.PerspectiveCamera();
    this.change(null, three);
  },

  uninstall: function (three) {
    delete three.controls;
  },

  change: function (event, three) {
    if (this.options.klass) {
      if (!event || event.changes.klass) {
        three.controls = new this.options.klass(
          this._camera,
          three.renderer.domElement
        );
      }

      Object.assign(three.controls, this.options.parameters);
    } else {
      three.controls = null;
    }
  },

  update: function (event, three) {
    const delta = (three.Time && three.Time.delta) || 1 / 60;
    const vr = three.VR && three.VR.state;

    if (three.controls.vr) three.controls.vr(vr);
    three.controls.update(delta);
  },

  camera: function (event, three) {
    three.controls.object = this._camera = event.camera;
  },

  resize: function (event, three) {
    three.controls.handleResize && three.controls.handleResize();
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/extra/cursor.js


Bootstrap.registerPlugin("cursor", {
  listen: [
    "update",
    "this.change",
    "install:change",
    "uninstall:change",
    "element.mousemove",
    "vr",
  ],

  defaults: {
    cursor: null,
    hide: false,
    timeout: 3,
  },

  install: function (three) {
    this.timeout = this.options.timeout;
    this.element = three.element;
    this.change(null, three);
  },

  uninstall: function (three) {
    delete three.controls;
  },

  change: function (event, three) {
    this.applyCursor(three);
  },

  mousemove: function (event, three) {
    if (this.options.hide) {
      this.applyCursor(three);
      this.timeout = +this.options.timeout || 0;
    }
  },

  update: function (event, three) {
    const delta = (three.Time && three.Time.delta) || 1 / 60;

    if (this.options.hide) {
      this.timeout -= delta;
      if (this.timeout < 0) {
        this.applyCursor(three, "none");
      }
    }
  },

  vr: function (event, three) {
    this.hide = event.active && !event.hmd.fake;
    this.applyCursor(three);
  },

  applyCursor: function (three, cursor) {
    const auto = three.controls ? "move" : "";
    cursor = cursor || this.options.cursor || auto;
    if (this.hide) cursor = "none";
    if (this.cursor != cursor) {
      this.element.style.cursor = cursor;
    }
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/extra/fullscreen.js


Bootstrap.registerPlugin("fullscreen", {
  defaults: {
    key: "f",
  },

  listen: ["ready", "update"],

  install: function (three) {
    three.Fullscreen = this.api(
      {
        active: false,
        toggle: this.toggle.bind(this),
      },
      three
    );
  },

  uninstall: function (three) {
    delete three.Fullscreen;
  },

  ready: function (event, three) {
    document.body.addEventListener(
      "keypress",
      function (event) {
        if (
          this.options.key &&
          event.charCode == this.options.key.charCodeAt(0)
        ) {
          this.toggle(three);
        }
      }.bind(this)
    );

    const changeHandler = function () {
      const active =
        !!document.fullscreenElement ||
        !!document.mozFullScreenElement ||
        !!document.webkitFullscreenElement ||
        !!document.msFullscreenElement;
      three.Fullscreen.active = this.active = active;
      three.trigger({
        type: "fullscreen",
        active: active,
      });
    }.bind(this);
    document.addEventListener("fullscreenchange", changeHandler, false);
    document.addEventListener("webkitfullscreenchange", changeHandler, false);
    document.addEventListener("mozfullscreenchange", changeHandler, false);
  },

  toggle: function (three) {
    const canvas = three.canvas;
    const options =
      three.VR && three.VR.active ? { vrDisplay: three.VR.hmd } : {};

    if (!this.active) {
      if (canvas.requestFullScreen) {
        canvas.requestFullScreen(options);
      } else if (canvas.msRequestFullScreen) {
        canvas.msRequestFullscreen(options);
      } else if (canvas.webkitRequestFullscreen) {
        canvas.webkitRequestFullscreen(options);
      } else if (canvas.mozRequestFullScreen) {
        canvas.mozRequestFullScreen(options); // s vs S
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen(); // s vs S
      }
    }
  },
});

// EXTERNAL MODULE: ./node_modules/stats.js/build/stats.min.js
var stats_min = __webpack_require__(3466);
var stats_min_default = /*#__PURE__*/__webpack_require__.n(stats_min);
;// CONCATENATED MODULE: ./node_modules/threestrap/src/extra/stats.js



Bootstrap.registerPlugin("stats", {
  listen: ["pre", "post"],

  install: function (three) {
    const stats = (this.stats = new (stats_min_default())());
    const style = stats.domElement.style;

    style.position = "absolute";
    style.top = style.left = 0;
    three.element.appendChild(stats.domElement);

    three.stats = stats;
  },

  uninstall: function (three) {
    this.stats.domElement.remove()
    delete three.stats;
  },

  pre: function (_event, _three) {
    this.stats.begin();
  },

  post: function (_event, _three) {
    this.stats.end();
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/extra/ui.js


Bootstrap.registerPlugin("ui", {
  defaults: {
    theme: "white",
    style:
      ".threestrap-ui { position: absolute; bottom: 5px; right: 5px; float: left; }" +
      ".threestrap-ui button { border: 0; background: none;" +
      "  vertical-align: middle; font-weight: bold; } " +
      ".threestrap-ui .glyphicon { top: 2px; font-weight: bold; } " +
      "@media (max-width: 640px) { .threestrap-ui button { font-size: 120% } }" +
      ".threestrap-white button { color: #fff; text-shadow: 0 1px 1px rgba(0, 0, 0, 1), " +
      "0 1px 3px rgba(0, 0, 0, 1); }" +
      ".threestrap-black button { color: #000; text-shadow: 0 0px 1px rgba(255, 255, 255, 1), " +
      "0 0px 2px rgba(255, 255, 255, 1), " +
      "0 0px 2px rgba(255, 255, 255, 1) }",
  },

  listen: ["fullscreen"],

  markup: function (three, theme, style) {
    let url =
      "//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css";
    if (location.href.match(/^file:\/\//)) url = "http://" + url;

    const buttons = [];

    if (three.Fullscreen) {
      buttons.push(
        '<button class="fullscreen" title="Full Screen">' +
          '<span class="glyphicon glyphicon-fullscreen"></span>' +
          "</button>"
      );
    }
    if (three.VR) {
      buttons.push('<button class="vr" title="VR Headset">VR</button>');
    }

    return (
      '<style type="text/css">@import url("' +
      url +
      '"); ' +
      style +
      "</style>" +
      '<div class="threestrap-ui threestrap-' +
      theme +
      '">' +
      buttons.join("\n") +
      "</div>"
    );
  },

  install: function (three) {
    const ui = (this.ui = document.createElement("div"));
    ui.innerHTML = this.markup(three, this.options.theme, this.options.style);
    document.body.appendChild(ui);

    const fullscreen = (this.ui.fullscreen =
      ui.querySelector("button.fullscreen"));
    if (fullscreen) {
      three.bind([fullscreen, "click:goFullscreen"], this);
    }

    const vr = (this.ui.vr = ui.querySelector("button.vr"));
    if (vr && three.VR) {
      three.VR.set({ mode: "2d" });
      three.bind([vr, "click:goVR"], this);
    }
  },

  fullscreen: function (event, three) {
    this.ui.style.display = event.active ? "none" : "block";
    if (!event.active) three.VR && three.VR.set({ mode: "2d" });
  },

  goFullscreen: function (event, three) {
    if (three.Fullscreen) {
      three.Fullscreen.toggle();
    }
  },

  goVR: function (event, three) {
    if (three.VR) {
      three.VR.set({ mode: "auto" });
      three.Fullscreen.toggle();
    }
  },

  uninstall: function (_three) {
    document.body.removeChild(this.ui);
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/renderers/VRRenderer.js
/**
 * VRRenderer
 *
 * @author wwwtyro https://github.com/wwwtyro
 * @author unconed https://github.com/unconed
 */


class VRRenderer {
  constructor(renderer, hmd) {
    this.renderer = renderer;

    this.right = new external_THREE_.Vector3();
    this.cameraLeft = new external_THREE_.PerspectiveCamera();
    this.cameraRight = new external_THREE_.PerspectiveCamera();

    const et = hmd.getEyeTranslation("left");
    this.halfIPD = new external_THREE_.Vector3(et.x, et.y, et.z).length();
    this.fovLeft = hmd.getRecommendedEyeFieldOfView("left");
    this.fovRight = hmd.getRecommendedEyeFieldOfView("right");
  }

  FovToNDCScaleOffset(fov) {
    const pxscale = 2.0 / (fov.leftTan + fov.rightTan);
    const pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
    const pyscale = 2.0 / (fov.upTan + fov.downTan);
    const pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
    return {
      scale: [pxscale, pyscale],
      offset: [pxoffset, pyoffset],
    };
  }

  FovPortToProjection(
    matrix,
    fov,
    rightHanded /* = true */,
    zNear /* = 0.01 */,
    zFar /* = 10000.0 */
  ) {
    rightHanded = rightHanded === undefined ? true : rightHanded;
    zNear = zNear === undefined ? 0.01 : zNear;
    zFar = zFar === undefined ? 10000.0 : zFar;
    const handednessScale = rightHanded ? -1.0 : 1.0;
    const m = matrix.elements;
    const scaleAndOffset = this.FovToNDCScaleOffset(fov);
    m[0 * 4 + 0] = scaleAndOffset.scale[0];
    m[0 * 4 + 1] = 0.0;
    m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
    m[0 * 4 + 3] = 0.0;
    m[1 * 4 + 0] = 0.0;
    m[1 * 4 + 1] = scaleAndOffset.scale[1];
    m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
    m[1 * 4 + 3] = 0.0;
    m[2 * 4 + 0] = 0.0;
    m[2 * 4 + 1] = 0.0;
    m[2 * 4 + 2] = (zFar / (zNear - zFar)) * -handednessScale;
    m[2 * 4 + 3] = (zFar * zNear) / (zNear - zFar);
    m[3 * 4 + 0] = 0.0;
    m[3 * 4 + 1] = 0.0;
    m[3 * 4 + 2] = handednessScale;
    m[3 * 4 + 3] = 0.0;
    matrix.transpose();
  }

  FovToProjection(
    matrix,
    fov,
    rightHanded /* = true */,
    zNear /* = 0.01 */,
    zFar /* = 10000.0 */
  ) {
    const fovPort = {
      upTan: Math.tan((fov.upDegrees * Math.PI) / 180.0),
      downTan: Math.tan((fov.downDegrees * Math.PI) / 180.0),
      leftTan: Math.tan((fov.leftDegrees * Math.PI) / 180.0),
      rightTan: Math.tan((fov.rightDegrees * Math.PI) / 180.0),
    };
    return this.FovPortToProjection(matrix, fovPort, rightHanded, zNear, zFar);
  }

  render(scene, camera) {
    this.FovToProjection(
      this.cameraLeft.projectionMatrix,
      this.fovLeft,
      true,
      camera.near,
      camera.far
    );
    this.FovToProjection(
      this.cameraRight.projectionMatrix,
      this.fovRight,
      true,
      camera.near,
      camera.far
    );

    this.right.set(this.halfIPD, 0, 0);
    this.right.applyQuaternion(camera.quaternion);

    this.cameraLeft.position.copy(camera.position).sub(this.right);
    this.cameraRight.position.copy(camera.position).add(this.right);

    this.cameraLeft.quaternion.copy(camera.quaternion);
    this.cameraRight.quaternion.copy(camera.quaternion);

    const dpr = this.renderer.devicePixelRatio || 1;
    const width = this.renderer.domElement.width / 2 / dpr;
    const height = this.renderer.domElement.height / dpr;

    this.renderer.enableScissorTest(true);

    this.renderer.setViewport(0, 0, width, height);
    this.renderer.setScissor(0, 0, width, height);
    this.renderer.render(scene, this.cameraLeft);

    this.renderer.setViewport(width, 0, width, height);
    this.renderer.setScissor(width, 0, width, height);
    this.renderer.render(scene, this.cameraRight);
  }
}

;// CONCATENATED MODULE: ./node_modules/threestrap/src/extra/vr.js



/*
VR sensor / HMD hookup.
*/
Bootstrap.registerPlugin("vr", {
  defaults: {
    mode: "auto", // 'auto', '2d'
    device: null,
    fov: 80, // emulated FOV for fallback
  },

  listen: ["window.load", "pre", "render", "resize", "this.change"],

  install: function (three) {
    three.VR = this.api(
      {
        active: false,
        devices: [],
        hmd: null,
        sensor: null,
        renderer: null,
        state: null,
      },
      three
    );
  },

  uninstall: function (three) {
    delete three.VR;
  },

  mocks: function (three, fov, def) {
    // Fake VR device for cardboard / desktop

    // Interpuppilary distance
    const ipd = 0.03;

    // Symmetric eye FOVs (Cardboard style)
    const getEyeTranslation = function (key) {
      return { left: { x: -ipd, y: 0, z: 0 }, right: { x: ipd, y: 0, z: 0 } }[
        key
      ];
    };
    const getRecommendedEyeFieldOfView = function (key) {
      const camera = three.camera;
      const aspect = (camera && camera.aspect) || 16 / 9;
      const fov2 = (fov || (camera && camera.fov) || def) / 2;
      const fovX =
        (Math.atan((Math.tan((fov2 * Math.PI) / 180) * aspect) / 2) * 180) /
        Math.PI;
      const fovY = fov2;

      return {
        left: {
          rightDegrees: fovX,
          leftDegrees: fovX,
          downDegrees: fovY,
          upDegrees: fovY,
        },
        right: {
          rightDegrees: fovX,
          leftDegrees: fovX,
          downDegrees: fovY,
          upDegrees: fovY,
        },
      }[key];
    };
    // Will be replaced with orbit controls or device orientation controls by VRControls
    const getState = function () {
      return {};
    };

    return [
      {
        fake: true,
        force: 1,
        deviceId: "emu",
        deviceName: "Emulated",
        getEyeTranslation: getEyeTranslation,
        getRecommendedEyeFieldOfView: getRecommendedEyeFieldOfView,
      },
      {
        force: 2,
        getState: getState,
      },
    ];
  },

  load: function (event, three) {
    const callback = function (devs) {
      this.callback(devs, three);
    }.bind(this);

    if (navigator.getVRDevices) {
      navigator.getVRDevices().then(callback);
    } else if (navigator.mozGetVRDevices) {
      navigator.mozGetVRDevices(callback);
    } else {
      console.warn("No native VR support detected.");
      callback(this.mocks(three, this.options.fov, this.defaults.fov), three);
    }
  },

  callback: function (vrdevs, three) {
    let hmd, sensor;

    const HMD = window.HMDVRDevice || function () {};
    const SENSOR = window.PositionSensorVRDevice || function () {};

    // Export list of devices
    vrdevs = three.VR.devices = vrdevs || three.VR.devices;

    // Get HMD device
    const deviceId = this.options.device;
    let dev;

    for (let i = 0; i < vrdevs.length; ++i) {
      dev = vrdevs[i];
      if (dev.force == 1 || dev instanceof HMD) {
        if (deviceId && deviceId != dev.deviceId) continue;
        hmd = dev;
        break;
      }
    }

    if (hmd) {
      // Get sensor device
      let dev;
      for (let i = 0; i < vrdevs.length; ++i) {
        dev = vrdevs[i];
        if (
          dev.force == 2 ||
          (dev instanceof SENSOR && dev.hardwareUnitId == hmd.hardwareUnitId)
        ) {
          sensor = dev;
          break;
        }
      }

      this.hookup(hmd, sensor, three);
    }
  },

  hookup: function (hmd, sensor, three) {
    if (!VRRenderer) console.log("VRRenderer not found");
    const klass = VRRenderer || function () {};

    this.renderer = new klass(three.renderer, hmd);
    this.hmd = hmd;
    this.sensor = sensor;

    three.VR.renderer = this.renderer;
    three.VR.hmd = hmd;
    three.VR.sensor = sensor;

    console.log("VRRenderer", hmd.deviceName);
  },

  change: function (event, three) {
    if (event.changes.device) {
      this.callback(null, three);
    }
    this.pre(event, three);
  },

  pre: function (event, three) {
    const last = this.active;

    // Global active flag
    const active = (this.active = this.renderer && this.options.mode != "2d");
    three.VR.active = active;

    // Load sensor state
    if (active && this.sensor) {
      const state = this.sensor.getState();
      three.VR.state = state;
    } else {
      three.VR.state = null;
    }

    // Notify if VR state changed
    if (last != this.active) {
      three.trigger({
        type: "vr",
        active: active,
        hmd: this.hmd,
        sensor: this.sensor,
      });
    }
  },

  resize: function (_event, _three) {
    if (this.active) {
      // Reinit HMD projection
      this.renderer.initialize();
    }
  },

  render: function (event, three) {
    if (three.scene && three.camera) {
      const renderer = this.active ? this.renderer : three.renderer;

      if (this.last != renderer) {
        if (renderer == three.renderer) {
          // Cleanup leftover renderer state when swapping back to normal
          const dpr = renderer.getPixelRatio();
          const width = renderer.domElement.width / dpr;
          const height = renderer.domElement.height / dpr;
          renderer.setScissorTest(false);
          renderer.setViewport(0, 0, width, height);
        }
      }

      this.last = renderer;

      renderer.render(three.scene, three.camera);
    }
  },
});

;// CONCATENATED MODULE: ./node_modules/threestrap/src/extra/index.js







;// CONCATENATED MODULE: ./node_modules/threestrap/src/controls/VRControls.js
/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 *
 * VRControls from
 * https://cdn.jsdelivr.net/npm/three@0.93.0/examples/js/controls/VRControls.js.
 * Added here so that the existing VR examples still work... this will stay
 * until we get everything upgraded to the modern three.js approach to VR. See
 * https://threejs.org/docs/index.html#manual/en/introduction/How-to-create-VR-content
 * for more info.
 */



class VRControls {
  constructor(object, onError) {
    this.object = object;
    this.standingMatrix = new Matrix4();
    this.frameData = null;

    if ("VRFrameData" in window) {
      // eslint-disable-next-line no-undef
      this.frameData = new VRFrameData();
    }

    function gotVRDisplays(displays) {
      this.vrDisplays = displays;

      if (displays.length > 0) {
        this.vrDisplay = displays[0];
      } else {
        if (onError) onError("VR input not available.");
      }
    }

    if (navigator.getVRDisplays) {
      navigator
        .getVRDisplays()
        .then(gotVRDisplays)
        .catch(function () {
          console.warn("VRControls: Unable to get VR Displays");
        });
    }

    // the Rift SDK returns the position in meters
    // this scale factor allows the user to define how meters
    // are converted to scene units.

    this.scale = 1;

    // If true will use "standing space" coordinate system where y=0 is the
    // floor and x=0, z=0 is the center of the room.
    this.standing = false;

    // Distance from the users eyes to the floor in meters. Used when
    // standing=true but the VRDisplay doesn't provide stageParameters.
    this.userHeight = 1.6;
  }

  getVRDisplay() {
    return this.vrDisplay;
  }

  setVRDisplay(value) {
    this.vrDisplay = value;
  }

  getVRDisplays() {
    console.warn("VRControls: getVRDisplays() is being deprecated.");
    return this.vrDisplays;
  }

  getStandingMatrix() {
    return this.standingMatrix;
  }

  update() {
    if (this.vrDisplay) {
      let pose;

      if (this.vrDisplay.getFrameData) {
        this.vrDisplay.getFrameData(this.frameData);
        pose = this.frameData.pose;
      } else if (this.vrDisplay.getPose) {
        pose = this.vrDisplay.getPose();
      }

      if (pose.orientation !== null) {
        this.object.quaternion.fromArray(pose.orientation);
      }

      if (pose.position !== null) {
        this.object.position.fromArray(pose.position);
      } else {
        this.object.position.set(0, 0, 0);
      }

      if (this.standing) {
        if (this.vrDisplay.stageParameters) {
          this.object.updateMatrix();

          this.standingMatrix.fromArray(
            this.vrDisplay.stageParameters.sittingToStandingTransform
          );
          this.object.applyMatrix(this.standingMatrix);
        } else {
          this.object.position.setY(this.object.position.y + this.userHeight);
        }
      }

      this.object.position.multiplyScalar(this.scale);
    }
  }

  dispose() {
    this.vrDisplay = null;
  }
}

;// CONCATENATED MODULE: ./node_modules/threestrap/src/controls/index.js


;// CONCATENATED MODULE: ./node_modules/threestrap/src/renderers/MultiRenderer.js
/**
 * Allows a stack of renderers to be treated as a single renderer.
 * @author Gheric Speiginer
 */


class MultiRenderer {
  constructor(parameters) {
    console.log("MultiRenderer", REVISION);

    this.domElement = document.createElement("div");
    this.domElement.style.position = "relative";

    this.renderers = [];
    this._renderSizeSet = false;

    const rendererClasses = parameters.renderers || [];
    const rendererParameters = parameters.parameters || [];

    // elements are stacked back-to-front
    for (let i = 0; i < rendererClasses.length; i++) {
      const renderer = new rendererClasses[i](rendererParameters[i]);
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.top = "0px";
      renderer.domElement.style.left = "0px";
      this.domElement.appendChild(renderer.domElement);
      this.renderers.push(renderer);
    }
  }

  setSize(w, h) {
    this.domElement.style.width = w + "px";
    this.domElement.style.height = h + "px";

    for (let i = 0; i < this.renderers.length; i++) {
      const renderer = this.renderers[i];
      const el = renderer.domElement;

      if (!this._renderSizeSet || (el && el.tagName !== "CANVAS")) {
        renderer.setSize(w, h);
      }

      el.style.width = w + "px";
      el.style.height = h + "px";
    }
  }

  setRenderSize(rw, rh) {
    this._renderSizeSet = true;

    for (let i = 0; i < this.renderers.length; i++) {
      const renderer = this.renderers[i];
      const el = renderer.domElement;

      if (el && el.tagName === "CANVAS") {
        renderer.setSize(rw, rh, false);
      }
    }
  }

  render(scene, camera) {
    for (let i = 0; i < this.renderers.length; i++) {
      this.renderers[i].render(scene, camera);
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/threestrap/src/renderers/index.js



;// CONCATENATED MODULE: ./node_modules/threestrap/src/index.js






// These should probably be in their own build!











;// CONCATENATED MODULE: ./src/model/attributes.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
 Custom attribute model
 - Organizes attributes by trait in .attributes
 - Provides constant-time .props / .get() access to flat dictionary
 - Provides .get(key) with or without trait namespaces
 - Change attributes with .set(key) or .set(dictionary)
 - Validation is double-buffered and in-place to detect changes and nops
 - Change notifications are coalesced per object and per trait, digested later
 - Values are stored in three.js uniform-style objects so they can be bound as GL uniforms
 - Originally passed (unnormalized) values are preserved and can be fetched via .orig()
 - Attributes can be defined as final/const
 - Attributes can be computed from both public or private expressions with .bind(key, false/true)
 - Expressions are time-dependent, can be time-travelled with .evaluate()
 - This enables continous simulation and data logging despite choppy animation updates

  Actual type and trait definitions are injected from Primitives
*/

class Attributes {
  constructor(definitions, context) {
    this.context = context;
    this.traits = definitions.Traits;
    this.types = definitions.Types;
    this.pending = [];
    this.bound = [];
    this.last = null;
  }

  make(type) {
    return {
      enum: typeof type.enum === "function" ? type.enum() : undefined,
      type: typeof type.uniform === "function" ? type.uniform() : undefined, // for three.js
      value: type.make(),
    };
  }

  apply(object, config) {
    return new Data(object, config, this);
  }

  bind(callback) {
    return this.bound.push(callback);
  }
  unbind(callback) {
    return (this.bound = Array.from(this.bound).filter(
      (cb) => cb !== callback
    ));
  }

  queue(callback, object, key, value) {
    this.lastObject = object;
    this.lastKey = key;
    this.lastValue = value;
    return this.pending.push(callback);
  }

  invoke(callback) {
    return callback(this.context.time.clock, this.context.time.step);
  }

  compute() {
    if (this.bound.length) {
      for (const cb of Array.from(this.bound)) {
        this.invoke(cb);
      }
    }
  }

  digest() {
    let calls;
    if (!this.pending.length) {
      return false;
    }

    [calls, this.pending] = Array.from([this.pending, []]);
    for (const callback of Array.from(calls)) {
      callback();
    }

    return true;
  }

  getTrait(name) {
    return this.traits[name];
  }

  getLastTrigger() {
    return `${this.lastObject.toString()} - ${this.lastKey}=\`${
      this.lastValue
    }\``;
  }
}

const shallowCopy = function (x) {
  const out = {};
  for (const k in x) {
    const v = x[k];
    out[k] = v;
  }
  return out;
};

class Data {
  constructor(object, config, _attributes) {
    let key, ns, oldComputed, oldExpr, oldOrig, oldProps, spec;
    let { props } = config;
    const { traits, finals, freeform } = config;
    const data = this;

    // Save existing (original) values if re-applying
    if (
      object.props != null &&
      object.expr != null &&
      object.orig != null &&
      object.computed != null &&
      object.attributes != null
    ) {
      oldProps = shallowCopy(object.props);
      oldExpr = shallowCopy(object.expr);
      oldOrig = object.orig();
      oldComputed = object.computed();

      // Dispose of old attributes/bindings
      if (object.attributes != null) {
        object.attributes.dispose();
      }
    }

    // Flattened and original values
    const flattened = {};
    const originals = {};

    // Aliases
    const mapTo = {};
    const to = (name) => (mapTo[name] != null ? mapTo[name] : name);
    const define = function (name, alias) {
      if (mapTo[alias]) {
        throw new Error(
          `${object.toString()} - Duplicate property \`${alias}\``
        );
      }
      return (mapTo[alias] = name);
    };

    // Get/set
    const get = (key) =>
      (data[key] != null ? data[key].value : undefined) != null
        ? data[key] != null
          ? data[key].value
          : undefined
        : __guard__(data[to(key)], (x) => x.value);
    const set = function (key, value, ignore, initial) {
      let attr;
      key = to(key);

      // Look for defined attribute
      if ((attr = data[key]) == null) {
        if (!freeform) {
          throw new Error(
            `${object.toString()} - Setting unknown property \`${key}={${value}}\``
          );
        }

        // Define attribute on the fly (placeholder)
        attr = data[key] = {
          short: key,
          type: null,
          last: null,
          value: null,
        };
        validators[key] = (v) => v;
      }

      if (!ignore) {
        // See if prop isn't bound
        if (_expr[key]) {
          throw new Error(
            `${object.toString()} - Can't set bound property \`${key}={${value}}\``
          );
        }

        // See if prop isn't computed
        if (_computed[key]) {
          throw new Error(
            `${object.toString()} - Can't set computed property \`${key}={${value}}\``
          );
        }

        // See if prop isn't final
        if (_finals[key]) {
          throw new Error(
            `${object.toString()} - Can't set final property \`${key}={${value}}\``
          );
        }
      }

      // Validate new value
      let valid = true;
      const validated = validate(key, value, attr.last, function () {
        valid = false;
        return null;
      });

      // Accept and insert into flattened/original list
      if (valid) {
        [attr.value, attr.last] = Array.from([validated, attr.value]);

        // Remember in flattened dict
        const { short } = attr;
        flattened[short] = validated;
        if (!ignore) {
          originals[short] = value;
        } // Remember original unvalidated value

        // Compare to last value unless setting initial value
        if (!initial && !equals(key, attr.value, attr.last)) {
          change(key, value);
        }
      }

      return valid;
    };

    const constant = function (key, value, initial) {
      key = to(key);

      set(key, value, true, initial);
      return (_finals[key] = true);
    };

    // Prop/expression binding
    const expr = {};

    const _bound = {};
    const _eval = {};
    const _expr = {};
    const _computed = {};
    const _finals = {};

    const bind = function (key, expression, computed) {
      if (computed == null) {
        computed = false;
      }
      key = to(key);

      if (typeof expression !== "function") {
        throw new Error(
          `${object.toString()} - Expression \`${key}=>{${expr}}\` is not a function`
        );
      }
      if (_expr[key]) {
        throw new Error(
          `${object.toString()} - Property \`${key}=>{${expr}}\` is already bound`
        );
      }
      if (_computed[key]) {
        throw new Error(
          `${object.toString()} - Property \`${key}\` is computed`
        );
      }
      if (_finals[key]) {
        throw new Error(`${object.toString()} - Property \`${key}\` is final`);
      }

      const list = computed ? _computed : _expr;
      list[key] = expression;

      const short = data[key] != null ? data[key].short : key;
      if (!computed) {
        expr[short] = expression;
      } // flattened
      _eval[key] = expression;

      expression = expression.bind(object);
      _bound[key] = function (t, d) {
        let clock;
        if (
          (clock = object.clock != null ? object.clock.getTime() : undefined)
        ) {
          t = clock.clock;
          d = clock.step;
        }

        return object.set(key, expression(t, d), true);
      };
      return _attributes.bind(_bound[key]);
    };

    const unbind = function (key, computed) {
      if (computed == null) {
        computed = false;
      }
      key = to(key);

      const list = computed ? _computed : _expr;
      if (!list[key]) {
        return;
      }
      _attributes.unbind(_bound[key]);
      delete _bound[key];
      delete list[key];

      if (data[key] != null) {
        key = data[key].short;
      }
      return delete expr[key];
    };

    const evaluate = function (key, time) {
      let left;
      key = to(key);
      return (left =
        typeof _eval[key] === "function" ? _eval[key](time, 0) : undefined) !=
        null
        ? left
        : data[key].value;
    };

    // Public interface
    object.expr = expr;
    object.props = flattened;

    object.evaluate = function (key, time) {
      if (key != null) {
        return evaluate(key, time);
      } else {
        const out = {};
        for (key in props) {
          out[key] = evaluate(key, time);
        }
        return out;
      }
    };

    object.get = function (key) {
      if (key != null) {
        return get(key);
      } else {
        return flattened;
      }
    };

    object.set = function (key, value, ignore, initial) {
      if (typeof key === "string") {
        set(key, value, ignore, initial);
      } else {
        initial = ignore;
        ignore = value;
        const options = key;
        for (key in options) {
          value = options[key];
          set(key, value, ignore, initial);
        }
      }
    };

    object.bind = function (key, expr, computed) {
      if (typeof key === "string") {
        bind(key, expr, computed);
      } else {
        computed = expr;
        const binds = key;
        for (key in binds) {
          expr = binds[key];
          bind(key, expr, computed);
        }
      }
    };

    object.unbind = function (key, computed) {
      if (typeof key === "string") {
        unbind(key, computed);
      } else {
        computed = expr;
        const binds = key;
        for (key in binds) {
          unbind(key, computed);
        }
      }
    };

    object.attribute = function (key) {
      if (key != null) {
        return data[to(key)];
      } else {
        return data;
      }
    };
    object.orig = function (key) {
      if (key != null) {
        return originals[to(key)];
      } else {
        return shallowCopy(originals);
      }
    };
    object.computed = function (key) {
      if (key != null) {
        return _computed[to(key)];
      } else {
        return shallowCopy(_computed);
      }
    };

    // Validate value for key
    const makers = {};
    const validators = {};
    const equalors = {};

    const equals = (key, value, target) => equalors[key](value, target);
    const validate = (key, value, target, invalid) =>
      validators[key](value, target, invalid);

    object.validate = function (key, value) {
      let target;
      key = to(key);
      const make = makers[key];
      if (make != null) {
        target = make();
      }
      return (target = validate(key, value, target, function () {
        throw new Error(
          `${object.toString()} - Invalid value \`${key}={${value}}\``
        );
      }));
    };

    // Accumulate changes
    let dirty = false;
    let changes = {};
    let touches = {};
    let changed = {};
    let touched = {};
    const getNS = (key) => key.split(".")[0];
    const change = function (key, value) {
      if (!dirty) {
        dirty = true;
        _attributes.queue(digest, object, key, value);
      }

      const trait = getNS(key);

      // Log change
      changes[key] = true;

      // Mark trait/namespace as dirty
      return (touches[trait] = true);
    };

    const event = {
      type: "change",
      changed: null,
      touched: null,
    };

    // Notify listeners of accumulated changes
    const digest = function () {
      // Swap double buffered changes objects
      let k;
      event.changed = changes;
      event.touched = touches;
      changes = changed;
      touches = touched;
      ({ changed } = event);
      ({ touched } = event);

      // Reset all dirty flags
      dirty = false;
      for (k in changes) {
        changes[k] = false;
      }
      for (k in touches) {
        touches[k] = false;
      }

      event.type = "change";
      object.trigger(event);

      return (() => {
        const result = [];
        for (const trait in event.touched) {
          event.type = `change:${trait}`;
          result.push(object.trigger(event));
        }
        return result;
      })();
    };

    // Convert name.trait.key into keyName
    const shorthand = function (name) {
      const parts = name.split(/\./g);
      const suffix = parts.pop();
      parts.pop(); // Discard
      parts.unshift(suffix);
      return parts.reduce(
        (a, b) => a + b.charAt(0).toUpperCase() + b.substring(1)
      );
    };

    // Define attributes for given trait spec by namespace
    const addSpec = (name, spec) =>
      (() => {
        const result = [];
        for (let key in spec) {
          let value;
          const type = spec[key];
          key = [name, key].join(".");
          const short = shorthand(key);

          // Make attribute object
          data[key] = {
            T: type,
            ns: name,
            short,
            enum: typeof type.enum === "function" ? type.enum() : undefined,
            type:
              typeof type.uniform === "function" ? type.uniform() : undefined,
            last: type.make(),
            value: (value = type.make()),
          };

          // Define flat namespace alias
          define(key, short);
          flattened[short] = value;

          // Collect makers, validators and comparators
          makers[key] = type.make;
          validators[key] = type.validate != null ? type.validate : (a) => a;
          result.push(
            (equalors[key] =
              type.equals != null ? type.equals : (a, b) => a === b)
          );
        }
        return result;
      })();

    // Add in traits
    const list = [];
    for (let trait of Array.from(traits)) {
      [trait, ns] = Array.from(trait.split(":"));
      const name = ns ? [ns, trait].join(".") : trait;
      spec = _attributes.getTrait(trait);
      list.push(trait);

      if (spec != null) {
        addSpec(name, spec);
      }
    }

    // Add custom props by namespace
    if (props != null) {
      for (ns in props) {
        spec = props[ns];
        addSpec(ns, spec);
      }
    }

    // Store array of traits
    const unique = list.filter((object, i) => list.indexOf(object) === i);
    object.traits = unique;

    // Set previous internal values
    if (oldProps != null) {
      object.set(oldProps, true, true);
    }

    // Set final props
    if (finals != null) {
      for (key in finals) {
        const value = finals[key];
        constant(key, value, true);
      }
    }

    // Set previous external values
    if (oldOrig != null) {
      object.set(oldOrig, false, true);
    }

    // Bind previous computed props/expressions
    if (oldComputed != null) {
      object.bind(oldComputed, true);
    }
    if (oldExpr != null) {
      object.bind(oldExpr, false);
    }

    // Destructor
    this.dispose = function () {
      for (key in _computed) {
        unbind(key, true);
      }
      for (key in _expr) {
        unbind(key, false);
      }
      props = {};
      delete object.attributes;
      delete object.get;
      return delete object.set;
    };

    null;
  }
}

function __guard__(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/util/pretty.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
const NUMBER_PRECISION = 5;
const NUMBER_THRESHOLD = 0.0001;

const checkFactor = (v, f) =>
  Math.abs(v / f - Math.round(v / f)) < NUMBER_THRESHOLD;
const checkUnit = (v) => checkFactor(v, 1);

const formatMultiple = function (v, f, k, compact) {
  const d = Math.round(v / f);
  if (d === 1) {
    return `${k}`;
  }
  if (d === -1) {
    return `-${k}`;
  }
  if (k === "1") {
    return `${d}`;
  }
  if (compact) {
    return `${d}${k}`;
  } else {
    return `${d}*${k}`;
  }
};

const formatFraction = function (v, f, k, compact) {
  let d = Math.round(v * f);
  if (Math.abs(d) === 1) {
    d = d < 0 ? "-" : "";
    d += k;
  } else if (k !== "1") {
    d += compact ? `${k}` : `*${k}`;
  }

  return `${d}/${f}`;
};

const formatFactors = [
  { 1: 1 },
  { 1: 1, τ: Math.PI * 2 },
  { 1: 1, π: Math.PI },
  { 1: 1, τ: Math.PI * 2, π: Math.PI },
  { 1: 1, e: Math.E },
  { 1: 1, τ: Math.PI * 2, e: Math.E },
  { 1: 1, π: Math.PI, e: Math.E },
  { 1: 1, τ: Math.PI * 2, π: Math.PI, e: Math.E },
];
const formatPrimes = [
  // denominators 1-30 + interesting multiples
  [2 * 2 * 3 * 5 * 7, [2, 3, 5, 7]], // 1-7
  [2 * 2 * 2 * 3 * 3 * 5 * 5 * 7 * 7, [2, 3, 5, 7]], // 8-11
  [2 * 2 * 3 * 5 * 7 * 11 * 13, [2, 3, 5, 7, 11, 13]], // 12-16
  [2 * 2 * 17 * 19 * 23 * 29, [2, 17, 19, 23, 29]], // 17-30
  [256 * 256, [2]], // Powers of 2
  [1000000, [2, 5]], // Powers of 10
];

const prettyNumber = function (options) {
  let cache, compact, e, pi, tau;
  if (options) {
    ({ cache, compact, tau, pi, e } = options);
  }

  compact = +!!(compact != null ? compact : true);
  tau = +!!(tau != null ? tau : true);
  pi = +!!(pi != null ? pi : true);
  e = +!!(e != null ? e : true);
  cache = +!!(cache != null ? cache : true);

  const formatIndex = tau + pi * 2 + e * 4;

  const numberCache = cache ? {} : null;

  return function (v) {
    if (numberCache != null) {
      let cached;
      if ((cached = numberCache[v]) != null) {
        return cached;
      }
      if (v === Math.round(v)) {
        return (numberCache[v] = `${v}`);
      }
    }

    let out = `${v}`;
    let best = out.length + out.indexOf(".") + 2;
    const match = function (x) {
      const d = x.length;
      if (d <= best) {
        out = `${x}`;
        return (best = d);
      }
    };

    for (const k in formatFactors[formatIndex]) {
      const f = formatFactors[formatIndex][k];
      if (checkUnit(v / f)) {
        match(`${formatMultiple(v / f, 1, k, compact)}`);
      } else {
        // eslint-disable-next-line prefer-const
        for (let [denom, list] of Array.from(formatPrimes)) {
          let numer = (v / f) * denom;
          if (checkUnit(numer)) {
            for (const p of Array.from(list)) {
              let d, n;
              while (checkUnit((n = numer / p)) && checkUnit((d = denom / p))) {
                numer = n;
                denom = d;
              }
            }

            match(`${formatFraction(v / f, denom, k, compact)}`);
            break;
          }
        }
      }
    }

    if (`${v}`.length > NUMBER_PRECISION) {
      match(`${v.toPrecision(NUMBER_PRECISION)}`);
    }

    if (numberCache != null) {
      numberCache[v] = out;
    }

    return out;
  };
};

const prettyPrint = function (markup, level) {
  if (level == null) {
    level = "info";
  }
  markup = prettyMarkup(markup);
  return console[level].apply(console, markup);
};

const prettyMarkup = function (markup) {
  // quick n dirty

  const tag = "color:rgb(128,0,128)";
  const attr = "color:rgb(144,64,0)";
  const str = "color:rgb(0,0,192)";
  const obj = "color:rgb(0,70,156)";
  const txt = "color:inherit";

  let quoted = false;
  let nested = 0;

  const args = [];
  markup = markup.replace(
    /(\\[<={}> "'])|(=>|[<={}> "'])/g,
    function (_, escape, char) {
      if (escape != null ? escape.length : undefined) {
        return escape;
      }
      if (quoted && !['"', "'"].includes(char)) {
        return char;
      }
      if (nested && !['"', "'", "{", "}"].includes(char)) {
        return char;
      }

      return (() => {
        switch (char) {
          case "<":
            args.push(tag);
            return "%c<";
          case ">":
            args.push(tag);
            args.push(txt);
            return "%c>%c";
          case " ":
            args.push(attr);
            return " %c";
          case "=":
          case "=>":
            args.push(tag);
            return `%c${char}`;
          case '"':
          case "'":
            quoted = !quoted;
            if (quoted) {
              args.push(nested ? attr : str);
              return `${char}%c`;
            } else {
              args.push(nested ? obj : tag);
              return `%c${char}`;
            }
          case "{":
            if (nested++ === 0) {
              args.push(obj);
              return `%c${char}`;
            } else {
              return char;
            }
          case "}":
            if (--nested === 0) {
              args.push(tag);
              return `${char}%c`;
            } else {
              return char;
            }
          default:
            return char;
        }
      })();
    }
  );

  return [markup].concat(args);
};

const prettyJSXProp = (k, v) => prettyJSXPair(k, v, "=");
const prettyJSXBind = (k, v) => prettyJSXPair(k, v, "=>");

const prettyJSXPair = (function () {
  const formatNumber = prettyNumber({ compact: false });

  return function (k, v, op) {
    const key = function (k) {
      if (k === "" + +k || k.match(/^[A-Za-z_][A-Za-z0-9]*$/)) {
        return k;
      } else {
        return JSON.stringify(k);
      }
    };
    const wrap = function (v) {
      if (v.match('\n*"')) {
        return v;
      } else {
        return `{${v}}`;
      }
    };
    const value = function (v) {
      if (v instanceof Array) {
        return `[${v.map(value).join(", ")}]`;
      }

      switch (typeof v) {
        case "string":
          if (v.match("\n")) {
            return `"\n${v}"\n`;
          } else {
            return `"${v}"`;
          }
        case "function":
          v = `${v}`;
          if (v.match("\n")) {
            `\n${v}\n`;
          } else {
            `${v}`;
          }
          v = v.replace(/^function (\([^)]*\))/, "$1 =>");
          return (v = v.replace(
            /^(\([^)]*\)) =>\s*{\s*return\s*([^}]+)\s*;\s*}/,
            "$1 => $2"
          ));
        case "number":
          return formatNumber(v);
        default:
          if (v != null && v !== !!v) {
            if (v._up != null) {
              return value(v.map((v) => v));
            }
            if (v.toMarkup) {
              return v.toString();
            } else {
              return (
                "{" +
                (() => {
                  const result = [];
                  for (const kk in v) {
                    const vv = v[kk];
                    if (Object.prototype.hasOwnProperty.call(v, kk)) {
                      result.push(`${key(kk)}: ${value(vv)}`);
                    }
                  }
                  return result;
                })().join(", ") +
                "}"
              );
            }
          } else {
            return `${JSON.stringify(v)}`;
          }
      }
    };

    return [k, op, wrap(value(v))].join("");
  };
})();

const escapeHTML = function (str) {
  str = str.replace(/&/g, "&amp;");
  str = str.replace(/</g, "&lt;");
  return (str = str.replace(/"/g, "&quot;"));
};

const prettyFormat = function (str) {
  const args = [].slice.call(arguments);
  args.shift();

  let out = "<span>";

  str = escapeHTML(str);

  // eslint-disable-next-line no-unused-vars
  for (const _arg of Array.from(args)) {
    str = str.replace(/%([a-z])/, function (_, f) {
      const v = args.shift();
      switch (f) {
        case "c":
          return `</span><span style="${escapeHTML(v)}">`;
        default:
          return escapeHTML(v);
      }
    });
  }

  out += str;
  return (out += "</span>");
};

const JSX = { prop: prettyJSXProp, bind: prettyJSXBind };



/*
for x in [1, 2, 1/2, 3, 1/3, Math.PI, Math.PI / 2, Math.PI * 2, Math.PI * 3, Math.PI * 4, Math.PI * 3 / 4, Math.E * 100, Math.E / 100]
  console.log prettyNumber({})(x)
*/

;// CONCATENATED MODULE: ./src/model/node.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




let nodeIndex = 0;

class node_Node {
  constructor(type, defaults, options, binds, config, attributes) {
    this.type = type;
    this._id = (++nodeIndex).toString();

    this.configure(config, attributes);
    this.parent = this.root = this.path = this.index = null;

    this.set(defaults, true, true);
    this.set(options, false, true);
    this.bind(binds, false);
  }

  configure(config, attributes) {
    let { traits, props, finals, freeform } = config;
    if (traits == null) {
      traits =
        (this._config != null ? this._config.traits : undefined) != null
          ? this._config != null
            ? this._config.traits
            : undefined
          : [];
    }
    if (props == null) {
      props =
        (this._config != null ? this._config.props : undefined) != null
          ? this._config != null
            ? this._config.props
            : undefined
          : {};
    }
    if (finals == null) {
      finals =
        (this._config != null ? this._config.finals : undefined) != null
          ? this._config != null
            ? this._config.finals
            : undefined
          : {};
    }
    if (freeform == null) {
      freeform =
        (this._config != null ? this._config.freeform : undefined) != null
          ? this._config != null
            ? this._config.freeform
            : undefined
          : false;
    }

    this._config = { traits, props, finals, freeform };
    return (this.attributes = attributes.apply(this, this._config));
  }

  dispose() {
    this.attributes.dispose();
    return (this.attributes = null);
  }

  // Add/removal callback
  _added(parent) {
    this.parent = parent;
    this.root = parent.root;

    // Notify root listeners of child addition
    const event = {
      type: "add",
      node: this,
      parent: this.parent,
    };
    if (this.root) {
      this.root.trigger(event);
    }

    // Notify self listeners of own addition
    event.type = "added";
    return this.trigger(event);
  }

  _removed() {
    // Notify root listeners of child removal
    const event = {
      type: "remove",
      node: this,
    };
    if (this.root) {
      this.root.trigger(event);
    }

    // Notify self listeners of own removal
    event.type = "removed";
    this.trigger(event);

    return (this.root = this.parent = null);
  }

  // Assign unique indices to nodes to make paths
  _index(index, parent) {
    let path;
    if (parent == null) {
      ({ parent } = this);
    }
    this.index = index;
    this.path = path =
      index != null
        ? ((parent != null ? parent.path : undefined) != null
            ? parent != null
              ? parent.path
              : undefined
            : []
          ).concat([index])
        : null;
    this.order = path != null ? this._encode(path) : Infinity;
    if (this.root != null) {
      return this.trigger({ type: "reindex" });
    }
  }

  // Asymptotic arithmetic encoding
  // Computes invariant node order from path of indices
  // Goes from 1 at the root [0] of the tree, to 0 at [∞] (best for FP precision).
  // Divides the interval into countably infinite many intervals, nested recursively.
  //
  // (loses precision eventually, it's used cos three.js needs a single numerical order)
  _encode(path) {
    // Tune precision between deep and narrow (1) vs shallow and wide (n)
    const k = 3;

    const map = (x) => k / (x + k);
    const lerp = (t) => b + (a - b) * t;

    let a = 1 + 1 / k;
    let b = 0;
    for (const index of Array.from(path)) {
      const f = map(index + 1);
      const g = map(index + 2);
      [a, b] = Array.from([lerp(f), lerp(g)]);
    }
    return a;
  }

  toString() {
    const _id = this.id != null ? this.id : this._id;

    const tag = this.type != null ? this.type : "node";
    let id = tag;
    id += `#${_id}`;
    if (this.classes != null ? this.classes.length : undefined) {
      id += `.${this.classes.join(".")}`;
    }

    if (this.children != null) {
      let count;
      if ((count = this.children.length)) {
        return `<${id}>…(${count})…</${tag}>`;
      } else {
        return `<${id}></${tag}>`;
      }
    } else {
      return `<${id} />`;
    }
  }

  toMarkup(selector = null, indent) {
    let k, v;
    if (indent == null) {
      indent = "";
    }
    if (selector && typeof selector !== "function") {
      let left;
      selector =
        (left =
          this.root != null ? this.root.model._matcher(selector) : undefined) !=
        null
          ? left
          : () => true;
    }

    const tag = this.type != null ? this.type : "node";
    let { expr } = this;

    // Ensure generated ID goes first
    const orig = { id: this._id };
    const object = typeof this.orig === "function" ? this.orig() : undefined;
    for (k in object) {
      v = object[k];
      orig[k] = v;
    }

    const props = (() => {
      const result = [];
      for (k in orig) {
        v = orig[k];
        if (!this.expr[k]) {
          result.push(JSX.prop(k, v));
        }
      }
      return result;
    })();
    expr = (() => {
      const result1 = [];
      for (k in expr) {
        v = expr[k];
        result1.push(JSX.bind(k, v));
      }
      return result1;
    })();

    let attr = [""];
    if (props.length) {
      attr = attr.concat(props);
    }
    if (expr.length) {
      attr = attr.concat(expr);
    }
    attr = attr.join(" ");

    let child = indent;
    const recurse = () => {
      if (!(this.children != null ? this.children.length : undefined)) {
        return "";
      }
      return this.children
        .map((x) => x.toMarkup(selector, child))
        .filter((x) => x != null && x.length)
        .join("\n");
    };

    if (selector && !selector(this)) {
      return recurse();
    }

    if (this.children != null) {
      const open = `<${tag}${attr}>`;
      const close = `</${tag}>`;

      child = indent + "  ";
      let children = recurse();
      if (children.length) {
        children = "\n" + children + "\n" + indent;
      }
      if (children == null) {
        children = "";
      }

      return indent + open + children + close;
    } else {
      return `${indent}<${tag}${attr} />`;
    }
  }

  print(selector, level) {
    return prettyPrint(this.toMarkup(selector), level);
  }
}

Binder.apply(node_Node.prototype);

;// CONCATENATED MODULE: ./src/model/group.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Group extends node_Node {
  constructor(type, defaults, options, binds, config, attributes) {
    super(type, defaults, options, binds, config, attributes);

    this.children = [];
    this.on("reindex", (event) =>
      Array.from(this.children).map((child) => child.trigger(event))
    );
  }

  add(node) {
    if (node.parent != null) {
      node.parent.remove(node);
    }

    node._index(this.children.length, this);
    this.children.push(node);
    return node._added(this);
  }

  remove(node) {
    if (node.children != null ? node.children.length : undefined) {
      node.empty();
    }

    const index = this.children.indexOf(node);
    if (index === -1) {
      return;
    }

    this.children.splice(index, 1);
    node._index(null);
    node._removed(this);

    for (let i = 0; i < this.children.length; i++) {
      node = this.children[i];
      if (i >= index) {
        node._index(i);
      }
    }
  }

  empty() {
    const children = this.children.slice().reverse();
    for (const node of Array.from(children)) {
      this.remove(node);
    }
  }
}

;// CONCATENATED MODULE: ./src/model/guard.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
class Guard {
  constructor(limit) {
    if (limit == null) {
      limit = 10;
    }
    this.limit = limit;
  }
  iterate(options) {
    const { step, last } = options;

    let { limit } = this;
    while (step()) {
      if (!--limit) {
        console.warn(
          "Last iteration",
          typeof last === "function" ? last() : undefined
        );
        throw new Error("Exceeded iteration limit.");
      }
    }
    return null;
  }
}

// EXTERNAL MODULE: ./node_modules/css-select/lib/index.js
var lib = __webpack_require__(5366);
;// CONCATENATED MODULE: ./src/model/css-select-adapter.js
/**
 * This file contains an *adapter* for css-select. css-select is a CSS selection
 * engine for HTML that can be used with other data structures (XML, etc) via
 * adapters. Here we define an adapter for MathBox's vdom.
 *
 * The adapter interface is described here:
 *    https://github.com/fb55/css-select/blob/1aa44bdd64aaf2ebdfd7f338e2e76bed36521957/src/types.ts#L6-L96
 *
 * Nodes vs Elements:
 * In general, CSS Selectors act on a document tree built from nodes, which can
 * include element nodes and non-element nodes. For example, in HTML, tags are
 * element nodes but lines of text are non-element node. Non-element text nodes
 * can influence css selection, e.g., via :first-line pseudoclass, but these
 * non-element nodes are never returned by selectors.
 *
 * Mathbox only has element nodes.
 */

/**
 * Is this node an element node? Yes. Mathbox only has element nodes.
 */
function isTag(_elem) {
  return true;
}

function getChildren(elem) {
  return elem.children || [];
}

function getParent(elem) {
  return elem.parent;
}

/**
 * Takes an array of nodes, and removes any duplicates, as well as any
 * nodes whose ancestors are also in the array.
 */
function removeSubsets(nodes) {
  const deduped = new Set(nodes);

  deduped.forEach((node) => {
    let ancestor = node.parent;
    while (ancestor) {
      if (deduped.has(ancestor)) {
        deduped.delete(node);
        return;
      }
      ancestor = ancestor.parent;
    }
  });

  return Array.from(deduped);
}

const adapter = {
  isTag,
  /**
   * Does at least one of passed element nodes pass the test predicate?
   */
  existsOne(test, elems) {
    return elems.some((elem) =>
      isTag(elem)
        ? test(elem) || adapter.existsOne(test, getChildren(elem))
        : false
    );
  },
  /**
   * Get the siblings of the node. Note that unlike jQuery's `siblings` method,
   * this is expected to include the current node as well
   */
  getSiblings(elem) {
    const parent = getParent(elem);
    return parent ? getChildren(parent) : [elem];
  },
  getChildren,
  getParent,
  getAttributeValue(elem, name) {
    if (name === "class") return elem.props.classes.join(" ");
    if (name === "id") return elem.id;
    return "";
  },
  hasAttrib(elem, name) {
    if (name === "id") return !!elem.id;
    if (name === "class") return elem.props.classes.length > 0;
    if (!elem.traits.hash) return false;
    return Object.prototype.hasOwnProperty.call(elem.traits.hash, name);
  },
  removeSubsets,
  getName(elem) {
    return elem.type ?? "";
  },
  /**
   * Finds the first node in the array that matches the test predicate, or one
   * of its children.
   */
  findOne: function findOne(test, elems) {
    for (const node of elems) {
      if (test(node)) {
        return node;
      } else {
        const match = findOne(test, getChildren(node));
        if (match) return match;
      }
    }

    return null;
  },
  findAll: function findAll(test, elems) {
    const result = [];
    for (const elem of elems) {
      if (!isTag(elem)) continue;
      if (test(elem)) {
        result.push(elem);
      }
      result.push(...findAll(test, getChildren(elem)));
    }
    return result;
  },
  getText: function getText(_elem) {
    return "";
  },
};

/* harmony default export */ const css_select_adapter = (adapter);

;// CONCATENATED MODULE: ./src/model/css-select-adapted.js



/**
 * Returns a filtered array of elements which are contained in context.
 */
const filter = (nodes, context) => {
  const out = [];
  const contextNodes = Array.isArray(context) ? context : [context];
  const contextSet = new Set(contextNodes);
  for (const node of Array.from(nodes)) {
    let ancestor = node;
    while (ancestor != null) {
      if (contextSet.has(ancestor)) {
        out.push(node);
        break;
      }
      ancestor = css_select_adapter.getParent(ancestor);
    }
  }
  return out;
};

const getRoot = (element) => {
  let ancestor = element;
  while (css_select_adapter.getParent(ancestor) !== null) {
    ancestor = css_select_adapter.getParent(ancestor);
  }
  return ancestor;
};

/**
 * Finds elements in the given context matching the given css-selector.
 *
 * Does NOT throw if css query is invalid.
 *
 * @param {string} query A css selector
 * @param {*} context Element or array of elements
 * @returns All elements in context matching query
 */
const selectAll = (query, context) => {
  try {
    /**
     * Try/catch to tolerate invalid css queries.
     * See https://gitgud.io/unconed/mathbox/-/issues/23
     */
    lib.compile(query);
  } catch (err) {
    return [];
  }

  /**
   * Delegate to css-select, except always make queries relative to root and
   * filter matches outside of context ourselves. css-select does not currently
   * handle contextualized queries relative to root correctly.
   *
   * See https://github.com/fb55/css-select/issues/709
   */

  const isArray = Array.isArray(context);
  if (isArray && context.length === 0) return [];
  const root = getRoot(isArray ? context[0] : context);
  const matches = lib.selectAll(query, root, { adapter: css_select_adapter });
  if (context) return filter(matches, context);
  return matches;
};

const compile = (query) => {
  try {
    /**
     * Try/catch to tolerate invalid css queries.
     * See https://gitgud.io/unconed/mathbox/-/issues/23
     */
    return lib.compile(query, { adapter: css_select_adapter });
  } catch (err) {
    return () => false;
  }
};

;// CONCATENATED MODULE: ./src/model/model.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


const AUTO = /^<([0-9]+|<*)$/;

/*
  Model that wraps a root node and its children.

  Monitors adds, removals and ID/class changes.
  Enables CSS selectors, both querying and watching.

  Watchers are primed differentially as changes come in,
  and fired with digest().
*/
class Model {
  constructor(root) {
    this.root = root;
    this.root.model = this;
    this.root.root = this.root;

    this.ids = {};
    this.classes = {};
    this.traits = {};
    this.types = {};
    this.nodes = [];
    this.watchers = [];
    this.fire = false;

    this.lastNode = null;

    this.event = { type: "update" };

    // Triggered by child addition/removal
    const add = (event) => adopt(event.node);
    const remove = (event) => dispose(event.node);

    this.root.on("add", add);
    this.root.on("remove", remove);

    // Track node lifecycle
    const adopt = (node) => {
      addNode(node);
      addType(node);
      addTraits(node);

      node.on("change:node", update);
      update(null, node, true);
      return force(node);
    };

    const dispose = (node) => {
      removeNode(node);
      removeType(node);
      removeTraits(node);
      removeID(node.id, node);
      removeClasses(node.classes, node);

      node.off("change:node", update);
      return force(node);
    };

    // Watcher cycle for catching changes in id/classes
    const prime = (node) => {
      for (const watcher of Array.from(this.watchers)) {
        watcher.match = watcher.matcher(node);
      }
      return null;
    };

    const check = (node) => {
      for (const watcher of Array.from(this.watchers)) {
        const fire =
          watcher.fire ||
          (watcher.fire = watcher.match !== watcher.matcher(node));
        if (fire) {
          this.lastNode = node;
        }
        if (!this.fire) {
          this.fire = fire;
        }
      }
      return null;
    };

    const force = (node) => {
      for (const watcher of Array.from(this.watchers)) {
        const fire = watcher.fire || (watcher.fire = watcher.matcher(node));
        if (fire) {
          this.lastNode = node;
        }
        if (!this.fire) {
          this.fire = fire;
        }
      }
      return null;
    };

    this.digest = () => {
      if (!this.fire) {
        return false;
      }
      for (const watcher of Array.from(this.watchers.slice())) {
        if (watcher.fire) {
          watcher.fire = false;
          watcher.handler();
        }
      }
      this.fire = false;
      return true;
    };

    // Track id/class changes
    const update = (event, node, init) => {
      const _id = init || event.changed["node.id"];
      const _klass = init || event.changed["node.classes"];
      let primed = false;

      if (_id) {
        const id = node.get("node.id");
        if (id !== node.id) {
          if (!init) {
            prime(node);
          }
          primed = true;

          if (node.id != null) {
            removeID(node.id, node);
          }
          addID(id, node);
        }
      }

      if (_klass) {
        let left;
        let classes = (left = node.get("node.classes")) != null ? left : [];
        const klass = classes.join(",");
        if (klass !== (node.classes != null ? node.classes.klass : undefined)) {
          classes = classes.slice();

          if (!init && !primed) {
            prime(node);
          }
          primed = true;

          if (node.classes != null) {
            removeClasses(node.classes, node);
          }
          addClasses(classes, node);

          node.classes = classes;
          node.classes.klass = klass;
        }
      }

      if (!init && primed) {
        check(node);
      }
      return null;
    };

    // Manage lookup tables for types/classes/traits
    const addTags = function (sets, tags, node) {
      if (tags == null) {
        return;
      }
      for (const k of Array.from(tags)) {
        const list = sets[k] != null ? sets[k] : [];
        list.push(node);
        sets[k] = list;
      }
      return null;
    };

    const removeTags = function (sets, tags, node) {
      if (tags == null) {
        return;
      }
      for (const k of Array.from(tags)) {
        const list = sets[k];
        const index = list.indexOf(node);
        if (index >= 0) {
          list.splice(index, 1);
        }
        if (list.length === 0) {
          delete sets[k];
        }
      }
      return null;
    };

    // Build a hash for an array of tags for quick lookups
    const hashTags = function (array) {
      if (!(array.length > 0)) {
        return;
      }
      const hash = (array.hash = {});
      return Array.from(array).map((klass) => (hash[klass] = true));
    };

    const unhashTags = (array) => delete array.hash;

    // Track IDs (live)
    const addID = (id, node) => {
      if (this.ids[id]) {
        throw new Error(`Duplicate node id \`${id}\``);
      }

      if (id != null) {
        this.ids[id] = [node];
      }
      return (node.id = id != null ? id : node._id);
    };

    const removeID = (id, node) => {
      if (id != null) {
        delete this.ids[id];
      }
      return (node.id = node._id);
    };

    // Track classes (live)
    const addClasses = (classes, node) => {
      addTags(this.classes, classes, node);
      if (classes != null) {
        return hashTags(classes);
      }
    };

    const removeClasses = (classes, node) => {
      removeTags(this.classes, classes, node);
      if (classes != null) {
        return unhashTags(classes);
      }
    };

    // Track nodes
    const addNode = (node) => this.nodes.push(node);
    const removeNode = (node) => this.nodes.splice(this.nodes.indexOf(node), 1);

    // Track nodes by type
    const addType = (node) => addTags(this.types, [node.type], node);
    const removeType = (node) => removeTags(this.types, [node.type], node);

    // Track nodes by trait
    const addTraits = (node) => {
      addTags(this.traits, node.traits, node);
      return hashTags(node.traits);
    };

    const removeTraits = (node) => {
      removeTags(this.traits, node.traits, node);
      return unhashTags(node.traits);
    };

    adopt(this.root);
    this.root.trigger({ type: "added" });
  }

  select(query, context) {
    return selectAll(query, context || this.getRoot());
  }

  // Watch selector with handler
  watch(selector, handler) {
    let watcher;
    handler.unwatch = () => this.unwatch(handler);
    handler.watcher = watcher = {
      selector,
      handler,
      matcher: this._matcher(selector),
      match: false,
      fire: false,
    };
    this.watchers.push(watcher);
    return this.select(selector);
  }

  // Unwatch a handler
  unwatch(handler) {
    const { watcher } = handler;
    if (watcher == null) {
      return;
    }

    this.watchers.splice(this.watchers.indexOf(watcher), 1);
    delete handler.unwatch;
    return delete handler.watcher;
  }

  // Make a matcher for a single selector
  _matcher(query) {
    if (AUTO.test(query)) {
      throw new Error("Auto-link matcher unsupported");
    }
    return compile(query);
  }

  getRoot() {
    return this.root;
  }

  getLastTrigger() {
    return this.lastNode.toString();
  }
}

;// CONCATENATED MODULE: ./src/model/index.js






;// CONCATENATED MODULE: ./src/overlay/factory.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
class OverlayFactory {
  constructor(classes, canvas) {
    this.classes = classes;
    this.canvas = canvas;
    const div = document.createElement("div");
    div.classList.add("mathbox-overlays");
    this.div = div;
  }

  inject() {
    const element = this.canvas.parentNode;
    if (!element) {
      throw new Error("Canvas not inserted into document.");
    }
    return element.insertBefore(this.div, this.canvas);
  }

  unject() {
    const element = this.div.parentNode;
    return element.removeChild(this.div);
  }

  getTypes() {
    return Object.keys(this.classes);
  }

  make(type, options) {
    return new this.classes[type](this.div, options);
  }
}

;// CONCATENATED MODULE: ./src/util/vdom.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// Quick'n'dirty Virtual DOM diffing
// with a poor man's React for components
//
// This is for rendering HTML with data from a GL readback. See DOM examples.
const HEAP = [];
let id = 0;

// Static render components
const Types = {
  /*
  * el('example', props, children);
  example: MathBox.DOM.createClass({
    render: (el, props, children) ->
      * VDOM node
      return el('span', { className: "foo" }, "Hello World")
  })
  */
};

const descriptor = () => ({
  id: id++,
  type: null,
  props: null,
  children: null,
  rendered: null,
  instance: null,
});

const hint = function (n) {
  n *= 2;
  n = Math.max(0, HEAP.length - n);
  return __range__(0, n, false).map((_i) => HEAP.push(descriptor()));
};

const vdom_element = function (type, props, children) {
  const el = HEAP.length ? HEAP.pop() : descriptor();

  el.type = type != null ? type : "div";
  el.props = props != null ? props : null;
  el.children = children != null ? children : null;
  // Can't use `arguments` here to pass children as direct args, it de-optimizes label emitters

  return el;
};

const recycle = function (el) {
  if (!el.type) {
    return;
  }

  const { children } = el;
  el.type = el.props = el.children = el.instance = null;

  HEAP.push(el);

  if (children != null) {
    for (const child of Array.from(children)) {
      recycle(child);
    }
  }
};

const apply = function (el, last, node, parent, index) {
  if (el != null) {
    if (last == null) {
      // New node
      return mount(el, parent, index);
    } else {
      // Literal DOM node
      let same;
      if (el instanceof Node) {
        same = el === last;
        if (same) {
          return;
        }
      } else {
        // Check compatibility
        same =
          typeof el === typeof last &&
          last !== null &&
          el !== null &&
          el.type === last.type;
      }

      if (!same) {
        // Not compatible: unmount and remount
        unmount(last.instance, node);
        node.remove();
        return mount(el, parent, index);
      } else {
        // Maintain component ref
        let key, ref, value;
        el.instance = last.instance;

        // Check if it's a component
        const type = (el.type != null ? el.type.isComponentClass : undefined)
          ? el.type
          : Types[el.type];

        // Prepare to diff props and children
        const props = last != null ? last.props : undefined;
        const nextProps = el.props;
        const children =
          (last != null ? last.children : undefined) != null
            ? last != null
              ? last.children
              : undefined
            : null;
        const nextChildren = el.children;

        if (nextProps != null) {
          nextProps.children = nextChildren;
        }

        // Component
        if (type != null) {
          // See if it changed
          let dirty = node._COMPONENT_DIRTY;

          if ((props != null) !== (nextProps != null)) {
            dirty = true;
          }
          if (children !== nextChildren) {
            dirty = true;
          }

          if (props != null && nextProps != null) {
            if (!dirty) {
              for (key in props) {
                if (!Object.prototype.hasOwnProperty.call(nextProps, key)) {
                  dirty = true;
                }
              }
            }
            if (!dirty) {
              for (key in nextProps) {
                value = nextProps[key];
                if ((ref = props[key]) !== value) {
                  dirty = true;
                }
              }
            }
          }

          if (dirty) {
            let left;
            const comp = last.instance;
            if (el.props == null) {
              el.props = {};
            }
            for (const k in comp.defaultProps) {
              const v = comp.defaultProps[k];
              if (el.props[k] == null) {
                el.props[k] = v;
              }
            }
            el.props.children = el.children;

            if (typeof comp.willReceiveProps === "function") {
              comp.willReceiveProps(el.props);
            }
            const should =
              node._COMPONENT_FORCE ||
              ((left =
                typeof comp.shouldUpdate === "function"
                  ? comp.shouldUpdate(el.props)
                  : undefined) != null
                ? left
                : true);

            if (should) {
              const nextState = comp.getNextState();
              if (typeof comp.willUpdate === "function") {
                comp.willUpdate(el.props, nextState);
              }
            }

            const prevProps = comp.props;
            const prevState = comp.applyNextState();

            comp.props = el.props;
            comp.children = el.children;

            if (should) {
              el = el.rendered =
                typeof comp.render === "function"
                  ? comp.render(vdom_element, el.props, el.children)
                  : undefined;
              apply(el, last.rendered, node, parent, index);

              if (typeof comp.didUpdate === "function") {
                comp.didUpdate(prevProps, prevState);
              }
            }
          }

          return;
        } else {
          // VDOM node
          if (props != null) {
            for (key in props) {
              if (!Object.prototype.hasOwnProperty.call(nextProps, key)) {
                unset(node, key, props[key]);
              }
            }
          }
          if (nextProps != null) {
            for (key in nextProps) {
              value = nextProps[key];
              if ((ref = props[key]) !== value && key !== "children") {
                set(node, key, value, ref);
              }
            }
          }

          // Diff children
          if (nextChildren != null) {
            if (["string", "number"].includes(typeof nextChildren)) {
              // Insert text directly
              if (nextChildren !== children) {
                node.textContent = nextChildren;
              }
            } else {
              if (nextChildren.type != null) {
                // Single child
                apply(nextChildren, children, node.childNodes[0], node, 0);
              } else {
                // Diff children
                let child, i;
                const { childNodes } = node;
                if (children != null) {
                  for (i = 0; i < nextChildren.length; i++) {
                    child = nextChildren[i];
                    apply(child, children[i], childNodes[i], node, i);
                  }
                } else {
                  for (i = 0; i < nextChildren.length; i++) {
                    child = nextChildren[i];
                    apply(child, null, childNodes[i], node, i);
                  }
                }
              }
            }
          } else if (children != null) {
            // Unmount all child components
            unmount(null, node);

            // Remove all children
            node.innerHTML = "";
          }
        }

        return;
      }
    }
  }

  if (last != null) {
    // Removed node
    unmount(last.instance, node);
    return last.node.remove();
  }
};

const mount = function (el, parent, index) {
  let node;
  if (index == null) {
    index = 0;
  }
  const type = (el.type != null ? el.type.isComponentClass : undefined)
    ? el.type
    : Types[el.type];

  // Literal DOM node
  if (el instanceof Node) {
    node = el;
  } else {
    if (type != null) {
      // Component
      let comp;
      const ctor = (el.type != null ? el.type.isComponentClass : undefined)
        ? el.type
        : Types[el.type];

      // No component class found
      if (!ctor) {
        el = el.rendered = vdom_element("noscript");
        node = mount(el, parent, index);
        return node;
      }

      // Construct component class
      el.instance = comp = new ctor(parent);
      if (el.props == null) {
        el.props = {};
      }
      for (const k in comp.defaultProps) {
        const v = comp.defaultProps[k];
        if (el.props[k] == null) {
          el.props[k] = v;
        }
      }
      el.props.children = el.children;

      // Do initial state transition
      comp.props = el.props;
      comp.children = el.children;
      comp.setState(
        typeof comp.getInitialState === "function"
          ? comp.getInitialState()
          : undefined
      );
      if (typeof comp.willMount === "function") {
        comp.willMount();
      }

      // Render
      el = el.rendered =
        typeof comp.render === "function"
          ? comp.render(vdom_element, el.props, el.children)
          : undefined;
      node = mount(el, parent, index);

      // Finish mounting and remember component/node association
      if (typeof comp.didMount === "function") {
        comp.didMount(el);
      }
      node._COMPONENT = comp;

      return node;
    } else if (["string", "number"].includes(typeof el)) {
      // Text
      node = document.createTextNode(el);
    } else {
      // VDOM Node
      node = document.createElement(el.type);
      for (const key in el.props) {
        const value = el.props[key];
        set(node, key, value);
      }
    }

    const { children } = el;
    if (children != null) {
      if (["string", "number"].includes(typeof children)) {
        // Insert text directly
        node.textContent = children;
      } else {
        if (children.type != null) {
          // Single child
          mount(children, node, 0);
        } else {
          // Insert children
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            mount(child, node, i);
          }
        }
      }
    }
  }

  parent.insertBefore(node, parent.childNodes[index]);
  return node;
};

const unmount = function (comp, node) {
  if (comp) {
    if (typeof comp.willUnmount === "function") {
      comp.willUnmount();
    }
    for (const k in comp) {
      delete comp[k];
    }
  }

  return (() => {
    const result = [];
    for (const child of Array.from(node.childNodes)) {
      unmount(child._COMPONENT, child);
      result.push(delete child._COMPONENT);
    }
    return result;
  })();
};

const prop = function (key) {
  if (typeof document === "undefined") {
    return true;
  }
  if (document.documentElement.style[key] != null) {
    return key;
  }

  key = key[0].toUpperCase() + key.slice(1);
  const prefixes = ["webkit", "moz", "ms", "o"];
  for (const prefix of Array.from(prefixes)) {
    if (document.documentElement.style[prefix + key] != null) {
      return prefix + key;
    }
  }
};

const map = {};
for (const key of ["transform"]) {
  map[key] = prop(key);
}

const set = function (node, key, value, orig) {
  if (key === "style") {
    for (const k in value) {
      const v = value[k];
      if ((orig != null ? orig[k] : undefined) !== v) {
        node.style[map[k] != null ? map[k] : k] = v;
      }
    }
    return;
  }

  if (node[key] != null) {
    try {
      node[key] = value;
    } catch (e1) {
      console.log("failed setting " + key);
    }
    return;
  }

  if (node instanceof Node) {
    node.setAttribute(key, value);
    return;
  }
};

const unset = function (node, key, orig) {
  if (key === "style") {
    for (const k in orig) {
      node.style[map[k] != null ? map[k] : k] = "";
    }
    return;
  }

  if (node[key] != null) {
    node[key] = undefined;
  }

  if (node instanceof Node) {
    node.removeAttribute(key);
    return;
  }
};

/**
 * This needs explicit any -> any typings for ts to emit declarations.
 * Typescript can't handle class declarations inside functions very well.
 *
 * @param {any} prototype
 * @returns {any}
 */
const createClass = function (prototype) {
  let left;
  const aliases = {
    willMount: "componentWillMount",
    didMount: "componentDidMount",
    willReceiveProps: "componentWillReceiveProps",
    shouldUpdate: "shouldComponentUpdate",
    willUpdate: "componentWillUpdate",
    didUpdate: "componentDidUpdate",
    willUnmount: "componentWillUnmount",
  };
  for (const a in aliases) {
    const b = aliases[a];
    if (prototype[a] == null) {
      prototype[a] = prototype[b];
    }
  }

  class Component {
    constructor(node, props, state = null, children = null) {
      let k, v;
      if (props == null) {
        props = {};
      }
      this.props = props;
      this.state = state;
      this.children = children;
      const bind = function (f, self) {
        if (typeof f === "function") {
          return f.bind(self);
        } else {
          return f;
        }
      };
      for (k in prototype) {
        v = prototype[k];
        this[k] = bind(v, this);
      }

      let nextState = null;

      this.setState = function (state) {
        if (nextState == null) {
          nextState = state ? (nextState != null ? nextState : {}) : null;
        }
        for (k in state) {
          v = state[k];
          nextState[k] = v;
        }
        node._COMPONENT_DIRTY = true;
      };

      this.forceUpdate = function () {
        node._COMPONENT_FORCE = node._COMPONENT_DIRTY = true;

        let el = node;
        return (() => {
          const result = [];
          while ((el = el.parentNode)) {
            if (el._COMPONENT) {
              result.push((el._COMPONENT_FORCE = true));
            } else {
              result.push(undefined);
            }
          }
          return result;
        })();
      };

      this.getNextState = () => nextState;

      this.applyNextState = function () {
        node._COMPONENT_FORCE = node._COMPONENT_DIRTY = false;
        const prevState = this.state;
        [nextState, this.state] = Array.from([null, nextState]);
        return prevState;
      };
    }
  }

  Component.isComponentClass = true;
  Component.prototype.defaultProps =
    (left =
      typeof prototype.getDefaultProps === "function"
        ? prototype.getDefaultProps()
        : undefined) != null
      ? left
      : {};
  return Component;
};

function __range__(left, right, inclusive) {
  const range = [];
  const ascending = left < right;
  const end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}

;// CONCATENATED MODULE: ./src/overlay/overlay.js
class Overlay {
  constructor(element, options) {
    this.element = element;
    if (typeof this.init === "function") {
      this.init(options);
    }
  }

  dispose() {}
}

;// CONCATENATED MODULE: ./src/overlay/dom.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class DOM extends Overlay {
  static initClass() {
    this.prototype.el = vdom_element;
    this.prototype.hint = hint;
    this.prototype.apply = apply;
    this.prototype.recycle = recycle;
  }

  init(_options) {
    return (this.last = null);
  }

  dispose() {
    this.unmount();
    return super.dispose();
  }

  mount() {
    const overlay = document.createElement("div");
    overlay.classList.add("mathbox-overlay");
    this.element.appendChild(overlay);
    return (this.overlay = overlay);
  }

  unmount(_overlay) {
    if (this.overlay && this.overlay.parentNode) {
      this.element.removeChild(this.overlay);
    }
    return (this.overlay = null);
  }

  render(el) {
    // Lazy mounting
    if (!this.overlay) {
      this.mount();
    }

    // Wrap naked string or array in a div
    if (["string", "number"].includes(typeof el)) {
      el = this.el("div", null, el);
    }
    if (el instanceof Array) {
      el = this.el("div", null, el);
    }

    // Create empty div if el is null
    if (el == null) {
      el = this.el("div");
    }

    // See if it can be mounted directly
    const naked = el.type === "div";

    // Fetch last DOM state
    let { last } = this;

    // Start with root node
    const { overlay } = this;
    const node = naked ? overlay : overlay.childNodes[0];
    const parent = naked ? overlay.parentNode : overlay;

    // Create phantom DOM state if mounting into existing element
    if (!last && node) {
      last = this.el("div");
    }

    // Update DOM
    this.apply(el, last, node, parent, 0);
    this.last = el;

    // Recycle old descriptors
    if (last != null) {
      this.recycle(last);
    }
  }
}
DOM.initClass();

;// CONCATENATED MODULE: ./src/overlay/classes.js


const Classes = { dom: DOM };

;// CONCATENATED MODULE: ./src/overlay/index.js




;// CONCATENATED MODULE: ./src/primitives/primitive.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Primitive {
  static initClass() {
    this.Node = node_Node;
    this.Group = Group;

    // Class default
    this.model = this.Node;
    this.defaults = null;
    this.traits = null;
    this.props = null;
    this.finals = null;
    this.freeform = false;
  }

  constructor(node, _context, helpers) {
    this.node = node;
    this._context = _context;
    this._renderables = this._context.renderables;
    this._attributes = this._context.attributes;
    this._shaders = this._context.shaders;
    this._overlays = this._context.overlays;
    this._animator = this._context.animator;
    this._types = this._attributes.types;

    // Link up node 1-to-1
    this.node.controller = this;

    // This node has been inserted/removed
    this.node.on("added", (_event) => this._added());
    this.node.on("removed", (_event) => this._removed());

    // Property change (if mounted)
    this.node.on("change", (event) => {
      if (this._root) {
        return this.change(event.changed, event.touched);
      }
    });

    // Store local refs
    this.reconfigure();

    // Attribute getter / helpers
    this._get = this.node.get.bind(this.node);
    this._helpers = helpers(this, this.node.traits);

    // Keep track of various handlers to do auto-cleanup on unmake()
    this._handlers = { inherit: {}, listen: [], watch: [], compute: [] };

    // Detached initially
    this._root = this._parent = null;

    // Friendly constructor
    this.init();
  }

  is(trait) {
    return this.traits.hash[trait];
  }

  // Primitive lifecycle
  init() {}
  make() {}
  made() {}
  unmake(_rebuild) {}
  unmade() {}
  change(_changed, _touched, _init) {}

  // Force property reinit
  refresh() {
    return this.change({}, {}, true);
  }

  // Destroy and create cycle
  rebuild() {
    if (this._root) {
      this._removed(true);
      return this._added();
    }
  }

  // Reconfigure traits/props
  reconfigure(config) {
    if (config != null) {
      this.node.configure(config, this._attributes);
    }

    this.traits = this.node.traits;
    return (this.props = this.node.props);
  }

  // This node has been inserted
  _added() {
    let e, left;
    this._parent =
      this.node.parent != null ? this.node.parent.controller : undefined;
    this._root = this.node.root != null ? this.node.root.controller : undefined;

    this.node.clock =
      (left = this._inherit("clock")) != null ? left : this._root;

    try {
      try {
        this.make();
        this.refresh();
        return this.made();
      } catch (error) {
        e = error;
        this.node.print("warn");
        console.error(e);
        throw e;
      }
    } catch (error1) {
      e = error1;
      try {
        return this._removed();
        // eslint-disable-next-line no-empty
      } catch (error2) {}
    }
  }

  _removed(rebuild) {
    if (rebuild == null) {
      rebuild = false;
    }
    this.unmake(rebuild);

    this._unlisten();
    this._unattach();
    this._uncompute();

    this._root = null;
    this._parent = null;

    return this.unmade(rebuild);
  }

  // Bind event listeners to methods
  _listen(object, type, method, self) {
    if (self == null) {
      self = this;
    }
    if (object instanceof Array) {
      for (const o of Array.from(object)) {
        return this.__listen(o, type, method, self);
      }
    }
    return this.__listen(object, type, method, self);
  }

  __listen(object, type, method, self) {
    if (self == null) {
      self = this;
    }
    if (typeof object === "string") {
      object = this._inherit(object);
    }

    if (object != null) {
      const handler = method.bind(self);
      handler.node = this.node;
      object.on(type, handler);

      this._handlers.listen.push([object, type, handler]);
    }
    return object;
  }

  _unlisten() {
    if (!this._handlers.listen.length) {
      return;
    }

    for (const [object, type, handler] of Array.from(this._handlers.listen)) {
      object.off(type, handler);
    }
    return (this._handlers.listen = []);
  }

  // Find parent with certain trait
  _inherit(trait) {
    const cached = this._handlers.inherit[trait];
    if (cached !== undefined) {
      return cached;
    }

    return (this._handlers.inherit[trait] =
      this._parent != null
        ? this._parent._find(trait != null ? trait : null)
        : undefined);
  }

  _find(trait) {
    if (this.is(trait)) {
      return this;
    }
    return this._parent != null ? this._parent._find(trait) : undefined;
  }

  _uninherit() {
    return (this._handlers.inherit = {});
  }

  // Attach to controller by trait and watch the selector
  _attach(selector, trait, method, self, start, optional, multiple) {
    if (self == null) {
      self = this;
    }
    if (start == null) {
      start = this;
    }
    if (optional == null) {
      optional = false;
    }
    if (multiple == null) {
      multiple = false;
    }
    const filter = function (node) {
      if (node != null && Array.from(node.traits).includes(trait)) {
        return node;
      }
    };
    const map = (node) => (node != null ? node.controller : undefined);
    const flatten = function (list) {
      if (list == null) {
        return list;
      }
      let out = [];
      for (const sub of Array.from(list)) {
        if (sub instanceof Array) {
          out = out.concat(sub);
        } else {
          out.push(sub);
        }
      }
      return out;
    };

    const resolve = (selector) => {
      // Direct JS binding, no watcher.
      let node, nodes;
      if (typeof selector === "object") {
        node = selector;

        // API object
        if (node != null ? node._up : undefined) {
          selector = multiple ? node._targets : [node[0]];
          return selector;
        }

        // Array of things
        if (node instanceof Array) {
          selector = multiple ? flatten(node.map(resolve)) : resolve(node[0]);
          return selector;
        }

        // Node
        if (node instanceof node_Node) {
          return [node];
        }

        // Auto-link selector '<'
      } else if (typeof selector === "string" && selector[0] === "<") {
        let match;
        let discard = 0;
        if ((match = selector.match(/^<([0-9])+$/))) {
          discard = +match[1] - 1;
        }
        if (selector.match(/^<+$/)) {
          discard = +selector.length - 1;
        }

        nodes = [];

        // Implicitly associated node (scan backwards until we find one)
        let previous = start.node;
        while (previous) {
          // Find previous node
          const { parent } = previous;
          if (!parent) {
            break;
          }
          previous = parent.children[previous.index - 1];

          // If we reached the first child, ascend if nothing found yet
          if (!previous && !nodes.length) {
            previous = parent;
          }

          // Include if matched
          node = null;
          if (filter(previous)) {
            node = previous;
          }
          if (node != null && discard-- <= 0) {
            nodes.push(node);
          }

          // Return solo match
          if (!multiple && nodes.length) {
            return nodes;
          }
        }

        // Return list match
        if (multiple && nodes.length) {
          return nodes;
        }

        // Selector binding
      } else if (typeof selector === "string") {
        const watcher = method.bind(self);
        this._handlers.watch.push(watcher);

        const selection = this._root.watch(selector, watcher);
        if (!multiple) {
          if (filter(selection[0])) {
            node = selection[0];
          }
          if (node != null) {
            return [node];
          }
        } else {
          nodes = selection.filter(filter);
          if (nodes.length) {
            return nodes;
          }
        }
      }

      // Nothing found
      if (!optional) {
        console.warn(this.node.toMarkup());
        throw new Error(
          `${this.node.toString()} - Could not find ${trait} \`${selector}\``
        );
      }
      if (multiple) {
        return [];
      } else {
        return null;
      }
    };

    // Resolve selection recursively
    const nodes = flatten(resolve(selector));

    // Return node's controllers if found
    if (multiple) {
      if (nodes != null) {
        return nodes.map(map);
      } else {
        return null;
      }
    } else {
      if (nodes != null) {
        return map(nodes[0]);
      } else {
        return null;
      }
    }
  }

  // Remove watcher attachments
  _unattach() {
    if (!this._handlers.watch.length) {
      return;
    }

    for (const watcher of Array.from(this._handlers.watch)) {
      if (watcher != null) {
        watcher.unwatch();
      }
    }
    return (this._handlers.watch = []);
  }

  // Bind a computed value to a prop
  _compute(key, expr) {
    this._handlers.compute.push(key);
    return this.node.bind(key, expr, true);
  }

  // Remove prop bindings
  _uncompute() {
    if (!this._handlers.compute.length) {
      return;
    }
    for (const key of Array.from(this._handlers.compute)) {
      this.node.unbind(key, true);
    }
    return (this._handlers.compute = []);
  }
}
Primitive.initClass();

Binder.apply(Primitive.prototype);

;// CONCATENATED MODULE: ./src/primitives/types/base/parent.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Parent extends Primitive {
  static initClass() {
    this.model = Primitive.Group;
    this.traits = ["node"];
  }
}
Parent.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/base/group.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class group_Group extends Parent {
  static initClass() {
    this.traits = ["node", "object", "entity", "visible", "active"];
  }

  make() {
    this._helpers.visible.make();
    return this._helpers.active.make();
  }

  unmake() {
    this._helpers.visible.unmake();
    return this._helpers.active.unmake();
  }
}
group_Group.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/base/inherit.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Inherit extends Parent {
  static initClass() {
    this.traits = ["node", "bind"];
  }

  make() {
    // Bind to attached trait source
    return this._helpers.bind.make([{ to: "inherit.source", trait: "node" }]);
  }

  unmake() {
    return this._helpers.bind.unmake();
  }

  _find(trait) {
    if (this.bind.source && Array.from(this.props.traits).includes(trait)) {
      return this.bind.source._inherit(trait);
    }
    return super._find();
  }
}
Inherit.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/base/root.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Root extends Parent {
  static initClass() {
    this.traits = ["node", "root", "clock", "scene", "vertex", "unit"];
  }

  init() {
    this.size = null;

    this.cameraEvent = { type: "root.camera" };
    this.preEvent = { type: "root.pre" };
    this.updateEvent = { type: "root.update" };
    this.renderEvent = { type: "root.render" };
    this.postEvent = { type: "root.post" };

    this.clockEvent = { type: "clock.tick" };

    return (this.camera = null);
  }

  make() {
    return this._helpers.unit.make();
  }
  unmake() {
    return this._helpers.unit.unmake();
  }

  change(changed, touched, init) {
    if (changed["root.camera"] || init) {
      this._unattach();
      this._attach(
        this.props.camera,
        "camera",
        this.setCamera,
        this,
        this,
        true
      );
      return this.setCamera();
    }
  }

  adopt(renderable) {
    return Array.from(renderable.renders).map((object) =>
      this._context.scene.add(object)
    );
  }
  unadopt(renderable) {
    return Array.from(renderable.renders).map((object) =>
      this._context.scene.remove(object)
    );
  }

  select(selector) {
    return this.node.model.select(selector);
  }

  watch(selector, handler) {
    return this.node.model.watch(selector, handler);
  }

  unwatch(handler) {
    return this.node.model.unwatch(handler);
  }

  resize(size) {
    this.size = size;
    return this.trigger({
      type: "root.resize",
      size,
    });
  }

  getSize() {
    return this.size;
  }
  getSpeed() {
    return this.props.speed;
  }

  getUnit() {
    return this._helpers.unit.get();
  }
  getUnitUniforms() {
    return this._helpers.unit.uniforms();
  }

  pre() {
    this.getCamera().updateProjectionMatrix();
    this.trigger(this.clockEvent);
    return this.trigger(this.preEvent);
  }

  update() {
    return this.trigger(this.updateEvent);
  }
  render() {
    return this.trigger(this.renderEvent);
  }
  post() {
    return this.trigger(this.postEvent);
  }

  setCamera() {
    const camera = root_guard_(
      this.select(this.props.camera)[0],
      (x) => x.controller
    );
    if (this.camera !== camera) {
      this.camera = camera;
      return this.trigger({ type: "root.camera" });
    }
  }

  getCamera() {
    let left;
    return (left = this.camera != null ? this.camera.getCamera() : undefined) !=
      null
      ? left
      : this._context.defaultCamera;
  }

  getTime() {
    return this._context.time;
  }

  // End transform chain here
  vertex(shader, pass) {
    if (pass === 2) {
      return shader.pipe("view.position");
    }
    if (pass === 3) {
      return shader.pipe("root.position");
    }
    return shader;
  }
}
Root.initClass();

function root_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/primitives/types/base/unit.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Unit extends Parent {
  static initClass() {
    this.traits = ["node", "unit"];
  }

  make() {
    return this._helpers.unit.make();
  }
  unmake() {
    return this._helpers.unit.unmake();
  }

  getUnit() {
    return this._helpers.unit.get();
  }
  getUnitUniforms() {
    return this._helpers.unit.uniforms();
  }
}
Unit.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/base/index.js





;// CONCATENATED MODULE: ./src/util/three.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



const paramToGL = function (gl, p) {
  if (p === external_THREE_.RepeatWrapping) {
    return gl.REPEAT;
  }
  if (p === external_THREE_.ClampToEdgeWrapping) {
    return gl.CLAMP_TO_EDGE;
  }
  if (p === external_THREE_.MirroredRepeatWrapping) {
    return gl.MIRRORED_REPEAT;
  }

  if (p === external_THREE_.NearestFilter) {
    return gl.NEAREST;
  }
  if (p === external_THREE_.NearestMipMapNearestFilter) {
    return gl.NEAREST_MIPMAP_NEAREST;
  }
  if (p === external_THREE_.NearestMipMapLinearFilter) {
    return gl.NEAREST_MIPMAP_LINEAR;
  }

  if (p === external_THREE_.LinearFilter) {
    return gl.LINEAR;
  }
  if (p === external_THREE_.LinearMipMapNearestFilter) {
    return gl.LINEAR_MIPMAP_NEAREST;
  }
  if (p === external_THREE_.LinearMipMapLinearFilter) {
    return gl.LINEAR_MIPMAP_LINEAR;
  }

  if (p === external_THREE_.UnsignedByteType) {
    return gl.UNSIGNED_BYTE;
  }
  if (p === external_THREE_.UnsignedShort4444Type) {
    return gl.UNSIGNED_SHORT_4_4_4_4;
  }
  if (p === external_THREE_.UnsignedShort5551Type) {
    return gl.UNSIGNED_SHORT_5_5_5_1;
  }
  if (p === external_THREE_.ByteType) {
    return gl.BYTE;
  }
  if (p === external_THREE_.ShortType) {
    return gl.SHORT;
  }
  if (p === external_THREE_.UnsignedShortType) {
    return gl.UNSIGNED_SHORT;
  }
  if (p === external_THREE_.IntType) {
    return gl.INT;
  }
  if (p === external_THREE_.UnsignedIntType) {
    return gl.UNSIGNED_INT;
  }
  if (p === external_THREE_.FloatType) {
    return gl.FLOAT;
  }

  if (p === external_THREE_.AlphaFormat) {
    return gl.ALPHA;
  }
  if (p === external_THREE_.RGBAFormat) {
    return gl.RGBA;
  }
  if (p === external_THREE_.LuminanceFormat) {
    return gl.LUMINANCE;
  }
  if (p === external_THREE_.LuminanceAlphaFormat) {
    return gl.LUMINANCE_ALPHA;
  }

  if (p === external_THREE_.AddEquation) {
    return gl.FUNC_ADD;
  }
  if (p === external_THREE_.SubtractEquation) {
    return gl.FUNC_SUBTRACT;
  }
  if (p === external_THREE_.ReverseSubtractEquation) {
    return gl.FUNC_REVERSE_SUBTRACT;
  }

  if (p === external_THREE_.ZeroFactor) {
    return gl.ZERO;
  }
  if (p === external_THREE_.OneFactor) {
    return gl.ONE;
  }
  if (p === external_THREE_.SrcColorFactor) {
    return gl.SRC_COLOR;
  }
  if (p === external_THREE_.OneMinusSrcColorFactor) {
    return gl.ONE_MINUS_SRC_COLOR;
  }
  if (p === external_THREE_.SrcAlphaFactor) {
    return gl.SRC_ALPHA;
  }
  if (p === external_THREE_.OneMinusSrcAlphaFactor) {
    return gl.ONE_MINUS_SRC_ALPHA;
  }
  if (p === external_THREE_.DstAlphaFactor) {
    return gl.DST_ALPHA;
  }
  if (p === external_THREE_.OneMinusDstAlphaFactor) {
    return gl.ONE_MINUS_DST_ALPHA;
  }

  if (p === external_THREE_.DstColorFactor) {
    return gl.DST_COLOR;
  }
  if (p === external_THREE_.OneMinusDstColorFactor) {
    return gl.ONE_MINUS_DST_COLOR;
  }
  if (p === external_THREE_.SrcAlphaSaturateFactor) {
    return gl.SRC_ALPHA_SATURATE;
  }

  return 0;
};

const paramToArrayStorage = function (type) {
  switch (type) {
    case external_THREE_.UnsignedByteType:
      return Uint8Array;
    case external_THREE_.ByteType:
      return Int8Array;
    case external_THREE_.ShortType:
      return Int16Array;
    case external_THREE_.UnsignedShortType:
      return Uint16Array;
    case external_THREE_.IntType:
      return Int32Array;
    case external_THREE_.UnsignedIntType:
      return Uint32Array;
    case external_THREE_.FloatType:
      return Float32Array;
  }
};

const swizzleToEulerOrder = (swizzle) =>
  swizzle.map((i) => ["", "X", "Y", "Z"][i]).join("");

const transformComposer = function () {
  const euler = new external_THREE_.Euler();
  const quat = new external_THREE_.Quaternion();
  const pos = new external_THREE_.Vector3();
  const scl = new external_THREE_.Vector3();
  const transform = new external_THREE_.Matrix4();

  return function (position, rotation, quaternion, scale, matrix, eulerOrder) {
    if (eulerOrder == null) {
      eulerOrder = "XYZ";
    }
    if (rotation != null) {
      if (eulerOrder instanceof Array) {
        eulerOrder = swizzleToEulerOrder(eulerOrder);
      }
      euler.setFromVector3(rotation, eulerOrder);
      quat.setFromEuler(euler);
    } else {
      quat.set(0, 0, 0, 1);
    }

    if (quaternion != null) {
      quat.multiply(quaternion);
    }

    if (position != null) {
      pos.copy(position);
    } else {
      pos.set(0, 0, 0);
    }

    if (scale != null) {
      scl.copy(scale);
    } else {
      scl.set(1, 1, 1);
    }

    transform.compose(pos, quat, scl);
    if (matrix != null) {
      transform.multiplyMatrices(transform, matrix);
    }

    return transform;
  };
};

;// CONCATENATED MODULE: ./src/primitives/types/camera/camera.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Camera extends Primitive {
  static initClass() {
    this.traits = ["node", "camera"];
  }

  init() {}

  make() {
    const camera = this._context.defaultCamera;
    this.camera = this.props.proxy ? camera : camera.clone();

    this.euler = new external_THREE_.Euler();
    return (this.quat = new external_THREE_.Quaternion());
  }

  unmake() {}

  getCamera() {
    return this.camera;
  }

  change(changed, touched, init) {
    if (
      changed["camera.position"] ||
      changed["camera.quaternion"] ||
      changed["camera.rotation"] ||
      changed["camera.lookAt"] ||
      changed["camera.up"] ||
      changed["camera.fov"] ||
      init
    ) {
      const { position, quaternion, rotation, lookAt, up, fov } = this.props;

      // Apply transform conservatively to avoid conflicts with controls / proxy
      if (position != null) {
        this.camera.position.copy(position);
      }

      if (quaternion != null || rotation != null || lookAt != null) {
        if (lookAt != null) {
          this.camera.lookAt(lookAt);
        } else {
          this.camera.quaternion.set(0, 0, 0, 1);
        }

        if (rotation != null) {
          this.euler.setFromVector3(
            rotation,
            swizzleToEulerOrder(this.props.eulerOrder)
          );
          this.quat.setFromEuler(this.euler);
          this.camera.quaternion.multiply(this.quat);
        }

        if (quaternion != null) {
          this.camera.quaternion.multiply(quaternion);
        }
      }

      if (fov != null && this.camera.fov != null) {
        this.camera.fov = fov;
      }

      if (up != null) {
        this.camera.up.copy(up);
      }

      return this.camera.updateMatrix();
    }
  }
}
Camera.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/camera/index.js


;// CONCATENATED MODULE: ./src/util/data.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS202: Simplify dynamic range loops
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */

const getSizes = function (data) {
  const sizes = [];
  let array = data;
  while (
    typeof array !== "string" &&
    (array != null ? array.length : undefined) != null
  ) {
    sizes.push(array.length);
    array = array[0];
  }
  return sizes;
};

const getDimensions = function (data, spec) {
  let left;
  if (spec == null) {
    spec = {};
  }
  const { items, channels, width, height, depth } = spec;

  const dims = {};

  if (!data || !data.length) {
    return {
      items,
      channels,
      width: width != null ? width : 0,
      height: height != null ? height : 0,
      depth: depth != null ? depth : 0,
    };
  }

  const sizes = getSizes(data);
  const nesting = sizes.length;

  dims.channels = channels !== 1 && sizes.length > 1 ? sizes.pop() : channels;
  dims.items = items !== 1 && sizes.length > 1 ? sizes.pop() : items;
  dims.width = width !== 1 && sizes.length > 1 ? sizes.pop() : width;
  dims.height = height !== 1 && sizes.length > 1 ? sizes.pop() : height;
  dims.depth = depth !== 1 && sizes.length > 1 ? sizes.pop() : depth;

  let levels = nesting;
  if (channels === 1) {
    levels++;
  }
  if (items === 1 && levels > 1) {
    levels++;
  }
  if (width === 1 && levels > 2) {
    levels++;
  }
  if (height === 1 && levels > 3) {
    levels++;
  }

  let n = (left = sizes.pop()) != null ? left : 1;
  if (levels <= 1) {
    n /= dims.channels != null ? dims.channels : 1;
  }
  if (levels <= 2) {
    n /= dims.items != null ? dims.items : 1;
  }
  if (levels <= 3) {
    n /= dims.width != null ? dims.width : 1;
  }
  if (levels <= 4) {
    n /= dims.height != null ? dims.height : 1;
  }
  n = Math.floor(n);

  if (dims.width == null) {
    dims.width = n;
    n = 1;
  }
  if (dims.height == null) {
    dims.height = n;
    n = 1;
  }
  if (dims.depth == null) {
    dims.depth = n;
    n = 1;
  }

  return dims;
};

const repeatCall = function (call, times) {
  switch (times) {
    case 0:
      return () => true;
    case 1:
      return () => call();
    case 2:
      return function () {
        call();
        return call();
      };
    case 3:
      return function () {
        call();
        call();
        call();
        return call();
      };
    case 4:
      return function () {
        call();
        call();
        call();
        return call();
      };
    case 6:
      return function () {
        call();
        call();
        call();
        call();
        call();
        return call();
      };
    case 8:
      return function () {
        call();
        call();
        call();
        call();
        call();
        return call();
      };
  }
};

const makeEmitter = function (thunk, items, channels) {
  let outer;
  const inner = (() => {
    switch (channels) {
      case 0:
        return () => true;
      case 1:
        return (emit) => emit(thunk());
      case 2:
        return (emit) => emit(thunk(), thunk());
      case 3:
        return (emit) => emit(thunk(), thunk(), thunk());
      case 4:
        return (emit) => emit(thunk(), thunk(), thunk(), thunk());
      case 6:
        return (emit) =>
          emit(thunk(), thunk(), thunk(), thunk(), thunk(), thunk());
      case 8:
        return (emit) =>
          emit(
            thunk(),
            thunk(),
            thunk(),
            thunk(),
            thunk(),
            thunk(),
            thunk(),
            thunk()
          );
    }
  })();

  let next = null;
  while (items > 0) {
    const n = Math.min(items, 8);
    outer = (() => {
      switch (n) {
        case 1:
          return (emit) => inner(emit);
        case 2:
          return function (emit) {
            inner(emit);
            return inner(emit);
          };
        case 3:
          return function (emit) {
            inner(emit);
            inner(emit);
            return inner(emit);
          };
        case 4:
          return function (emit) {
            inner(emit);
            inner(emit);
            inner(emit);
            return inner(emit);
          };
        case 5:
          return function (emit) {
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            return inner(emit);
          };
        case 6:
          return function (emit) {
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            return inner(emit);
          };
        case 7:
          return function (emit) {
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            return inner(emit);
          };
        case 8:
          return function (emit) {
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            inner(emit);
            return inner(emit);
          };
      }
    })();
    if (next != null) {
      next = ((outer, next) =>
        function (emit) {
          outer(emit);
          return next(emit);
        })(outer, next);
    } else {
      next = outer;
    }
    items -= n;
  }

  outer = next != null ? next : () => true;
  outer.reset = thunk.reset;
  outer.rebind = thunk.rebind;
  return outer;
};

const getThunk = function (data) {
  let thunk;
  let j, k, l, m;
  let sizes = getSizes(data);
  const nesting = sizes.length;

  let a = sizes.pop();
  let b = sizes.pop();
  let c = sizes.pop();
  const d = sizes.pop();

  let i, first, second, third, fourth;

  switch (nesting) {
    case 0:
      thunk = () => 0;
      thunk.reset = function () {};
      break;

    case 1:
      i = 0;
      thunk = () => data[i++];
      thunk.reset = () => (i = 0);
      break;

    case 2:
      i = j = 0;
      first = data[j] != null ? data[j] : [];

      thunk = function () {
        const x = first[i++];
        if (i === a) {
          i = 0;
          j++;
          first = data[j] != null ? data[j] : [];
        }
        return x;
      };

      thunk.reset = function () {
        i = j = 0;
        first = data[j] != null ? data[j] : [];
      };
      break;

    case 3:
      i = j = k = 0;
      second = data[k] != null ? data[k] : [];
      first = second[j] != null ? second[j] : [];

      thunk = function () {
        const x = first[i++];
        if (i === a) {
          i = 0;
          j++;
          if (j === b) {
            j = 0;
            k++;
            second = data[k] != null ? data[k] : [];
          }
          first = second[j] != null ? second[j] : [];
        }
        return x;
      };

      thunk.reset = function () {
        i = j = k = 0;
        second = data[k] != null ? data[k] : [];
        first = second[j] != null ? second[j] : [];
      };
      break;

    case 4:
      i = j = k = l = 0;
      third = data[l] != null ? data[l] : [];
      second = third[k] != null ? third[k] : [];
      first = second[j] != null ? second[j] : [];

      thunk = function () {
        const x = first[i++];
        if (i === a) {
          i = 0;
          j++;
          if (j === b) {
            j = 0;
            k++;
            if (k === c) {
              k = 0;
              l++;
              third = data[l] != null ? data[l] : [];
            }
            second = third[k] != null ? third[k] : [];
          }
          first = second[j] != null ? second[j] : [];
        }
        return x;
      };

      thunk.reset = function () {
        i = j = k = l = 0;
        third = data[l] != null ? data[l] : [];
        second = third[k] != null ? third[k] : [];
        first = second[j] != null ? second[j] : [];
      };
      break;

    case 5:
      i = j = k = l = m = 0;
      fourth = data[m] != null ? data[m] : [];
      third = fourth[l] != null ? fourth[l] : [];
      second = third[k] != null ? third[k] : [];
      first = second[j] != null ? second[j] : [];

      thunk = function () {
        const x = first[i++];
        if (i === a) {
          i = 0;
          j++;
          if (j === b) {
            j = 0;
            k++;
            if (k === c) {
              k = 0;
              l++;
              if (l === d) {
                l = 0;
                m++;
                fourth = data[m] != null ? data[m] : [];
              }
              third = fourth[l] != null ? fourth[l] : [];
            }
            second = third[k] != null ? third[k] : [];
          }
          first = second[j] != null ? second[j] : [];
        }
        return x;
      };

      thunk.reset = function () {
        i = j = k = l = m = 0;
        fourth = data[m] != null ? data[m] : [];
        third = fourth[l] != null ? fourth[l] : [];
        second = third[k] != null ? third[k] : [];
        first = second[j] != null ? second[j] : [];
      };
      break;
  }

  thunk.rebind = function (d) {
    data = d;

    sizes = getSizes(data);
    if (sizes.length) {
      a = sizes.pop();
    }
    if (sizes.length) {
      b = sizes.pop();
    }
    if (sizes.length) {
      c = sizes.pop();
    }
    if (sizes.length) {
      return (d = sizes.pop());
    }
  };

  return thunk;
};

const getStreamer = function (array, samples, channels, items) {
  let i, j;
  let limit = (i = j = 0);

  const reset = function () {
    limit = samples * channels * items;
    return (i = j = 0);
  };

  const count = () => j;
  const done = () => limit - i <= 0;

  const skip = (() => {
    switch (channels) {
      case 1:
        return function (n) {
          i += n;
          j += n;
        };

      case 2:
        return function (n) {
          i += n * 2;
          j += n;
        };

      case 3:
        return function (n) {
          i += n * 3;
          j += n;
        };

      case 4:
        return function (n) {
          i += n * 4;
          j += n;
        };
    }
  })();

  const consume = (() => {
    switch (channels) {
      case 1:
        return function (emit) {
          emit(array[i++]);
          ++j;
        };

      case 2:
        return function (emit) {
          emit(array[i++], array[i++]);
          ++j;
        };

      case 3:
        return function (emit) {
          emit(array[i++], array[i++], array[i++]);
          ++j;
        };

      case 4:
        return function (emit) {
          emit(array[i++], array[i++], array[i++], array[i++]);
          ++j;
        };
    }
  })();

  const emit = (() => {
    switch (channels) {
      case 1:
        return function (x) {
          array[i++] = x;
          ++j;
        };

      case 2:
        return function (x, y) {
          array[i++] = x;
          array[i++] = y;
          ++j;
        };

      case 3:
        return function (x, y, z) {
          array[i++] = x;
          array[i++] = y;
          array[i++] = z;
          ++j;
        };

      case 4:
        return function (x, y, z, w) {
          array[i++] = x;
          array[i++] = y;
          array[i++] = z;
          array[i++] = w;
          ++j;
        };
    }
  })();

  consume.reset = reset;
  emit.reset = reset;

  reset();
  return { emit, consume, skip, count, done, reset };
};

const getLerpEmitter = function (expr1, expr2) {
  let emitter, lerp2, q, r, s;
  const scratch = new Float32Array(4096);
  let lerp1 = (lerp2 = 0.5);
  let p = (q = r = s = 0);

  const emit1 = function (x, y, z, w) {
    r++;
    scratch[p++] = x * lerp1;
    scratch[p++] = y * lerp1;
    scratch[p++] = z * lerp1;
    return (scratch[p++] = w * lerp1);
  };

  const emit2 = function (x, y, z, w) {
    s++;
    scratch[q++] += x * lerp2;
    scratch[q++] += y * lerp2;
    scratch[q++] += z * lerp2;
    return (scratch[q++] += w * lerp2);
  };

  const args = Math.max(expr1.length, expr2.length);

  if (args <= 3) {
    emitter = function (emit, x, i) {
      p = q = r = s = 0;
      expr1(emit1, x, i);
      expr2(emit2, x, i);
      const n = Math.min(r, s);
      let l = 0;
      return data_range_(0, n, false).map((_k) =>
        emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++])
      );
    };
  } else if (args <= 5) {
    emitter = function (emit, x, y, i, j) {
      p = q = r = s = 0;
      expr1(emit1, x, y, i, j);
      expr2(emit2, x, y, i, j);
      const n = Math.min(r, s);
      let l = 0;
      return data_range_(0, n, false).map((_k) =>
        emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++])
      );
    };
  } else if (args <= 7) {
    emitter = function (emit, x, y, z, i, j, k) {
      p = q = r = s = 0;
      expr1(emit1, x, y, z, i, j, k);
      expr2(emit2, x, y, z, i, j, k);
      const n = Math.min(r, s);
      let l = 0;
      return (() => {
        let asc, end;
        const result = [];
        for (
          k = 0, end = n, asc = 0 <= end;
          asc ? k < end : k > end;
          asc ? k++ : k--
        ) {
          result.push(
            emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++])
          );
        }
        return result;
      })();
    };
  } else if (args <= 9) {
    emitter = function (emit, x, y, z, w, i, j, k, l) {
      p = q = r = s = 0;
      expr1(emit1, x, y, z, w, i, j, k, l);
      expr2(emit2, x, y, z, w, i, j, k, l);
      const n = Math.min(r, s);
      l = 0;
      return (() => {
        let asc, end;
        const result = [];
        for (
          k = 0, end = n, asc = 0 <= end;
          asc ? k < end : k > end;
          asc ? k++ : k--
        ) {
          result.push(
            emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++])
          );
        }
        return result;
      })();
    };
  } else {
    emitter = function (emit, x, y, z, w, i, j, k, l, d, t) {
      p = q = 0;
      expr1(emit1, x, y, z, w, i, j, k, l, d, t);
      expr2(emit2, x, y, z, w, i, j, k, l, d, t);
      const n = Math.min(r, s);
      l = 0;
      return (() => {
        let asc, end;
        const result = [];
        for (
          k = 0, end = n, asc = 0 <= end;
          asc ? k < end : k > end;
          asc ? k++ : k--
        ) {
          result.push(
            emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++])
          );
        }
        return result;
      })();
    };
  }

  emitter.lerp = function (f) {
    let ref;
    return ([lerp1, lerp2] = Array.from((ref = [1 - f, f]))), ref;
  };

  return emitter;
};

const getLerpThunk = function (data1, data2) {
  // Get sizes
  const n1 = getSizes(data1).reduce((a, b) => a * b);
  const n2 = getSizes(data2).reduce((a, b) => a * b);
  const n = Math.min(n1, n2);

  // Create data thunks to copy (multi-)array
  const thunk1 = getThunk(data1);
  const thunk2 = getThunk(data2);

  // Create scratch array
  const scratch = new Float32Array(n);

  scratch.lerp = function (f) {
    thunk1.reset();
    thunk2.reset();

    let i = 0;
    return (() => {
      const result = [];
      while (i < n) {
        const a = thunk1();
        const b = thunk2();
        result.push((scratch[i++] = a + (b - a) * f));
      }
      return result;
    })();
  };

  return scratch;
};

function data_range_(left, right, inclusive) {
  const range = [];
  const ascending = left < right;
  const end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}

;// CONCATENATED MODULE: ./src/util/glsl.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
const letters = "xyzw".split("");

const index = {
  0: -1,
  x: 0,
  y: 1,
  z: 2,
  w: 3,
};

const parseOrder = function (order) {
  if (order === "" + order) {
    order = order.split("");
  }
  if (order === +order) {
    order = [order];
  }
  return order;
};

const toType = function (type) {
  if (type === +type) {
    type = "vec" + type;
  }
  if (type === "vec1") {
    type = "float";
  }
  return type;
};

const toFloatString = function (value) {
  value = "" + value;
  if (value.indexOf(".") < 0) {
    return (value += ".0");
  }
};

// Helper for float to byte conversion on the w axis, for readback
const mapByte2FloatOffset = function (stretch) {
  if (stretch == null) {
    stretch = 4;
  }
  const factor = toFloatString(stretch);
  return `\
vec4 float2ByteIndex(vec4 xyzw, out float channelIndex) {
  float relative = xyzw.w / ${factor};
  float w = floor(relative);
  channelIndex = (relative - w) * ${factor};
  return vec4(xyzw.xyz, w);
}\
`;
};

// Sample data texture array
const glsl_sample2DArray = function (textures) {
  const divide = function (a, b) {
    let out;
    if (a === b) {
      out = `\
return texture2D(dataTextures[${a}], uv);\
`;
    } else {
      const mid = Math.ceil(a + (b - a) / 2);
      out = `\
if (z < ${mid - 0.5}) {
  ${divide(a, mid - 1)}
}
else {
  ${divide(mid, b)}
}\
`;
    }
    return (out = out.replace(/\n/g, "\n  "));
  };

  const body = divide(0, textures - 1);

  return `\
uniform sampler2D dataTextures[${textures}];

vec4 sample2DArray(vec2 uv, float z) {
  ${body}
}\
`;
};

// Binary operator
const binaryOperator = function (type, op, curry) {
  type = toType(type);
  if (curry != null) {
    return `\
${type} binaryOperator(${type} a) {
  return a ${op} ${curry};
}\
`;
  } else {
    return `\
${type} binaryOperator(${type} a, ${type} b) {
  return a ${op} b;
}\
`;
  }
};

// Extend to n-vector with zeroes
const extendVec = function (from, to, value) {
  if (value == null) {
    value = 0;
  }
  if (from > to) {
    return truncateVec(from, to);
  }

  const diff = to - from;

  from = toType(from);
  to = toType(to);

  value = toFloatString(value);

  const parts = glsl_range_(0, diff, true).map(function (x) {
    if (x) {
      return value;
    } else {
      return "v";
    }
  });
  const ctor = parts.join(",");

  return `\
${to} extendVec(${from} v) { return ${to}(${ctor}); }\
`;
};

// Truncate n-vector
const truncateVec = function (from, to) {
  if (from < to) {
    return extendVec(from, to);
  }

  const swizzle = "." + "xyzw".substr(0, to);

  from = toType(from);
  to = toType(to);

  return `\
${to} truncateVec(${from} v) { return v${swizzle}; }\
`;
};

// Inject float into 4-component vector
const injectVec4 = function (order) {
  const swizzler = ["0.0", "0.0", "0.0", "0.0"];

  order = parseOrder(order);
  order = order.map(function (v) {
    if (v === "" + v) {
      return index[v];
    } else {
      return v;
    }
  });

  for (let i = 0; i < order.length; i++) {
    const channel = order[i];
    swizzler[channel] = ["a", "b", "c", "d"][i];
  }

  const mask = swizzler.slice(0, 4).join(", ");

  const args = ["float a", "float b", "float c", "float d"].slice(
    0,
    order.length
  );

  return `\
vec4 inject(${args}) {
  return vec4(${mask});
}\
`;
};

// Apply 4-component vector swizzle
const swizzleVec4 = function (order, size = null) {
  const lookup = ["0.0", "xyzw.x", "xyzw.y", "xyzw.z", "xyzw.w"];

  if (size == null) {
    size = order.length;
  }

  order = parseOrder(order);
  order = order.map(function (v) {
    if (Array.from([0, 1, 2, 3, 4]).includes(+v)) {
      v = +v;
    }
    if (v === "" + v) {
      v = index[v] + 1;
    }
    return lookup[v];
  });

  while (order.length < size) {
    order.push("0.0");
  }
  const mask = order.join(", ");

  return `\
vec${size} swizzle(vec4 xyzw) {
  return vec${size}(${mask});
}\
`.replace(/vec1/g, "float");
};

// Invert full or truncated swizzles for pointer lookups
const invertSwizzleVec4 = function (order) {
  const swizzler = ["0.0", "0.0", "0.0", "0.0"];

  order = parseOrder(order);
  order = order.map(function (v) {
    if (v === +v) {
      return letters[v - 1];
    } else {
      return v;
    }
  });

  for (let i = 0; i < order.length; i++) {
    const letter = order[i];
    const src = letters[i];
    const j = index[letter];

    swizzler[j] = `xyzw.${src}`;
  }

  const mask = swizzler.join(", ");

  return `\
vec4 invertSwizzle(vec4 xyzw) {
  return vec4(${mask});
}\
`;
};

const identity = function (type) {
  let args = [].slice.call(arguments);
  if (args.length > 1) {
    args = args.map((t, i) =>
      ["inout", t, String.fromCharCode(97 + i)].join(" ")
    );
    args = args.join(", ");
    return `\
void identity(${args}) { }\
`;
  } else {
    return `\
${type} identity(${type} x) {
  return x;
}\
`;
  }
};

const constant = (type, value) => `\
${type} constant() {
return ${value};
}\
`;

function glsl_range_(left, right, inclusive) {
  const range = [];
  const ascending = left < right;
  const end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}

;// CONCATENATED MODULE: ./src/primitives/types/base/source.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Source extends Primitive {
  static initClass() {
    this.traits = ["node", "source", "index"];
  }

  made() {
    // Notify of buffer reallocation
    return this.trigger({
      type: "source.rebuild",
    });
  }

  indexShader(shader) {
    return shader.pipe(identity("vec4"));
  }
  sourceShader(shader) {
    return shader.pipe(identity("vec4"));
  }

  getDimensions() {
    return {
      items: 1,
      width: 1,
      height: 1,
      depth: 1,
    };
  }

  getActiveDimensions() {
    return this.getDimensions();
  }

  getIndexDimensions() {
    return this.getActiveDimensions();
  }
  getFutureDimensions() {
    return this.getActiveDimensions();
  }
}
Source.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/data.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class data_Data extends Source {
  static initClass() {
    this.traits = ["node", "data", "source", "index", "entity", "active"];
  }

  init() {
    this.dataEmitter = null;
    return (this.dataSizes = null);
  }

  emitter(channels, items) {
    let emitter, resolve;
    const { data, bind, expr } = this.props;

    if (data != null) {
      // Make new emitter if data geometry doesn't match
      const last = this.dataSizes;
      const sizes = getSizes(data);

      if (!last || last.length !== sizes.length) {
        // Create data thunk to copy (multi-)array
        const thunk = getThunk(data);
        this.dataEmitter = this.callback(
          makeEmitter(thunk, items, channels)
        );
        this.dataSizes = sizes;
      }

      emitter = this.dataEmitter;
    } else if (resolve != null) {
      // Hook up data-bound expression to its source
      resolve = this._inherit("resolve");
      emitter = this.callback(resolve.callback(bind));
    } else if (expr != null) {
      // Convert given free expression to appropriate callback
      emitter = this.callback(expr);
    } else {
      // Passthrough
      emitter = this.callback(this.passthrough);
    }

    return emitter;
  }

  callback(callback) {
    return callback != null ? callback : function () {};
  }

  update() {}

  make() {
    this._helpers.active.make();

    // Always run update at least once to prime JS VM optimization for entering elements
    this.first = true;
    return this._listen("root", "root.update", () => {
      if (this.isActive || this.first) {
        this.update();
      }
      return (this.first = false);
    });
  }

  unmake() {
    this._helpers.active.unmake();

    this.dataEmitter = null;
    return (this.dataSizes = null);
  }
}
data_Data.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/buffer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Buffer extends data_Data {
  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "source",
      "index",
      "texture",
    ];
  }

  init() {
    this.bufferSlack = 0;
    this.bufferFrames = 0;

    this.bufferTime = 0;
    this.bufferDelta = 0;

    this.bufferClock = 0;
    this.bufferStep = 0;
    super.init();
  }

  make() {
    super.make();

    this.clockParent = this._inherit("clock");
    this.latchParent = this._inherit("latch");
  }

  unmake() {
    return super.unmake();
  }

  rawBuffer() {
    return this.buffer;
  }

  emitter() {
    const { channels, items } = this.props;

    return super.emitter(channels, items);
  }

  change(changed, touched, init) {
    if (changed["buffer.fps"] || init) {
      const { fps } = this.props;
      return (this.bufferSlack = fps ? 0.5 / fps : 0);
    }
  }

  syncBuffer(callback) {
    let delta, step;
    if (!this.buffer) {
      return;
    }
    const { live, fps, hurry, limit, realtime, observe } = this.props;

    const filled = this.buffer.getFilled();
    if (filled && !live) {
      return;
    }
    if (this.latchParent && !this.latchParent.isDirty) {
      return;
    }

    const time = this.clockParent.getTime();

    if (fps != null) {
      const slack = this.bufferSlack;
      const speed = time.step / time.delta;
      delta = realtime ? time.delta : time.step;
      const frame = 1 / fps;
      step = realtime && observe ? speed * frame : frame;

      if (Math.abs(time.time - this.bufferTime) > time.step * limit) {
        this.bufferTime = time.time;
        this.bufferClock = time.clock;
      }

      this.bufferSlack = Math.min(limit / fps, slack + delta);
      this.bufferDelta = delta;
      this.bufferStep = step;

      let frames = Math.min(hurry, Math.floor(slack * fps));
      if (!filled) {
        frames = Math.max(1, frames);
      }

      let stop = false;
      const abort = () => (stop = true);
      return (() => {
        const result = [];
        for (
          let i = 0, end = frames, asc = 0 <= end;
          asc ? i < end : i > end;
          asc ? i++ : i--
        ) {
          this.bufferTime += delta;
          this.bufferClock += step;

          if (stop) {
            break;
          }
          callback(abort, this.bufferFrames++, i, frames);

          result.push((this.bufferSlack -= frame));
        }
        return result;
      })();
    } else {
      this.bufferTime = time.time;
      this.bufferDelta = time.delta;
      this.bufferClock = time.clock;
      this.bufferStep = time.step;
      return callback(function () {}, this.bufferFrames++, 0, 1);
    }
  }

  alignShader(dims, shader) {
    const { minFilter, magFilter, aligned } = this.props;
    const mixed =
      (dims.items > 1 && dims.width > 1) || (dims.height > 1 && dims.depth > 1);

    if (aligned || !mixed) {
      return;
    }

    const nearest =
      minFilter === this.node.attributes["texture.minFilter"].enum.nearest &&
      magFilter === this.node.attributes["texture.magFilter"].enum.nearest;

    if (!nearest) {
      console.warn(
        `${this.node.toString()} - Cannot use linear min/magFilter with 3D/4D sampling`
      );
    }

    return shader.pipe("map.xyzw.align");
  }
}
Buffer.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/array.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Array_ extends Buffer {
  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "source",
      "index",
      "array",
      "texture",
      "raw",
    ];
  }

  init() {
    this.buffer = this.spec = null;

    this.space = {
      width: 0,
      history: 0,
    };

    this.used = { width: 0 };

    this.storage = "arrayBuffer";
    this.passthrough = (emit, x) => emit(x, 0, 0, 0);

    return super.init();
  }

  sourceShader(shader) {
    const dims = this.getDimensions();
    this.alignShader(dims, shader);
    return this.buffer.shader(shader);
  }

  getDimensions() {
    return {
      items: this.items,
      width: this.space.width,
      height: this.space.history,
      depth: 1,
    };
  }

  getActiveDimensions() {
    return {
      items: this.items,
      width: this.used.width,
      height: this.buffer.getFilled(),
      depth: 1,
    };
  }

  getFutureDimensions() {
    return {
      items: this.items,
      width: this.used.width,
      height: this.space.history,
      depth: 1,
    };
  }

  getRawDimensions() {
    return {
      items: this.items,
      width: this.space.width,
      height: 1,
      depth: 1,
    };
  }

  make() {
    super.make();

    // Read sampling parameters
    const minFilter =
      this.minFilter != null ? this.minFilter : this.props.minFilter;
    const magFilter =
      this.magFilter != null ? this.magFilter : this.props.magFilter;
    const type = this.type != null ? this.type : this.props.type;

    // Read given dimensions
    const { width } = this.props;
    const { history } = this.props;
    const reserve = this.props.bufferWidth;
    const { channels } = this.props;
    const { items } = this.props;

    let dims = (this.spec = { channels, items, width });

    this.items = dims.items;
    this.channels = dims.channels;

    // Init to right size if data supplied
    const { data } = this.props;
    dims = getDimensions(data, dims);

    const { space } = this;
    space.width = Math.max(reserve, dims.width || 1);
    space.history = history;

    // Create array buffer
    return (this.buffer = this._renderables.make(this.storage, {
      width: space.width,
      history: space.history,
      channels,
      items,
      minFilter,
      magFilter,
      type,
    }));
  }

  unmake() {
    super.unmake();
    if (this.buffer) {
      this.buffer.dispose();
      return (this.buffer = this.spec = null);
    }
  }

  change(changed, touched, init) {
    if (
      touched["texture"] ||
      changed["history.history"] ||
      changed["buffer.channels"] ||
      changed["buffer.items"] ||
      changed["array.bufferWidth"]
    ) {
      return this.rebuild();
    }

    if (!this.buffer) {
      return;
    }

    if (changed["array.width"]) {
      const { width, bufferWidth } = this.props;
      this.spec.width = width;

      if (width > bufferWidth) {
        return this.rebuild();
      }
    }

    if (
      changed["data.map"] ||
      changed["data.data"] ||
      changed["data.resolve"] ||
      changed["data.expr"] ||
      init
    ) {
      return this.buffer.setCallback(this.emitter());
    }
  }

  callback(callback) {
    if (callback.length <= 2) {
      return callback;
    } else {
      return (emit, i) => {
        return callback(emit, i, this.bufferClock, this.bufferStep);
      };
    }
  }

  update() {
    if (!this.buffer) {
      return;
    }

    const { data } = this.props;
    let { width } = this.props;
    const { space, used } = this;
    const l = used.width;

    const filled = this.buffer.getFilled();

    this.syncBuffer((abort) => {
      if (data != null) {
        const dims = getDimensions(data, this.spec);

        // Grow width if needed
        if (dims.width > space.width) {
          abort();
          return this.rebuild();
        }

        used.width = dims.width;

        this.buffer.setActive(used.width);
        if (typeof this.buffer.callback.rebind === "function") {
          this.buffer.callback.rebind(data);
        }
        return this.buffer.update();
      } else {
        width = this.spec.width || 1;

        this.buffer.setActive(width);

        width = this.buffer.update();
        return (used.width = width);
      }
    });

    if (used.width !== l || filled !== this.buffer.getFilled()) {
      return this.trigger({
        type: "source.resize",
      });
    }
  }
}
Array_.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/interval.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Interval extends Array_ {
  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "source",
      "index",
      "texture",
      "array",
      "span",
      "interval",
      "sampler",
      "raw",
    ];
  }

  updateSpan() {
    let inverse;
    const dimension = this.props.axis;
    let { width } = this.props;
    const { centered } = this.props;
    const pad = this.props.padding;

    const range = this._helpers.span.get("", dimension);

    width += pad * 2;

    this.a = range.x;
    const span = range.y - range.x;

    if (centered) {
      inverse = 1 / Math.max(1, width);
      this.a += (span * inverse) / 2;
    } else {
      inverse = 1 / Math.max(1, width - 1);
    }

    this.b = span * inverse;

    return (this.a += pad * this.b);
  }

  callback(callback) {
    this.updateSpan();

    if (this.last === callback) {
      return this._callback;
    }
    this.last = callback;

    if (callback.length <= 3) {
      return (this._callback = (emit, i) => {
        const x = this.a + this.b * i;
        return callback(emit, x, i);
      });
    } else {
      return (this._callback = (emit, i) => {
        const x = this.a + this.b * i;
        return callback(emit, x, i, this.bufferClock, this.bufferStep);
      });
    }
  }

  make() {
    super.make();
    this._helpers.span.make();
    return this._listen(this, "span.range", this.updateSpan);
  }

  unmake() {
    super.unmake();
    return this._helpers.span.unmake();
  }

  change(changed, touched, init) {
    super.change(changed, touched, init);
    if (touched["span"]) {
      this.updateSpan();
    }
  }
}
Interval.initClass();

// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js
var cloneDeep = __webpack_require__(361);
var cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);
// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js
var isEqual = __webpack_require__(8446);
var isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);
;// CONCATENATED MODULE: ./src/primitives/types/data/latch.js




class Latch extends Parent {
  static initClass() {
    this.traits = ["node", "entity", "active", "latch"];
  }

  init() {
    this.data = undefined;
    this.isDirty = true;
  }

  make() {
    this._helpers.active.make();

    this._listen("root", "root.update", function () {
      if (this.isActive) {
        this.update();
      }
    });
  }

  unmake() {
    this._helpers.active.unmake();
    this.data = undefined;
  }

  swap() {
    const { deep, data } = this.props;
    const dirty = deep ? !isEqual_default()(data, this.data) : data != this.data;
    if (dirty) {
      this.data = deep ? cloneDeep_default()(data) : data;
    }
  }

  update() {
    this.isDirty = this.swap();
  }
}
Latch.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/matrix.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Matrix extends Buffer {
  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "source",
      "index",
      "texture",
      "matrix",
      "raw",
    ];
  }

  init() {
    this.buffer = this.spec = null;

    this.space = {
      width: 0,
      height: 0,
      history: 0,
    };

    this.used = {
      width: 0,
      height: 0,
    };

    this.storage = "matrixBuffer";
    this.passthrough = (emit, x, y) => emit(x, y, 0, 0);

    return super.init();
  }

  sourceShader(shader) {
    const dims = this.getDimensions();
    this.alignShader(dims, shader);
    return this.buffer.shader(shader);
  }

  getDimensions() {
    return {
      items: this.items,
      width: this.space.width,
      height: this.space.height,
      depth: this.space.history,
    };
  }

  getActiveDimensions() {
    return {
      items: this.items,
      width: this.used.width,
      height: this.used.height,
      depth: this.buffer.getFilled(),
    };
  }

  getFutureDimensions() {
    return {
      items: this.items,
      width: this.used.width,
      height: this.used.height,
      depth: this.space.history,
    };
  }

  getRawDimensions() {
    return {
      items: this.items,
      width: this.space.width,
      height: this.space.height,
      depth: 1,
    };
  }

  make() {
    super.make();

    // Read sampling parameters
    const minFilter =
      this.minFilter != null ? this.minFilter : this.props.minFilter;
    const magFilter =
      this.magFilter != null ? this.magFilter : this.props.magFilter;
    const type = this.type != null ? this.type : this.props.type;

    // Read given dimensions
    const { width } = this.props;
    const { height } = this.props;
    const { history } = this.props;
    const reserveX = this.props.bufferWidth;
    const reserveY = this.props.bufferHeight;
    const { channels } = this.props;
    const { items } = this.props;

    let dims = (this.spec = { channels, items, width, height });

    this.items = dims.items;
    this.channels = dims.channels;

    // Init to right size if data supplied
    const { data } = this.props;
    dims = getDimensions(data, dims);

    const { space } = this;
    space.width = Math.max(reserveX, dims.width || 1);
    space.height = Math.max(reserveY, dims.height || 1);
    space.history = history;

    // Create matrix buffer
    return (this.buffer = this._renderables.make(this.storage, {
      width: space.width,
      height: space.height,
      history: space.history,
      channels,
      items,
      minFilter,
      magFilter,
      type,
    }));
  }

  unmake() {
    super.unmake();
    if (this.buffer) {
      this.buffer.dispose();
      return (this.buffer = this.spec = null);
    }
  }

  change(changed, touched, init) {
    if (
      touched["texture"] ||
      changed["matrix.history"] ||
      changed["buffer.channels"] ||
      changed["buffer.items"] ||
      changed["matrix.bufferWidth"] ||
      changed["matrix.bufferHeight"]
    ) {
      return this.rebuild();
    }

    if (!this.buffer) {
      return;
    }

    if (changed["matrix.width"]) {
      const { width, bufferWidth } = this.props;
      this.spec.width = width;

      if (width > bufferWidth) {
        return this.rebuild();
      }
    }

    if (changed["matrix.height"]) {
      const { height, bufferHeight } = this.props;
      this.spec.height = height;

      if (height > bufferHeight) {
        return this.rebuild();
      }
    }

    if (
      changed["data.map"] ||
      changed["data.data"] ||
      changed["data.resolve"] ||
      changed["data.expr"] ||
      init
    ) {
      return this.buffer.setCallback(this.emitter());
    }
  }

  callback(callback) {
    if (callback.length <= 3) {
      return callback;
    } else {
      return (emit, i, j) => {
        return callback(emit, i, j, this.bufferClock, this.bufferStep);
      };
    }
  }

  update() {
    if (!this.buffer) {
      return;
    }

    const { data } = this.props;
    const { space, used } = this;
    const w = used.width;
    const h = used.height;

    const filled = this.buffer.getFilled();

    this.syncBuffer((abort) => {
      if (data != null) {
        const dims = getDimensions(data, this.spec);

        // Grow if needed
        if (dims.width > space.width || dims.height > space.height) {
          abort();
          return this.rebuild();
        }

        used.width = dims.width;
        used.height = dims.height;

        this.buffer.setActive(used.width, used.height);
        if (typeof this.buffer.callback.rebind === "function") {
          this.buffer.callback.rebind(data);
        }
        return this.buffer.update();
      } else {
        let _w;
        const width = this.spec.width || 1;
        const height = this.spec.height || 1;

        this.buffer.setActive(width, height);

        const length = this.buffer.update();

        used.width = _w = width;
        used.height = Math.min(height, Math.ceil(length / _w));
        if (used.height === 1) {
          used.width = Math.min(width, length);
        }
      }
    });

    if (
      used.width !== w ||
      used.height !== h ||
      filled !== this.buffer.getFilled()
    ) {
      return this.trigger({
        type: "source.resize",
      });
    }
  }
}
Matrix.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/area.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



class Area extends Matrix {
  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "source",
      "index",
      "matrix",
      "texture",
      "raw",
      "span:x",
      "span:y",
      "area",
      "sampler:x",
      "sampler:y",
    ];
  }

  updateSpan() {
    let inverseX, inverseY;
    const dimensions = this.props.axes;
    let { width } = this.props;
    let { height } = this.props;

    const { centeredX } = this.props;
    const { centeredY } = this.props;

    const padX = this.props.paddingX;
    const padY = this.props.paddingY;

    const rangeX = this._helpers.span.get("x.", dimensions[0]);
    const rangeY = this._helpers.span.get("y.", dimensions[1]);

    this.aX = rangeX.x;
    this.aY = rangeY.x;

    const spanX = rangeX.y - rangeX.x;
    const spanY = rangeY.y - rangeY.x;

    width += padX * 2;
    height += padY * 2;

    if (centeredX) {
      inverseX = 1 / Math.max(1, width);
      this.aX += (spanX * inverseX) / 2;
    } else {
      inverseX = 1 / Math.max(1, width - 1);
    }

    if (centeredY) {
      inverseY = 1 / Math.max(1, height);
      this.aY += (spanY * inverseY) / 2;
    } else {
      inverseY = 1 / Math.max(1, height - 1);
    }

    this.bX = spanX * inverseX;
    this.bY = spanY * inverseY;

    this.aX += padX * this.bX;
    return (this.aY += padY * this.bY);
  }

  callback(callback) {
    this.updateSpan();

    if (this.last === callback) {
      return this._callback;
    }
    this.last = callback;

    if (callback.length <= 5) {
      return (this._callback = (emit, i, j) => {
        const x = this.aX + this.bX * i;
        const y = this.aY + this.bY * j;
        return callback(emit, x, y, i, j);
      });
    } else {
      return (this._callback = (emit, i, j) => {
        const x = this.aX + this.bX * i;
        const y = this.aY + this.bY * j;
        return callback(emit, x, y, i, j, this.bufferClock, this.bufferStep);
      });
    }
  }

  make() {
    super.make();
    this._helpers.span.make();
    return this._listen(this, "span.range", this.updateSpan);
  }

  unmake() {
    super.unmake();
    return this._helpers.span.unmake();
  }

  change(changed, touched, init) {
    super.change(changed, touched, init);
    if (touched["x"] || touched["y"]) {
      this.updateSpan();
    }
  }
}
Area.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/voxel.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS002: Fix invalid constructor
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Voxel extends Buffer {
  constructor(...args) {
    super(...args);
    this.update = this.update.bind(this);
  }

  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "source",
      "index",
      "texture",
      "voxel",
      "raw",
    ];
  }

  init() {
    this.buffer = this.spec = null;

    this.space = {
      width: 0,
      height: 0,
      depth: 0,
    };

    this.used = {
      width: 0,
      height: 0,
      depth: 0,
    };

    this.storage = "voxelBuffer";
    this.passthrough = (emit, x, y, z) => emit(x, y, z, 0);
    super.init();
  }

  sourceShader(shader) {
    const dims = this.getDimensions();
    this.alignShader(dims, shader);
    return this.buffer.shader(shader);
  }

  getDimensions() {
    return {
      items: this.items,
      width: this.space.width,
      height: this.space.height,
      depth: this.space.depth,
    };
  }

  getActiveDimensions() {
    return {
      items: this.items,
      width: this.used.width,
      height: this.used.height,
      depth: this.used.depth * this.buffer.getFilled(),
    };
  }

  getRawDimensions() {
    return this.getDimensions();
  }

  make() {
    super.make();

    // Read sampling parameters
    const minFilter =
      this.minFilter != null ? this.minFilter : this.props.minFilter;
    const magFilter =
      this.magFilter != null ? this.magFilter : this.props.magFilter;
    const type = this.type != null ? this.type : this.props.type;

    // Read given dimensions
    const { width } = this.props;
    const { height } = this.props;
    const { depth } = this.props;
    const reserveX = this.props.bufferWidth;
    const reserveY = this.props.bufferHeight;
    const reserveZ = this.props.bufferDepth;
    const { channels } = this.props;
    const { items } = this.props;

    let dims = (this.spec = { channels, items, width, height, depth });

    this.items = dims.items;
    this.channels = dims.channels;

    // Init to right size if data supplied
    const { data } = this.props;
    dims = getDimensions(data, dims);

    const { space } = this;
    space.width = Math.max(reserveX, dims.width || 1);
    space.height = Math.max(reserveY, dims.height || 1);
    space.depth = Math.max(reserveZ, dims.depth || 1);

    // Create voxel buffer
    return (this.buffer = this._renderables.make(this.storage, {
      width: space.width,
      height: space.height,
      depth: space.depth,
      channels,
      items,
      minFilter,
      magFilter,
      type,
    }));
  }

  unmake() {
    super.unmake();
    if (this.buffer) {
      this.buffer.dispose();
      return (this.buffer = this.spec = null);
    }
  }

  change(changed, touched, init) {
    if (
      touched["texture"] ||
      changed["buffer.channels"] ||
      changed["buffer.items"] ||
      changed["voxel.bufferWidth"] ||
      changed["voxel.bufferHeight"] ||
      changed["voxel.bufferDepth"]
    ) {
      return this.rebuild();
    }

    if (!this.buffer) {
      return;
    }

    if (changed["voxel.width"]) {
      const { width, bufferWidth } = this.props;
      this.spec.width = width;

      if (width > bufferWidth) {
        return this.rebuild();
      }
    }

    if (changed["voxel.height"]) {
      const { height, bufferHeight } = this.props;
      this.spec.height = height;

      if (height > bufferHeight) {
        return this.rebuild();
      }
    }

    if (changed["voxel.depth"]) {
      const { depth, bufferDepth } = this.props;
      this.spec.depth = depth;

      if (depth > bufferDepth) {
        return this.rebuild();
      }
    }

    if (
      changed["data.map"] ||
      changed["data.data"] ||
      changed["data.resolve"] ||
      changed["data.expr"] ||
      init
    ) {
      return this.buffer.setCallback(this.emitter());
    }
  }

  callback(callback) {
    if (callback.length <= 4) {
      return callback;
    } else {
      return (emit, i, j, k) => {
        return callback(emit, i, j, k, this.bufferClock, this.bufferStep);
      };
    }
  }

  update() {
    if (!this.buffer) {
      return;
    }

    const { data } = this.props;
    const { space, used } = this;
    const w = used.width;
    const h = used.height;
    const d = used.depth;

    const filled = this.buffer.getFilled();

    this.syncBuffer((abort) => {
      if (data != null) {
        const dims = getDimensions(data, this.spec);

        // Grow dimensions if needed
        if (
          dims.width > space.width ||
          dims.height > space.height ||
          dims.depth > space.depth
        ) {
          abort();
          return this.rebuild();
        }

        used.width = dims.width;
        used.height = dims.height;
        used.depth = dims.depth;

        this.buffer.setActive(used.width, used.height, used.depth);
        if (typeof this.buffer.callback.rebind === "function") {
          this.buffer.callback.rebind(data);
        }
        return this.buffer.update();
      } else {
        let _h, _w;
        const width = this.spec.width || 1;
        const height = this.spec.height || 1;
        const depth = this.spec.depth || 1;

        this.buffer.setActive(width, height, depth);

        const length = this.buffer.update();

        used.width = _w = width;
        used.height = _h = height;
        used.depth = Math.min(depth, Math.ceil(length / _w / _h));

        if (used.depth === 1) {
          used.height = Math.min(height, Math.ceil(length / _w));
          if (used.height === 1) {
            used.width = Math.min(width, length);
          }
        }
      }
    });

    if (
      used.width !== w ||
      used.height !== h ||
      used.depth !== d ||
      filled !== this.buffer.getFilled()
    ) {
      return this.trigger({
        type: "source.resize",
      });
    }
  }
}
Voxel.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/volume.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Volume extends Voxel {
  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "source",
      "index",
      "texture",
      "voxel",
      "span:x",
      "span:y",
      "span:z",
      "volume",
      "sampler:x",
      "sampler:y",
      "sampler:z",
      "raw",
    ];
  }

  updateSpan() {
    let inverseX, inverseY, inverseZ;
    const dimensions = this.props.axes;
    let { width } = this.props;
    let { height } = this.props;
    let { depth } = this.props;

    const { centeredX } = this.props;
    const { centeredY } = this.props;
    const { centeredZ } = this.props;

    const padX = this.props.paddingX;
    const padY = this.props.paddingY;
    const padZ = this.props.paddingZ;

    const rangeX = this._helpers.span.get("x.", dimensions[0]);
    const rangeY = this._helpers.span.get("y.", dimensions[1]);
    const rangeZ = this._helpers.span.get("z.", dimensions[2]);

    this.aX = rangeX.x;
    this.aY = rangeY.x;
    this.aZ = rangeZ.x;

    const spanX = rangeX.y - rangeX.x;
    const spanY = rangeY.y - rangeY.x;
    const spanZ = rangeZ.y - rangeZ.x;

    width += padX * 2;
    height += padY * 2;
    depth += padZ * 2;

    if (centeredX) {
      inverseX = 1 / Math.max(1, width);
      this.aX += (spanX * inverseX) / 2;
    } else {
      inverseX = 1 / Math.max(1, width - 1);
    }

    if (centeredY) {
      inverseY = 1 / Math.max(1, height);
      this.aY += (spanY * inverseY) / 2;
    } else {
      inverseY = 1 / Math.max(1, height - 1);
    }

    if (centeredZ) {
      inverseZ = 1 / Math.max(1, depth);
      this.aZ += (spanZ * inverseZ) / 2;
    } else {
      inverseZ = 1 / Math.max(1, depth - 1);
    }

    this.bX = spanX * inverseX;
    this.bY = spanY * inverseY;
    this.bZ = spanZ * inverseZ;

    this.aX += this.bX * padX;
    this.aY += this.bY * padY;
    return (this.aZ += this.bZ * padY);
  }

  callback(callback) {
    this.updateSpan();

    if (this.last === callback) {
      return this._callback;
    }
    this.last = callback;

    if (callback.length <= 7) {
      return (this._callback = (emit, i, j, k) => {
        const x = this.aX + this.bX * i;
        const y = this.aY + this.bY * j;
        const z = this.aZ + this.bZ * k;
        return callback(emit, x, y, z, i, j, k);
      });
    } else {
      return (this._callback = (emit, i, j, k) => {
        const x = this.aX + this.bX * i;
        const y = this.aY + this.bY * j;
        const z = this.aZ + this.bZ * k;
        return callback(
          emit,
          x,
          y,
          z,
          i,
          j,
          k,
          this.bufferClock,
          this.bufferStep
        );
      });
    }
  }

  make() {
    super.make();
    this._helpers.span.make();
    return this._listen(this, "span.range", this.updateSpan);
  }

  unmake() {
    super.unmake();
    return this._helpers.span.unmake();
  }

  change(changed, touched, init) {
    super.change(changed, touched, init);

    if (touched["x"] || touched["y"] || touched["z"]) {
      this.updateSpan();
    }
  }
}
Volume.initClass();

;// CONCATENATED MODULE: ./src/util/axis.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


const setOrigin = function (vec, dimensions, origin) {
  if (+dimensions === dimensions) {
    dimensions = [dimensions];
  }
  const x = Array.from(dimensions).includes(1) ? 0 : origin.x;
  const y = Array.from(dimensions).includes(2) ? 0 : origin.y;
  const z = Array.from(dimensions).includes(3) ? 0 : origin.z;
  const w = Array.from(dimensions).includes(4) ? 0 : origin.w;
  return vec.set(x, y, z, w);
};

const addOrigin = (function () {
  const v = new external_THREE_.Vector4();
  return function (vec, dimension, origin) {
    setOrigin(v, dimension, origin);
    return vec.add(v);
  };
})();

const setDimension = function (vec, dimension) {
  const x = dimension === 1 ? 1 : 0;
  const y = dimension === 2 ? 1 : 0;
  const z = dimension === 3 ? 1 : 0;
  const w = dimension === 4 ? 1 : 0;
  return vec.set(x, y, z, w);
};

const setDimensionNormal = function (vec, dimension) {
  const x = dimension === 1 ? 1 : 0;
  const y = dimension === 2 ? 1 : 0;
  const z = dimension === 3 ? 1 : 0;
  const w = dimension === 4 ? 1 : 0;
  return vec.set(y, z + x, w, 0);
};

const recenterAxis = (function () {
  const axis = [0, 0];

  return function (x, dx, bend, f) {
    if (f == null) {
      f = 0;
    }
    if (bend > 0) {
      const x1 = x;
      const x2 = x + dx;

      const abs = Math.max(Math.abs(x1), Math.abs(x2));
      const fabs = abs * f;

      const min = Math.min(x1, x2);
      const max = Math.max(x1, x2);

      x = min + (-abs + fabs - min) * bend;
      dx = max + (abs + fabs - max) * bend - x;
    }

    axis[0] = x;
    axis[1] = dx;
    return axis;
  };
})();

;// CONCATENATED MODULE: ./src/primitives/types/data/scale.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Scale extends Source {
  static initClass() {
    this.traits = [
      "node",
      "source",
      "index",
      "interval",
      "span",
      "scale",
      "raw",
      "origin",
    ];
  }

  init() {
    return (this.used = this.space = this.scaleAxis = this.sampler = null);
  }

  rawBuffer() {
    return this.buffer;
  }

  sourceShader(shader) {
    return shader.pipe(this.sampler);
  }

  getDimensions() {
    return {
      items: 1,
      width: this.space,
      height: 1,
      depth: 1,
    };
  }

  getActiveDimensions() {
    return {
      items: 1,
      width: this.used,
      height: this.buffer.getFilled(),
      depth: 1,
    };
  }

  getRawDimensions() {
    return this.getDimensions();
  }

  make() {
    // Prepare data buffer of tick positions
    let samples;
    this.space = samples = this._helpers.scale.divide("");

    this.buffer = this._renderables.make("dataBuffer", {
      width: samples,
      channels: 1,
      items: 1,
    });

    // Prepare position shader
    const positionUniforms = {
      scaleAxis: this._attributes.make(this._types.vec4()),
      scaleOffset: this._attributes.make(this._types.vec4()),
    };

    this.scaleAxis = positionUniforms.scaleAxis.value;
    this.scaleOffset = positionUniforms.scaleOffset.value;

    // Build sampler
    const p = (this.sampler = this._shaders.shader());
    // Require buffer sampler as callback
    p.require(this.buffer.shader(this._shaders.shader(), 1));
    // Shader to expand scalars to 4D vector on an axis.
    p.pipe("scale.position", positionUniforms);

    this._helpers.span.make();

    // Monitor view range
    return this._listen(this, "span.range", this.updateRanges);
  }

  unmake() {
    this.scaleAxis = null;

    return this._helpers.span.unmake();
  }

  change(changed, touched, init) {
    if (changed["scale.divide"]) {
      return this.rebuild();
    }

    if (
      touched["view"] ||
      touched["interval"] ||
      touched["span"] ||
      touched["scale"] ||
      touched["origin"] ||
      init
    ) {
      return this.updateRanges();
    }
  }

  updateRanges() {
    const { used } = this;

    // Fetch range along axis
    const { axis, origin } = this.props;
    const range = this._helpers.span.get("", axis);

    // Calculate scale along axis
    const min = range.x;
    const max = range.y;
    const ticks = this._helpers.scale.generate("", this.buffer, min, max);

    setDimension(this.scaleAxis, axis);
    setOrigin(this.scaleOffset, axis, origin);

    // Clip to number of ticks
    this.used = ticks.length;

    // Notify of resize
    if (this.used !== used) {
      return this.trigger({
        type: "source.resize",
      });
    }
  }
}
Scale.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/data/index.js









;// CONCATENATED MODULE: ./src/util/js.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// Merge multiple objects
const merge = function () {
  const x = {};
  for (const obj of Array.from(arguments)) {
    for (const k in obj) {
      const v = obj[k];
      x[k] = v;
    }
  }
  return x;
};

const clone = (o) => JSON.parse(JSON.serialize(o));

const parseQuoted = function (str) {
  let accum = "";

  const unescape = (str) => (str = str.replace(/\\/g, ""));
  const munch = function (next) {
    if (accum.length) {
      list.push(unescape(accum));
    }
    return (accum = next != null ? next : "");
  };

  str = str.split(/(?=(?:\\.|["' ,]))/g);
  let quote = false;
  const list = [];

  for (const chunk of Array.from(str)) {
    const char = chunk[0];
    const token = chunk.slice(1);
    switch (char) {
      case '"':
      case "'":
        if (quote) {
          if (quote === char) {
            quote = false;
            munch(token);
          } else {
            accum += chunk;
          }
        } else {
          if (accum !== "") {
            throw new Error(
              `ParseError: String \`${str}\` does not contain comma-separated quoted tokens.`
            );
          }

          quote = char;
          accum += token;
        }
        break;
      case " ":
      case ",":
        if (!quote) {
          munch(token);
        } else {
          accum += chunk;
        }
        break;
      default:
        accum += chunk;
    }
  }
  munch();
  return list;
};

;// CONCATENATED MODULE: ./src/primitives/types/draw/axis.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Axis extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "axis",
      "span",
      "interval",
      "arrow",
      "position",
      "origin",
      "shade",
    ];
    this.defaults = {
      end: true,
      zBias: -1,
    };
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.axisPosition =
      this.axisStep =
      this.resolution =
      this.line =
      this.arrows =
        null;
  }

  make() {
    // Prepare position shader
    const positionUniforms = {
      axisPosition: this._attributes.make(this._types.vec4()),
      axisStep: this._attributes.make(this._types.vec4()),
    };

    this.axisPosition = positionUniforms.axisPosition.value;
    this.axisStep = positionUniforms.axisStep.value;

    // Build transform chain
    let position = this._shaders.shader();
    position.pipe("axis.position", positionUniforms);
    position = this._helpers.position.pipeline(position);

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const lineUniforms = this._helpers.line.uniforms();
    const arrowUniforms = this._helpers.arrow.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Line geometry
    const { detail } = this.props;
    const samples = detail + 1;
    this.resolution = 1 / detail;

    // Clip start/end for terminating arrow
    const { start, end } = this.props;

    // Stroke style
    const { stroke, join } = this.props;

    // Build transition mask lookup
    let mask = this._helpers.object.mask();

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline() || false;

    // Indexing by fixed or by given axis
    const { crossed, axis } = this.props;
    if (!crossed && mask != null && axis > 1) {
      const swizzle = ["x000", "y000", "z000", "w000"][axis];
      mask = this._helpers.position.swizzle(mask, swizzle);
    }

    // Make line renderable
    const uniforms = merge(
      arrowUniforms,
      lineUniforms,
      styleUniforms,
      unitUniforms
    );
    this.line = this._renderables.make("line", {
      uniforms,
      samples,
      position,
      clip: start || end,
      stroke,
      join,
      mask,
      material,
    });

    // Make arrow renderables
    this.arrows = [];
    if (start) {
      this.arrows.push(
        this._renderables.make("arrow", {
          uniforms,
          flip: true,
          samples,
          position,
          mask,
          material,
        })
      );
    }

    if (end) {
      this.arrows.push(
        this._renderables.make("arrow", {
          uniforms,
          samples,
          position,
          mask,
          material,
        })
      );
    }

    // Visible, object and span traits
    this._helpers.visible.make();
    this._helpers.object.make(this.arrows.concat([this.line]));
    this._helpers.span.make();

    // Monitor view range
    return this._listen(this, "span.range", this.updateRanges);
  }

  unmake() {
    this._helpers.visible.unmake();
    this._helpers.object.unmake();
    return this._helpers.span.unmake();
  }

  change(changed, touched, init) {
    if (
      changed["axis.detail"] ||
      changed["line.stroke"] ||
      changed["line.join"] ||
      changed["axis.crossed"] ||
      (changed["interval.axis"] && this.props.crossed)
    ) {
      return this.rebuild();
    }

    if (
      touched["interval"] ||
      touched["span"] ||
      touched["view"] ||
      touched["origin"] ||
      init
    ) {
      return this.updateRanges();
    }
  }

  updateRanges() {
    const { axis, origin } = this.props;

    const range = this._helpers.span.get("", axis);

    const min = range.x;
    const max = range.y;

    setDimension(this.axisPosition, axis).multiplyScalar(min);
    setDimension(this.axisStep, axis).multiplyScalar(
      (max - min) * this.resolution
    );

    return addOrigin(this.axisPosition, axis, origin);
  }
}
Axis.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/face.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Face extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "mesh",
      "face",
      "geometry",
      "position",
      "bind",
      "shade",
    ];
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.face = null;
  }

  resize() {
    if (this.bind.points == null) {
      return;
    }

    const dims = this.bind.points.getActiveDimensions();
    const { items, width, height, depth } = dims;

    if (this.face) {
      this.face.geometry.clip(width, height, depth, items);
    }
    if (this.line) {
      this.line.geometry.clip(items, width, height, depth);
    }

    if (this.bind.map != null) {
      const map = this.bind.map.getActiveDimensions();
      if (this.face) {
        return this.face.geometry.map(
          map.width,
          map.height,
          map.depth,
          map.items
        );
      }
    }
  }

  make() {
    // Bind to attached data sources
    let color, uniforms;
    this._helpers.bind.make([
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
      { to: "mesh.map", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }

    // Fetch position and transform to view
    let position = this.bind.points.sourceShader(this._shaders.shader());
    position = this._helpers.position.pipeline(position);

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const lineUniforms = this._helpers.line.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Auto z-bias wireframe over surface
    const wireUniforms = {};
    wireUniforms.styleZBias = this._attributes.make(this._types.number());
    this.wireZBias = wireUniforms.styleZBias;

    // Fetch geometry dimensions
    const dims = this.bind.points.getDimensions();
    const { items, width, height, depth } = dims;

    // Get display properties
    const { line, shaded, fill, stroke, join } = this.props;

    // Build color lookup
    if (this.bind.colors) {
      color = this._shaders.shader();
      this.bind.colors.sourceShader(color);
    }

    // Build transition mask lookup
    const mask = this._helpers.object.mask();

    // Build texture map lookup
    const map = this._helpers.shade.map(
      this.bind.map != null
        ? this.bind.map.sourceShader(this._shaders.shader())
        : undefined
    );

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline();
    const faceMaterial = material || shaded;
    const lineMaterial = material || false;

    const objects = [];

    // Make line renderable
    if (line) {
      // Swizzle face edges into segments
      const swizzle = this._shaders.shader();
      swizzle.pipe(swizzleVec4("yzwx"));
      swizzle.pipe(position);

      uniforms = merge(
        unitUniforms,
        lineUniforms,
        styleUniforms,
        wireUniforms
      );
      this.line = this._renderables.make("line", {
        uniforms,
        samples: items,
        strips: width,
        ribbons: height,
        layers: depth,
        position: swizzle,
        color,
        stroke,
        join,
        material: lineMaterial,
        mask,
        closed: true,
      });
      objects.push(this.line);
    }

    // Make face renderable
    if (fill) {
      uniforms = merge(unitUniforms, styleUniforms, {});
      this.face = this._renderables.make("face", {
        uniforms,
        width,
        height,
        depth,
        items,
        position,
        color,
        material: faceMaterial,
        mask,
        map,
      });
      objects.push(this.face);
    }

    this._helpers.visible.make();
    return this._helpers.object.make(objects);
  }

  made() {
    return this.resize();
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    this._helpers.object.unmake();

    return (this.face = this.line = null);
  }

  change(changed, touched, init) {
    if (changed["geometry.points"] || touched["mesh"]) {
      return this.rebuild();
    }

    if (changed["style.zBias"] || changed["mesh.lineBias"] || init) {
      const { fill, zBias, lineBias } = this.props;
      return (this.wireZBias.value = zBias + (fill ? lineBias : 0));
    }
  }
}
Face.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/grid.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Grid extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "grid",
      "area",
      "position",
      "origin",
      "shade",
      "axis:x",
      "axis:y",
      "scale:x",
      "scale:y",
      "span:x",
      "span:y",
    ];
    this.defaults = {
      width: 1,
      zBias: -2,
    };
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.axes = null;
  }

  make() {
    // Build transition mask lookup
    let axis;
    let mask = this._helpers.object.mask();

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline() || false;

    axis = (first, second, transpose) => {
      // Prepare data buffer of tick positions
      let position;
      const detail = this._get(first + "axis.detail");
      const samples = detail + 1;
      const resolution = 1 / detail;

      const strips = this._helpers.scale.divide(second);
      const buffer = this._renderables.make("dataBuffer", {
        width: strips,
        channels: 1,
      });

      // Prepare position shader
      const positionUniforms = {
        gridPosition: this._attributes.make(this._types.vec4()),
        gridStep: this._attributes.make(this._types.vec4()),
        gridAxis: this._attributes.make(this._types.vec4()),
      };

      const values = {
        gridPosition: positionUniforms.gridPosition.value,
        gridStep: positionUniforms.gridStep.value,
        gridAxis: positionUniforms.gridAxis.value,
      };

      // Build transform chain
      const p = (position = this._shaders.shader());

      // Align second grid with first in mask space if requested
      if (transpose != null && mask != null) {
        mask = this._helpers.position.swizzle(mask, transpose);
      }

      // Require buffer sampler as callback
      p.require(buffer.shader(this._shaders.shader(), 2));

      // Calculate grid position
      p.pipe("grid.position", positionUniforms);

      // Apply view transform
      position = this._helpers.position.pipeline(p);

      // Prepare bound uniforms
      const styleUniforms = this._helpers.style.uniforms();
      const lineUniforms = this._helpers.line.uniforms();
      const unitUniforms = this._inherit("unit").getUnitUniforms();
      const uniforms = merge(lineUniforms, styleUniforms, unitUniforms);

      // Make line renderable
      const line = this._renderables.make("line", {
        uniforms,
        samples,
        strips,
        position,
        stroke,
        join,
        mask,
        material,
      });

      // Store axis object for manipulation later
      return { first, second, resolution, samples, line, buffer, values };
    };

    // Generate both line sets
    const { lineX, lineY, crossed, axes } = this.props;
    const transpose = ["0000", "x000", "y000", "z000", "w000"][axes[1]];

    // Stroke style
    const { stroke, join } = this.props;

    this.axes = [];
    lineX && this.axes.push(axis("x.", "y.", null));
    lineY && this.axes.push(axis("y.", "x.", crossed ? null : transpose));

    // Register lines
    const lines = (() => {
      const result = [];
      for (axis of this.axes) {
        result.push(axis.line);
      }
      return result;
    })();
    this._helpers.visible.make();
    this._helpers.object.make(lines);
    this._helpers.span.make();

    // Monitor view range
    return this._listen(this, "span.range", this.updateRanges);
  }

  unmake() {
    this._helpers.visible.unmake();
    this._helpers.object.unmake();
    this._helpers.span.unmake();

    for (const axis of this.axes) {
      axis.buffer.dispose();
    }

    this.axes = null;
  }

  change(changed, touched, init) {
    if (
      changed["x.axis.detail"] ||
      changed["y.axis.detail"] ||
      changed["x.axis.factor"] ||
      changed["y.axis.factor"] ||
      changed["grid.lineX"] ||
      changed["grid.lineY"] ||
      changed["line.stroke"] ||
      changed["line.join"] ||
      changed["grid.crossed"] ||
      (changed["grid.axes"] && this.props.crossed)
    ) {
      return this.rebuild();
    }

    if (
      touched["x"] ||
      touched["y"] ||
      touched["area"] ||
      touched["grid"] ||
      touched["view"] ||
      touched["origin"] ||
      init
    ) {
      return this.updateRanges();
    }
  }

  updateRanges() {
    const axis = (x, y, range1, range2, axis) => {
      const { second, resolution, samples, line, buffer, values } = axis;

      // Set line steps along first axis
      let min = range1.x;
      let max = range1.y;
      setDimension(values.gridPosition, x).multiplyScalar(min);
      setDimension(values.gridStep, x).multiplyScalar(
        (max - min) * resolution
      );

      // Add origin on remaining two axes
      addOrigin(values.gridPosition, axes, origin);

      // Calculate scale along second axis
      min = range2.x;
      max = range2.y;
      const ticks = this._helpers.scale.generate(second, buffer, min, max);
      setDimension(values.gridAxis, y);

      // Clip to number of ticks
      const n = ticks.length;
      return line.geometry.clip(samples, n, 1, 1);
    };

    // Fetch grid range in both dimensions
    const { axes, origin } = this.props;
    const range1 = this._helpers.span.get("x.", axes[0]);
    const range2 = this._helpers.span.get("y.", axes[1]);

    // Update both line sets
    const { lineX, lineY } = this.props;

    if (lineX) {
      axis(axes[0], axes[1], range1, range2, this.axes[0]);
    }
    if (lineY) {
      axis(axes[1], axes[0], range2, range1, this.axes[+lineX]);
    }
    window.cake1 = this.axes[0].buffer;
    window.cake2 = this.axes[1].buffer;
    window.cake3 = this.axes[0];
  }
}
Grid.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/line.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Line extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "arrow",
      "geometry",
      "position",
      "bind",
      "shade",
    ];
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.line = this.arrows = null;
  }

  resize() {
    if (this.bind.points == null) {
      return;
    }
    const dims = this.bind.points.getActiveDimensions();

    const samples = dims.width;
    const strips = dims.height;
    const ribbons = dims.depth;
    const layers = dims.items;

    this.line.geometry.clip(samples, strips, ribbons, layers);
    return Array.from(this.arrows).map((arrow) =>
      arrow.geometry.clip(samples, strips, ribbons, layers)
    );
  }

  make() {
    // Bind to attached data sources
    let color;
    this._helpers.bind.make([
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }

    // Build transform chain
    let position = this._shaders.shader();

    // Fetch position
    position = this.bind.points.sourceShader(position);

    // Transform position to view
    position = this._helpers.position.pipeline(position);

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const lineUniforms = this._helpers.line.uniforms();
    const arrowUniforms = this._helpers.arrow.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Clip start/end for terminating arrow
    const { start, end } = this.props;

    // Stroke style
    const { stroke, join, proximity, closed } = this.props;
    this.proximity = proximity;

    // Fetch geometry dimensions
    const dims = this.bind.points.getDimensions();
    const samples = dims.width;
    const strips = dims.height;
    const ribbons = dims.depth;
    const layers = dims.items;

    // Build color lookup
    if (this.bind.colors) {
      color = this._shaders.shader();
      this.bind.colors.sourceShader(color);
    }

    // Build transition mask lookup
    const mask = this._helpers.object.mask();

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline() || false;

    // Make line renderable
    const uniforms = merge(
      arrowUniforms,
      lineUniforms,
      styleUniforms,
      unitUniforms
    );
    this.line = this._renderables.make("line", {
      uniforms,
      samples,
      strips,
      ribbons,
      layers,
      position,
      color,
      clip: start || end,
      stroke,
      join,
      proximity,
      closed,
      mask,
      material,
    });

    // Make arrow renderables
    this.arrows = [];
    if (start) {
      this.arrows.push(
        this._renderables.make("arrow", {
          uniforms,
          flip: true,
          samples,
          strips,
          ribbons,
          layers,
          position,
          color,
          closed,
          mask,
          material,
        })
      );
    }

    if (end) {
      this.arrows.push(
        this._renderables.make("arrow", {
          uniforms,
          samples,
          strips,
          ribbons,
          layers,
          position,
          color,
          closed,
          mask,
          material,
        })
      );
    }

    this._helpers.visible.make();
    return this._helpers.object.make(this.arrows.concat([this.line]));
  }

  made() {
    return this.resize();
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    this._helpers.object.unmake();

    return (this.line = this.arrows = null);
  }

  change(changed, _touched, _init) {
    if (
      changed["geometry.points"] ||
      changed["line.stroke"] ||
      changed["line.join"] ||
      changed["arrow.start"] ||
      changed["arrow.end"]
    ) {
      return this.rebuild();
    }

    if (changed["line.proximity"]) {
      if ((this.proximity != null) !== (this.props.proximity != null)) {
        return this.rebuild();
      }
    }
  }
}
Line.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/point.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Point extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "point",
      "geometry",
      "position",
      "bind",
      "shade",
    ];
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.point = null;
  }

  resize() {
    if (this.bind.points == null) {
      return;
    }

    const dims = this.bind.points.getActiveDimensions();
    const { items, width, height, depth } = dims;

    return this.point.geometry.clip(width, height, depth, items);
  }

  make() {
    // Bind to attached data sources
    let color, size;
    this._helpers.bind.make([
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
      { to: "point.sizes", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }

    // Build transform chain
    let position = this._shaders.shader();

    // Fetch position and transform to view
    position = this.bind.points.sourceShader(position);
    position = this._helpers.position.pipeline(position);

    // Fetch geometry dimensions
    const dims = this.bind.points.getDimensions();
    const { items, width, height, depth } = dims;

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const pointUniforms = this._helpers.point.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Build color lookup
    if (this.bind.colors) {
      color = this._shaders.shader();
      this.bind.colors.sourceShader(color);
    }

    // Build size lookup
    if (this.bind.sizes) {
      size = this._shaders.shader();
      this.bind.sizes.sourceShader(size);
    }

    // Build transition mask lookup
    const mask = this._helpers.object.mask();

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline() || false;

    // Point style
    const { shape } = this.props;
    const { fill } = this.props;
    const { optical } = this.props;

    // Make point renderable
    const uniforms = merge(unitUniforms, pointUniforms, styleUniforms);
    this.point = this._renderables.make("point", {
      uniforms,
      width,
      height,
      depth,
      items,
      position,
      color,
      size,
      shape,
      optical,
      fill,
      mask,
      material,
    });

    this._helpers.visible.make();
    this._helpers.object.make([this.point]);
  }

  made() {
    return this.resize();
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    this._helpers.object.unmake();

    this.point = null;
  }

  change(changed, _touched, _init) {
    if (
      changed["geometry.points"] ||
      changed["point.shape"] ||
      changed["point.fill"]
    ) {
      return this.rebuild();
    }
  }
}
Point.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/strip.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Strip extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "mesh",
      "strip",
      "geometry",
      "position",
      "bind",
      "shade",
    ];
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.strip = null;
  }

  resize() {
    if (this.bind.points == null) {
      return;
    }

    const dims = this.bind.points.getActiveDimensions();
    const { items, width, height, depth } = dims;

    if (this.strip) {
      this.strip.geometry.clip(width, height, depth, items);
    }
    if (this.line) {
      this.line.geometry.clip(items, width, height, depth);
    }

    if (this.bind.map != null) {
      const map = this.bind.map.getActiveDimensions();
      if (this.strip) {
        return this.strip.geometry.map(
          map.width,
          map.height,
          map.depth,
          map.items
        );
      }
    }
  }

  make() {
    // Bind to attached data sources
    let color, uniforms;
    this._helpers.bind.make([
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
      { to: "mesh.map", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }

    // Build transform chain
    let position = this._shaders.shader();

    // Fetch position
    position = this.bind.points.sourceShader(position);

    // Transform position to view
    position = this._helpers.position.pipeline(position);

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const lineUniforms = this._helpers.line.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Get display properties
    const { line, shaded, fill, stroke, join } = this.props;

    // Auto z-bias wireframe over surface
    const wireUniforms = {};
    wireUniforms.styleZBias = this._attributes.make(this._types.number());
    this.wireZBias = wireUniforms.styleZBias;

    // Fetch geometry dimensions
    const dims = this.bind.points.getDimensions();
    const { items, width, height, depth } = dims;

    // Build color lookup
    if (this.bind.colors) {
      color = this._shaders.shader();
      color = this.bind.colors.sourceShader(color);
    }

    // Build transition mask lookup
    const mask = this._helpers.object.mask();

    // Build texture map lookup
    this._helpers.shade.map(
      this.bind.map != null
        ? this.bind.map.sourceShader(this._shaders.shader())
        : undefined
    );

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline();
    const faceMaterial = material || shaded;
    const lineMaterial = material || false;

    const objects = [];

    // Make line renderable
    if (line) {
      // Swizzle strip edges into segments
      const swizzle = this._shaders.shader();
      swizzle.pipe(swizzleVec4("yzwx"));
      swizzle.pipe(position);

      uniforms = merge(
        unitUniforms,
        lineUniforms,
        styleUniforms,
        wireUniforms
      );

      this.line = this._renderables.make("line", {
        uniforms,
        samples: items,
        strips: width,
        ribbons: height,
        layers: depth,
        position: swizzle,
        color,
        stroke,
        join,
        mask,
        material: lineMaterial,
      });

      objects.push(this.line);
    }

    // Make strip renderable
    if (fill) {
      uniforms = merge(styleUniforms, {});

      this.strip = this._renderables.make("strip", {
        uniforms,
        width,
        height,
        depth,
        items,
        position,
        color,
        material: faceMaterial,
      });
      objects.push(this.strip);
    }

    this._helpers.visible.make();
    return this._helpers.object.make(objects);
  }

  made() {
    return this.resize();
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    this._helpers.object.unmake();

    return (this.strip = null);
  }

  change(changed, touched, init) {
    if (changed["geometry.points"] || touched["mesh"]) {
      return this.rebuild();
    }

    if (changed["style.zBias"] || changed["mesh.lineBias"] || init) {
      const { fill, zBias, lineBias } = this.props;
      return (this.wireZBias.value = zBias + (fill ? lineBias : 0));
    }
  }
}
Strip.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/surface.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Surface extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "mesh",
      "geometry",
      "surface",
      "position",
      "grid",
      "bind",
      "shade",
    ];
    this.defaults = {
      lineX: false,
      lineY: false,
    };
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.lineX = this.lineY = this.surface = null;
  }

  resize() {
    if (this.bind.points == null) {
      return;
    }

    const dims = this.bind.points.getActiveDimensions();
    const { width, height, depth, items } = dims;

    if (this.surface) {
      this.surface.geometry.clip(width, height, depth, items);
    }
    if (this.lineX) {
      this.lineX.geometry.clip(width, height, depth, items);
    }
    if (this.lineY) {
      this.lineY.geometry.clip(height, width, depth, items);
    }

    if (this.bind.map != null) {
      const map = this.bind.map.getActiveDimensions();
      if (this.surface) {
        return this.surface.geometry.map(
          map.width,
          map.height,
          map.depth,
          map.items
        );
      }
    }
  }

  make() {
    // Bind to attached data sources
    let color, normal;
    this._helpers.bind.make([
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
      { to: "mesh.normals", trait: "source" },
      { to: "mesh.map", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }

    // Build transform chain
    let position = this._shaders.shader();

    // Fetch position and transform to view
    position = this.bind.points.sourceShader(position);
    position = this._helpers.position.pipeline(position);

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const wireUniforms = this._helpers.style.uniforms();
    const lineUniforms = this._helpers.line.uniforms();
    const surfaceUniforms = this._helpers.surface.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Darken wireframe if needed for contrast
    // Auto z-bias wireframe over surface
    wireUniforms.styleColor = this._attributes.make(this._types.color());
    wireUniforms.styleZBias = this._attributes.make(this._types.number());
    this.wireColor = wireUniforms.styleColor.value;
    this.wireZBias = wireUniforms.styleZBias;
    this.wireScratch = new external_THREE_.Color();

    // Fetch geometry dimensions
    const dims = this.bind.points.getDimensions();
    const { width, height, depth, items } = dims;

    // Get display properties
    const {
      shaded,
      fill,
      lineX,
      lineY,
      closedX,
      closedY,
      stroke,
      join,
      proximity,
      crossed,
    } = this.props;
    const objects = [];
    this.proximity = proximity;

    // Fetch normals
    if (this.bind.normals != null) {
      normal = this._shaders.shader();
      this.bind.normals.sourceShader(normal);
      this._helpers.shade.normal(normal);
    }

    // Build color lookup
    if (this.bind.colors != null) {
      color = this._shaders.shader();
      this.bind.colors.sourceShader(color);
    }

    // Build transition mask lookup
    const mask = this._helpers.object.mask();

    // Build texture map lookup
    const map = this._helpers.shade.map(
      this.bind.map != null
        ? this.bind.map.sourceShader(this._shaders.shader())
        : undefined
    );

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline();
    const faceMaterial = material || shaded;
    const lineMaterial = material || false;

    // Make line and surface renderables
    const { swizzle, swizzle2 } = this._helpers.position;
    let uniforms = merge(
      unitUniforms,
      lineUniforms,
      styleUniforms,
      wireUniforms
    );
    const zUnits = lineX || lineY ? -50 : 0;
    if (lineX) {
      this.lineX = this._renderables.make("line", {
        uniforms,
        samples: width,
        strips: height,
        ribbons: depth,
        layers: items,
        position,
        color,
        normal,
        zUnits: -zUnits,
        stroke,
        join,
        mask,
        material: lineMaterial,
        proximity,
        closed: closedX || closed,
      });
      objects.push(this.lineX);
    }

    if (lineY) {
      this.lineY = this._renderables.make("line", {
        uniforms,
        samples: height,
        strips: width,
        ribbons: depth,
        layers: items,
        position: swizzle2(position, "yxzw", "yxzw"),
        color: swizzle(color, "yxzw"),
        zUnits: -zUnits,
        stroke,
        join,
        mask: swizzle(mask, crossed ? "xyzw" : "yxzw"),
        material: lineMaterial,
        proximity,
        closed: closedY || closed,
      });
      objects.push(this.lineY);
    }

    if (fill) {
      uniforms = merge(unitUniforms, surfaceUniforms, styleUniforms);
      this.surface = this._renderables.make("surface", {
        uniforms,
        width,
        height,
        surfaces: depth,
        layers: items,
        position,
        color,
        zUnits,
        stroke,
        material: faceMaterial,
        mask,
        map,
        intUV: true,
        closedX: closedX || closed,
        closedY: closedY || closed,
      });
      objects.push(this.surface);
    }

    this._helpers.visible.make();
    return this._helpers.object.make(objects);
  }

  made() {
    return this.resize();
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    this._helpers.object.unmake();

    return (this.lineX = this.lineY = this.surface = null);
  }

  _convertGammaToLinear(color, gammaFactor = 2.0) {
    color.r = Math.pow(color.r, gammaFactor);
    color.g = Math.pow(color.g, gammaFactor);
    color.b = Math.pow(color.b, gammaFactor);

    return color;
  }

  _convertLinearToGamma(color, gammaFactor = 2.0) {
    const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;

    color.r = Math.pow(color.r, safeInverse);
    color.g = Math.pow(color.g, safeInverse);
    color.b = Math.pow(color.b, safeInverse);

    return color;
  }

  change(changed, touched, init) {
    if (
      changed["geometry.points"] ||
      changed["mesh.shaded"] ||
      changed["mesh.fill"] ||
      changed["line.stroke"] ||
      changed["line.join"] ||
      touched["grid"]
    ) {
      return this.rebuild();
    }

    if (
      changed["style.color"] ||
      changed["style.zBias"] ||
      changed["mesh.fill"] ||
      changed["mesh.lineBias"] ||
      init
    ) {
      const { fill, color, zBias, lineBias } = this.props;

      this.wireZBias.value = zBias + (fill ? lineBias : 0);
      this.wireColor.copy(color);
      if (fill) {
        const c = this.wireScratch;
        c.setRGB(color.r, color.g, color.b);
        this._convertLinearToGamma(
          this._convertGammaToLinear(c).multiplyScalar(0.75)
        );
        this.wireColor.r = c.r;
        this.wireColor.g = c.g;
        this.wireColor.b = c.b;
      }
    }

    if (changed["line.proximity"]) {
      if ((this.proximity != null) !== (this.props.proximity != null)) {
        return this.rebuild();
      }
    }
  }
}
Surface.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/ticks.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Ticks extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "ticks",
      "geometry",
      "position",
      "bind",
      "shade",
    ];
  }

  init() {
    return (this.tickStrip = this.line = null);
  }

  resize() {
    if (this.bind.points == null) {
      return;
    }
    const dims = this.bind.points.getActiveDimensions();

    const active = +(dims.items > 0);
    const strips = dims.width * active;
    const ribbons = dims.height * active;
    const layers = dims.depth * active;

    this.line.geometry.clip(2, strips, ribbons, layers);
    return this.tickStrip.set(0, strips - 1);
  }

  make() {
    // Bind to attached data sources
    let color, position;
    this._helpers.bind.make([
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const lineUniforms = this._helpers.line.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();
    const uniforms = merge(lineUniforms, styleUniforms, unitUniforms);

    // Prepare position shader
    const positionUniforms = {
      tickEpsilon: this.node.attributes["ticks.epsilon"],
      tickSize: this.node.attributes["ticks.size"],
      tickNormal: this.node.attributes["ticks.normal"],
      tickStrip: this._attributes.make(this._types.vec2(0, 0)),
      worldUnit: uniforms.worldUnit,
      focusDepth: uniforms.focusDepth,
    };

    this.tickStrip = positionUniforms.tickStrip.value;

    // Build transform chain
    const p = (position = this._shaders.shader());

    // Require buffer sampler as callback
    p.require(this.bind.points.sourceShader(this._shaders.shader()));

    // Require view transform as callback
    p.require(this._helpers.position.pipeline(this._shaders.shader()));

    // Link to tick shader
    p.pipe("ticks.position", positionUniforms);

    // Stroke style
    const { stroke, join } = this.props;

    // Fetch geometry dimensions
    const dims = this.bind.points.getDimensions();
    const strips = dims.width;
    const ribbons = dims.height;
    const layers = dims.depth;

    // Build color lookup
    if (this.bind.colors) {
      color = this._shaders.shader();
      this.bind.colors.sourceShader(color);
    }

    // Build transition mask lookup
    const mask = this._helpers.object.mask();

    // Build fragment material lookup
    const material = this._helpers.shade.pipeline() || false;

    // Make line renderable
    const { swizzle } = this._helpers.position;
    this.line = this._renderables.make("line", {
      uniforms,
      samples: 2,
      strips,
      ribbons,
      layers,
      position,
      color,
      stroke,
      join,
      mask: swizzle(mask, "yzwx"),
      material,
    });

    this._helpers.visible.make();
    return this._helpers.object.make([this.line]);
  }

  made() {
    return this.resize();
  }

  unmake() {
    this.line = null;

    this._helpers.visible.unmake();
    return this._helpers.object.unmake();
  }

  change(changed, _touched, _init) {
    if (
      changed["geometry.points"] ||
      changed["line.stroke"] ||
      changed["line.join"]
    ) {
      return this.rebuild();
    }
  }
}
Ticks.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/vector.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Vector extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "style",
      "line",
      "arrow",
      "geometry",
      "position",
      "bind",
      "shade",
    ];
  }

  constructor(node, context, helpers) {
    super(node, context, helpers);

    this.line = this.arrows = null;
  }

  resize() {
    if (this.bind.points == null) {
      return;
    }
    const dims = this.bind.points.getActiveDimensions();

    const samples = dims.items;
    const strips = dims.width;
    const ribbons = dims.height;
    const layers = dims.depth;

    this.line.geometry.clip(samples, strips, ribbons, layers);
    return Array.from(this.arrows).map((arrow) =>
      arrow.geometry.clip(samples, strips, ribbons, layers)
    );
  }

  make() {
    // Bind to attached data sources
    let color;
    this._helpers.bind.make([
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }

    // Build transform chain
    let position = this._shaders.shader();

    // Fetch position
    this.bind.points.sourceShader(position);

    // Transform position to view
    this._helpers.position.pipeline(position);

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const lineUniforms = this._helpers.line.uniforms();
    const arrowUniforms = this._helpers.arrow.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Clip start/end for terminating arrow
    const { start, end } = this.props;

    // Stroke style
    const { stroke, join, proximity, closed } = this.props;
    this.proximity = proximity;

    // Fetch geometry dimensions
    const dims = this.bind.points.getDimensions();
    const samples = dims.items;
    const strips = dims.width;
    const ribbons = dims.height;
    const layers = dims.depth;

    // Build color lookup
    if (this.bind.colors) {
      color = this._shaders.shader();
      this.bind.colors.sourceShader(color);
    }

    // Build transition mask lookup
    let mask = this._helpers.object.mask();

    // Build fragment material lookup
    let material = this._helpers.shade.pipeline() || false;

    // Swizzle vector to line
    const { swizzle, swizzle2 } = this._helpers.position;
    position = swizzle2(position, "yzwx", "yzwx");
    color = swizzle(color, "yzwx");
    mask = swizzle(mask, "yzwx");
    material = swizzle(material, "yzwx");

    // Make line renderable
    const uniforms = merge(
      arrowUniforms,
      lineUniforms,
      styleUniforms,
      unitUniforms
    );
    this.line = this._renderables.make("line", {
      uniforms,
      samples,
      ribbons,
      strips,
      layers,
      position,
      color,
      clip: start || end,
      stroke,
      join,
      proximity,
      closed,
      mask,
      material,
    });

    // Make arrow renderables
    this.arrows = [];
    if (start) {
      this.arrows.push(
        this._renderables.make("arrow", {
          uniforms,
          flip: true,
          samples,
          ribbons,
          strips,
          layers,
          position,
          color,
          closed,
          mask,
          material,
        })
      );
    }

    if (end) {
      this.arrows.push(
        this._renderables.make("arrow", {
          uniforms,
          samples,
          ribbons,
          strips,
          layers,
          position,
          color,
          closed,
          mask,
          material,
        })
      );
    }

    this._helpers.visible.make();
    return this._helpers.object.make(this.arrows.concat([this.line]));
  }

  made() {
    return this.resize();
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    this._helpers.object.unmake();

    return (this.line = this.arrows = null);
  }

  change(changed, _touched, _init) {
    if (
      changed["geometry.points"] ||
      changed["line.stroke"] ||
      changed["line.join"] ||
      changed["arrow.start"] ||
      changed["arrow.end"]
    ) {
      return this.rebuild();
    }

    if (changed["line.proximity"]) {
      if ((this.proximity != null) !== (this.props.proximity != null)) {
        return this.rebuild();
      }
    }
  }
}
Vector.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/draw/index.js










;// CONCATENATED MODULE: ./src/primitives/types/overlay/html.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class HTML extends Voxel {
  static initClass() {
    this.traits = ["node", "buffer", "active", "data", "voxel", "html"];
    this.finals = { channels: 1 };
  }

  init() {
    super.init();
    this.storage = "pushBuffer";
  }

  make() {
    super.make();

    // Get our own size
    const { items, width, height, depth } = this.getDimensions();

    // Prepare DOM element factory
    this.dom = this._overlays.make("dom");
    return this.dom.hint(items * width * height * depth);
  }

  unmake() {
    super.unmake();
    if (this.dom != null) {
      this.dom.dispose();
      return (this.dom = null);
    }
  }

  update() {
    return super.update();
  }

  change(changed, touched, init) {
    if (touched["html"]) {
      return this.rebuild();
    }
    return super.change(changed, touched, init);
  }

  nodes() {
    return this.buffer.read();
  }

  callback(callback) {
    const { el } = this.dom;

    if (callback.length <= 6) {
      return (emit, i, j, k, l) => callback(emit, el, i, j, k, l);
    } else {
      return (emit, i, j, k, l) => {
        return callback(
          emit,
          el,
          i,
          j,
          k,
          l,
          this.bufferClock,
          this.bufferStep
        );
      };
    }
  }
}
HTML.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/overlay/dom.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class dom_DOM extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "object",
      "visible",
      "overlay",
      "dom",
      "attach",
      "position",
    ];
  }

  init() {
    this.emitter = this.root = null;
    this.active = {};
  }

  make() {
    super.make();

    // Bind to attached objects
    this._helpers.bind.make([
      { to: "dom.html", trait: "html" },
      { to: "dom.points", trait: "source" },
    ]);

    if (this.bind.points == null || this.bind.html == null) {
      return;
    }

    // Listen for updates
    this.root = this._inherit("root");
    this._listen("root", "root.update", this.update);
    this._listen("root", "root.post", this.post);

    // Fetch geometry dimensions
    const pointDims = this.bind.points.getDimensions();
    const htmlDims = this.bind.html.getDimensions();

    const items = Math.min(pointDims.items, htmlDims.items);
    const width = Math.min(pointDims.width, htmlDims.width);
    const height = Math.min(pointDims.height, htmlDims.height);
    const depth = Math.min(pointDims.depth, htmlDims.depth);

    // Build shader to sample position data
    let position = this.bind.points.sourceShader(this._shaders.shader());

    // Transform data into screen space
    position = this._helpers.position.pipeline(position);

    // Apply global projection
    const projection = this._shaders.shader({ globals: ["projectionMatrix"] });
    projection.pipe("project.readback");
    position.pipe(projection);

    // Build nop index shader
    const indexer = this._shaders.shader();

    // Prepare readback/memo RTT
    this.readback = this._renderables.make("readback", {
      map: position,
      indexer,
      items,
      width,
      height,
      depth,
      channels: 4,
      stpq: true,
    });

    // Prepare overlay container VDOM
    this.dom = this._overlays.make("dom");
    this.dom.hint(items * width * height * depth * 2);
    // Make sure we have enough for wrapping each given element once

    // Prepare readback consumer
    this.emitter = this.callback(this.bind.html.nodes());
    this.readback.setCallback(this.emitter);

    this._helpers.visible.make();
  }

  unmake() {
    if (this.readback != null) {
      this.readback.dispose();
      this.dom.dispose();
      this.readback = this.dom = null;

      this.root = null;
      this.emitter = null;
      this.active = {};
    }

    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
  }

  update() {
    if (this.readback == null) {
      return;
    }
    if (this.props.visible) {
      this.readback.update(
        this.root != null ? this.root.getCamera() : undefined
      );
      this.readback.post();
      this.readback.iterate();
    }
  }

  post() {
    if (this.readback == null) {
      return;
    }
    this.dom.render(this.isVisible ? this.emitter.nodes() : null);
  }

  callback(data) {
    // Create static consumer for the readback
    let strideJ, strideK;
    const uniforms = this._inherit("unit").getUnitUniforms();
    const width = uniforms.viewWidth;
    const height = uniforms.viewHeight;

    const attr = this.node.attributes["dom.attributes"];
    const size = this.node.attributes["dom.size"];
    const zoom = this.node.attributes["dom.zoom"];
    const color = this.node.attributes["dom.color"];
    const outline = this.node.attributes["dom.outline"];
    const pointer = this.node.attributes["dom.pointerEvents"];
    const opacity = this.node.attributes["overlay.opacity"];
    const zIndex = this.node.attributes["overlay.zIndex"];
    const offset = this.node.attributes["attach.offset"];
    const depth = this.node.attributes["attach.depth"];
    const snap = this.node.attributes["attach.snap"];
    const { el } = this.dom;

    let nodes = [];
    let styles = null;
    let className = null;

    let strideI = (strideJ = strideK = 0);
    let colorString = "";

    const f = function (x, y, z, w, i, j, k, l) {
      // Get HTML item by offset
      let v;
      const index = l + strideI * i + strideJ * j + strideK * k;
      const children = data[index];

      // Clip behind camera or when invisible
      const clip = w < 0;

      // Depth blending
      const iw = 1 / w;
      const flatZ = 1 + (iw - 1) * depth.value;
      const scale = clip ? 0 : flatZ;

      // GL to CSS coordinate transform
      const ox = +offset.value.x * scale;
      const oy = +offset.value.y * scale;
      let xx = (x + 1) * width.value * 0.5 + ox;
      let yy = (y - 1) * height.value * 0.5 + oy;

      // Handle zoom/scale
      xx /= zoom.value;
      yy /= zoom.value;

      // Snap to pixel
      if (snap.value) {
        xx = Math.round(xx);
        yy = Math.round(yy);
      }

      // Clip and apply opacity
      const alpha = Math.min(0.999, clip ? 0 : opacity.value);

      // Generate div
      const props = {
        className,
        style: {
          transform: `translate3d(${xx}px, ${-yy}px, ${
            1 - w
          }px) translate(-50%, -50%) scale(${scale},${scale})`,
          opacity: alpha,
        },
      };
      for (k in styles) {
        v = styles[k];
        props.style[k] = v;
      }

      // Merge in external attributes
      const a = attr.value;
      if (a != null) {
        const s = a.style;
        for (k in a) {
          v = a[k];
          if (!["style", "className"].includes(k)) {
            props[k] = v;
          }
        }
        if (s != null) {
          for (k in s) {
            v = s[k];
            props.style[k] = v;
          }
        }
      }
      props.className +=
        " " +
        ((a != null ? a.className : undefined) != null
          ? a != null
            ? a.className
            : undefined
          : "mathbox-label");

      // Push node onto list
      return nodes.push(el("div", props, children));
    };

    f.reset = () => {
      nodes = [];
      [strideI, strideJ, strideK] = Array.from([
        this.strideI,
        this.strideJ,
        this.strideK,
      ]);

      const c = color.value;
      const m = (x) => Math.floor(x * 255);
      colorString = c ? `rgb(${[m(c.x), m(c.y), m(c.z)]})` : "";

      className = `mathbox-outline-${Math.round(outline.value)}`;
      styles = {};
      if (c) {
        styles.color = colorString;
      }
      styles.fontSize = `${size.value}px`;
      if (zoom.value !== 1) {
        styles.zoom = zoom.value;
      }
      if (zIndex.value > 0) {
        styles.zIndex = zIndex.value;
      }
      if (pointer.value) {
        return (styles.pointerEvents = "auto");
      }
    };

    f.nodes = () => nodes;
    return f;
  }

  resize() {
    let sI, sJ;
    if (this.readback == null) {
      return;
    }

    // Fetch geometry/html dimensions
    const pointDims = this.bind.points.getActiveDimensions();
    const htmlDims = this.bind.html.getActiveDimensions();

    const items = Math.min(pointDims.items, htmlDims.items);
    const width = Math.min(pointDims.width, htmlDims.width);
    const height = Math.min(pointDims.height, htmlDims.height);
    const depth = Math.min(pointDims.depth, htmlDims.depth);

    // Limit readback to active area
    this.readback.setActive(items, width, height, depth);

    // Recalculate iteration strides
    this.strideI = sI = htmlDims.items;
    this.strideJ = sJ = sI * htmlDims.width;
    this.strideK = sJ * htmlDims.height;
  }

  change(changed, _touched, _init) {
    if (changed["dom.html"] || changed["dom.points"]) {
      return this.rebuild();
    }
  }
}
dom_DOM.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/overlay/index.js



;// CONCATENATED MODULE: ./src/primitives/types/text/text.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */







class Text extends Voxel {
  static initClass() {
    this.traits = [
      "node",
      "buffer",
      "active",
      "data",
      "texture",
      "voxel",
      "text",
      "font",
    ];
    this.defaults = {
      minFilter: "linear",
      magFilter: "linear",
    };
    this.finals = { channels: 1 };
  }

  init() {
    super.init();
    return (this.atlas = null);
  }

  textShader(shader) {
    return this.atlas.shader(shader);
  }

  textIsSDF() {
    return this.props.sdf > 0;
  }
  textHeight() {
    return this.props.detail;
  }

  make() {
    // Read sampling parameters
    let { minFilter, magFilter, type } = this.props;

    // Read font parameters
    const { font, style, variant, weight, detail, sdf } = this.props;

    // Prepare text atlas
    this.atlas = this._renderables.make("textAtlas", {
      font,
      size: detail,
      style,
      variant,
      weight,
      outline: sdf,
      minFilter,
      magFilter,
      type,
    });

    // Underlying data buffer needs no filtering
    this.minFilter = external_THREE_.NearestFilter;
    this.magFilter = external_THREE_.NearestFilter;
    this.type = external_THREE_.FloatType;

    // Skip voxel::make(), as we need 4 channels internally in our buffer to store sprite x/y/w/h per string
    Buffer.prototype.make.call(this);

    // Read sampling parameters
    minFilter = this.minFilter != null ? this.minFilter : this.props.minFilter;
    magFilter = this.magFilter != null ? this.magFilter : this.props.magFilter;
    type = this.type != null ? this.type : this.props.type;

    // Read given dimensions
    const { width } = this.props;
    const { height } = this.props;
    const { depth } = this.props;
    const reserveX = this.props.bufferWidth;
    const reserveY = this.props.bufferHeight;
    const reserveZ = this.props.bufferDepth;
    const { channels } = this.props;
    const { items } = this.props;

    let dims = (this.spec = { channels, items, width, height, depth });

    this.items = dims.items;
    this.channels = dims.channels;

    // Init to right size if data supplied
    const { data } = this.props;
    dims = getDimensions(data, dims);

    const { space } = this;
    space.width = Math.max(reserveX, dims.width || 1);
    space.height = Math.max(reserveY, dims.height || 1);
    space.depth = Math.max(reserveZ, dims.depth || 1);

    // Create text voxel buffer
    this.buffer = this._renderables.make(this.storage, {
      width: space.width,
      height: space.height,
      depth: space.depth,
      channels: 4,
      items,
      minFilter,
      magFilter,
      type,
    });

    // Hook buffer emitter to map atlas text
    const { atlas } = this;
    const { emit } = this.buffer.streamer;
    return (this.buffer.streamer.emit = (text) => atlas.map(text, emit));
  }

  unmake() {
    super.unmake();
    if (this.atlas) {
      this.atlas.dispose();
      return (this.atlas = null);
    }
  }

  update() {
    this.atlas.begin();
    super.update();
    return this.atlas.end();
  }

  change(changed, touched, init) {
    if (touched["font"]) {
      return this.rebuild();
    }
    return super.change(changed, touched, init);
  }
}
Text.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/operator.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Operator extends Source {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index"];
  }

  indexShader(shader) {
    return __guardMethod__(this.bind.source, "indexShader", (o) =>
      o.indexShader(shader)
    );
  }
  sourceShader(shader) {
    return __guardMethod__(this.bind.source, "sourceShader", (o) =>
      o.sourceShader(shader)
    );
  }

  getDimensions() {
    return this.bind.source.getDimensions();
  }
  getFutureDimensions() {
    return this.bind.source.getFutureDimensions();
  }
  getActiveDimensions() {
    return this.bind.source.getActiveDimensions();
  }
  getIndexDimensions() {
    return this.bind.source.getIndexDimensions();
  }

  init() {
    return (this.sourceSpec = [
      { to: "operator.source", trait: "source", optional: true },
    ]);
  }

  make() {
    super.make();

    // Bind to attached data sources
    return this._helpers.bind.make(this.sourceSpec);
  }

  made() {
    this.resize();
    return super.made();
  }

  unmake() {
    return this._helpers.bind.unmake();
  }

  resize(_rebuild) {
    return this.trigger({
      type: "source.resize",
    });
  }
}
Operator.initClass();

function __guardMethod__(obj, methodName, transform) {
  if (
    typeof obj !== "undefined" &&
    obj !== null &&
    typeof obj[methodName] === "function"
  ) {
    return transform(obj, methodName);
  } else {
    return undefined;
  }
}

;// CONCATENATED MODULE: ./src/primitives/types/text/format.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Format extends Operator {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "operator",
      "texture",
      "text",
      "format",
      "font",
    ];
    this.defaults = {
      minFilter: "linear",
      magFilter: "linear",
    };
  }

  init() {
    super.init();
    this.atlas = this.buffer = this.used = this.time = null;
    return (this.filled = false);
  }

  sourceShader(shader) {
    return this.buffer.shader(shader);
  }

  textShader(shader) {
    return this.atlas.shader(shader);
  }

  textIsSDF() {
    return this.props.sdf > 0;
  }

  textHeight() {
    return this.props.detail;
  }

  make() {
    // Bind to attached data sources    # super()
    this._helpers.bind.make([{ to: "operator.source", trait: "raw" }]);

    // Read sampling parameters
    let { minFilter, magFilter, type } = this.props;

    // Read font parameters
    const { font, style, variant, weight, detail, sdf } = this.props;

    // Prepare text atlas
    this.atlas = this._renderables.make("textAtlas", {
      font,
      size: detail,
      style,
      variant,
      weight,
      outline: sdf,
      minFilter,
      magFilter,
      type,
    });

    // Underlying data buffer needs no filtering
    minFilter = external_THREE_.NearestFilter;
    magFilter = external_THREE_.NearestFilter;
    type = external_THREE_.FloatType;

    // Fetch geometry dimensions
    const dims = this.bind.source.getDimensions();
    const { items, width, height, depth } = dims;

    // Create voxel buffer for text atlas coords
    this.buffer = this._renderables.make("voxelBuffer", {
      width,
      height,
      depth,
      channels: 4,
      items,
      minFilter,
      magFilter,
      type,
    });

    // Hook buffer emitter to map atlas text
    const { atlas } = this;
    const { emit } = this.buffer.streamer;
    this.buffer.streamer.emit = (t) => atlas.map(t, emit);

    // Grab parent clock
    this.clockParent = this._inherit("clock");
    return this._listen("root", "root.update", this.update);
  }

  made() {
    super.made();
    return this.resize();
  }

  unmake() {
    super.unmake();
    if (this.buffer) {
      this.buffer.dispose();
      this.buffer = null;
    }

    if (this.atlas) {
      this.atlas.dispose();
      return (this.atlas = null);
    }
  }

  update() {
    if ((this.filled && !this.props.live) || !this.through) {
      return;
    }

    this.time = this.clockParent.getTime();

    const { used } = this;

    this.atlas.begin();
    this.used = this.through();
    this.buffer.write(this.used);
    this.atlas.end();

    this.filled = true;

    if (used !== this.used) {
      return this.trigger({
        type: "source.resize",
      });
    }
  }

  change(changed, touched, init) {
    if (touched["font"]) {
      return this.rebuild();
    }

    if (
      changed["format.expr"] ||
      changed["format.digits"] ||
      changed["format.data"] ||
      init
    ) {
      let map;
      let { expr } = this.props;
      const { digits, data } = this.props;

      if (expr == null) {
        if (data != null) {
          expr = (x, y, z, w, i) => data[i];
        } else {
          expr = (x) => x;
        }
      }

      const { length } = expr;

      if (digits != null) {
        expr = (
          (expr) => (x, y, z, w, i, j, k, l, t, d) =>
            +expr(x, y, z, w, i, j, k, l, t, d).toPrecision(digits)
        )(expr);
      }

      // Stream raw source data and format it with expression
      if (length > 8) {
        map = (emit, x, y, z, w, i, j, k, l, _t, _d) => {
          return emit(
            expr(x, y, z, w, i, j, k, l, this.time.clock, this.time.step)
          );
        };
      } else {
        map = (emit, x, y, z, w, i, j, k, l) => {
          return emit(expr(x, y, z, w, i, j, k, l));
        };
      }

      return (this.through = this.bind.source
        .rawBuffer()
        .through(map, this.buffer));
    }
  }
}
Format.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/text/label.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Label extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "object",
      "visible",
      "style",
      "label",
      "attach",
      "geometry",
      "position",
    ];
  }

  make() {
    let color;
    super.make();

    // Bind to attached objects
    this._helpers.bind.make([
      { to: "label.text", trait: "text" },
      { to: "geometry.points", trait: "source" },
      { to: "geometry.colors", trait: "source" },
    ]);

    if (this.bind.points == null) {
      return;
    }
    if (this.bind.text == null) {
      return;
    }

    // Fetch geometry/text dimensions
    const pointDims = this.bind.points.getDimensions();
    const textDims = this.bind.text.getDimensions();
    const textIsSDF = this.bind.text.textIsSDF();

    const items = Math.min(pointDims.items, textDims.items);
    const width = Math.min(pointDims.width, textDims.width);
    const height = Math.min(pointDims.height, textDims.height);
    const depth = Math.min(pointDims.depth, textDims.depth);

    // Build shader to sample position data
    // and transform into screen space
    let position = this.bind.points.sourceShader(this._shaders.shader());
    position = this._helpers.position.pipeline(position);

    // Build shader to sample text geometry data
    const sprite = this.bind.text.sourceShader(this._shaders.shader());

    // Build shader to sample text image data
    const map = this._shaders.shader().pipe("label.map");
    map.pipe(this.bind.text.textShader(this._shaders.shader()));

    // Build shader to resolve text data
    const labelUniforms = {
      spriteDepth: this.node.attributes["attach.depth"],
      spriteOffset: this.node.attributes["attach.offset"],
      spriteSnap: this.node.attributes["attach.snap"],
      spriteScale: this._attributes.make(this._types.number()),
      outlineStep: this._attributes.make(this._types.number()),
      outlineExpand: this._attributes.make(this._types.number()),
      outlineColor: this.node.attributes["label.background"],
    };

    this.spriteScale = labelUniforms.spriteScale;
    this.outlineStep = labelUniforms.outlineStep;
    this.outlineExpand = labelUniforms.outlineExpand;

    const snippet = textIsSDF ? "label.outline" : "label.alpha";
    const combine = this._shaders.shader().pipe(snippet, labelUniforms);

    // Build color lookup
    if (this.bind.colors) {
      color = this._shaders.shader();
      this.bind.colors.sourceShader(color);
    }

    // Build transition mask lookup
    const mask = this._helpers.object.mask();

    // Prepare bound uniforms
    const styleUniforms = this._helpers.style.uniforms();
    const unitUniforms = this._inherit("unit").getUnitUniforms();

    // Make sprite renderable
    const uniforms = merge(unitUniforms, styleUniforms, labelUniforms);
    this.sprite = this._renderables.make("sprite", {
      uniforms,
      width,
      height,
      depth,
      items,
      position,
      sprite,
      map,
      combine,
      color,
      mask,
      linear: true,
    });

    this._helpers.visible.make();
    return this._helpers.object.make([this.sprite]);
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    this._helpers.object.unmake();

    return (this.sprite = null);
  }

  resize() {
    // Fetch geometry/text dimensions
    const pointDims = this.bind.points.getActiveDimensions();
    const textDims = this.bind.text.getActiveDimensions();

    const items = Math.min(pointDims.items, textDims.items);
    const width = Math.min(pointDims.width, textDims.width);
    const height = Math.min(pointDims.height, textDims.height);
    const depth = Math.min(pointDims.depth, textDims.depth);

    return this.sprite.geometry.clip(width, height, depth, items);
  }

  change(changed, touched, _init) {
    if (touched["geometry"] || changed["label.text"]) {
      return this.rebuild();
    }
    if (this.bind.points == null) {
      return;
    }

    const { size } = this.props;
    const { outline } = this.props;
    const { expand } = this.props;
    const height = this.bind.text.textHeight();
    const scale = size / height;

    this.outlineExpand.value = ((expand / scale) * 16) / 255;
    this.outlineStep.value = ((outline / scale) * 16) / 255;
    return (this.spriteScale.value = scale);
  }
}
Label.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/resample.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Resample extends Operator {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "operator",
      "source",
      "index",
      "resample",
      "sampler:x",
      "sampler:y",
      "sampler:z",
      "sampler:w",
      "include",
    ];
  }

  indexShader(shader) {
    shader.pipe(this.indexer);
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    return shader.pipe(this.operator);
  }

  getDimensions() {
    return this._resample(this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._resample(this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._resample(this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._resample(this.bind.source.getIndexDimensions());
  }

  _resample(dims) {
    const r = this.resampled;
    const c = this.centered;
    const p = this.padding;

    if (this.relativeSize) {
      if (!c.items) {
        dims.items--;
      }
      if (!c.width) {
        dims.width--;
      }
      if (!c.height) {
        dims.height--;
      }
      if (!c.depth) {
        dims.depth--;
      }

      if (r.items != null) {
        dims.items *= r.items;
      }
      if (r.width != null) {
        dims.width *= r.width;
      }
      if (r.height != null) {
        dims.height *= r.height;
      }
      if (r.depth != null) {
        dims.depth *= r.depth;
      }

      if (!c.items) {
        dims.items++;
      }
      if (!c.width) {
        dims.width++;
      }
      if (!c.height) {
        dims.height++;
      }
      if (!c.depth) {
        dims.depth++;
      }

      dims.items -= p.items * 2;
      dims.width -= p.width * 2;
      dims.height -= p.height * 2;
      dims.depth -= p.depth * 2;
    } else {
      if (r.items != null) {
        dims.items = r.items;
      }
      if (r.width != null) {
        dims.width = r.width;
      }
      if (r.height != null) {
        dims.height = r.height;
      }
      if (r.depth != null) {
        dims.depth = r.depth;
      }
    }

    dims.items = Math.max(0, Math.floor(dims.items));
    dims.width = Math.max(0, Math.floor(dims.width));
    dims.height = Math.max(0, Math.floor(dims.height));
    dims.depth = Math.max(0, Math.floor(dims.depth));

    return dims;
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Bind to attached shader
    this._helpers.bind.make([
      { to: "include.shader", trait: "shader", optional: true },
    ]);

    // Get custom shader
    const { indices, channels } = this.props;
    const { shader } = this.bind;

    // Get resampled dimensions (if any)
    const { sample, size, items, width, height, depth } = this.props;

    // Sampler behavior
    const relativeSample =
      sample === this.node.attributes["resample.sample"].enum.relative;
    const relativeSize =
      size === this.node.attributes["resample.size"].enum.relative;

    this.resampled = {};
    if (items != null) {
      this.resampled.items = items;
    }
    if (width != null) {
      this.resampled.width = width;
    }
    if (height != null) {
      this.resampled.height = height;
    }
    if (depth != null) {
      this.resampled.depth = depth;
    }

    this.centered = {};
    this.centered.items = this.props.centeredW;
    this.centered.width = this.props.centeredX;
    this.centered.height = this.props.centeredY;
    this.centered.depth = this.props.centeredZ;

    this.padding = {};
    this.padding.items = this.props.paddingW;
    this.padding.width = this.props.paddingX;
    this.padding.height = this.props.paddingY;
    this.padding.depth = this.props.paddingZ;

    // Build shader to resample data
    const operator = this._shaders.shader();
    const indexer = this._shaders.shader();

    // Uniforms
    const type = [
      null,
      this._types.number,
      this._types.vec2,
      this._types.vec3,
      this._types.vec4,
    ][indices];
    const uniforms = {
      dataSize: this._attributes.make(type(0, 0, 0, 0)),
      dataResolution: this._attributes.make(type(0, 0, 0, 0)),

      targetSize: this._attributes.make(type(0, 0, 0, 0)),
      targetResolution: this._attributes.make(type(0, 0, 0, 0)),

      resampleFactor: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
      resampleBias: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
    };

    this.dataResolution = uniforms.dataResolution;
    this.dataSize = uniforms.dataSize;
    this.targetResolution = uniforms.targetResolution;
    this.targetSize = uniforms.targetSize;
    this.resampleFactor = uniforms.resampleFactor;
    this.resampleBias = uniforms.resampleBias;

    // Has resize props?
    const resize =
      items != null || width != null || height != null || depth != null;

    // Add padding
    operator.pipe("resample.padding", uniforms);

    // Add centered sampling offset
    let vec = [];
    let any = false;
    const iterable = ["width", "height", "depth", "items"];
    for (let i = 0; i < iterable.length; i++) {
      const key = iterable[i];
      const centered = this.centered[key];
      if (!any) {
        any = centered;
      }
      vec[i] = centered ? "0.5" : "0.0";
    }

    if (any) {
      vec = `vec4(${vec})`;
      // TODO is this right? seems like copy paste.
      operator.pipe(binaryOperator(4, "+", vec));
      if (resize) {
        indexer.pipe(binaryOperator(4, "+", vec));
      }
    }

    if (relativeSample) {
      // Addressing relative to target
      if (resize) {
        operator.pipe("resample.relative", uniforms);
        indexer.pipe("resample.relative", uniforms);
      } else {
        indexer.pipe(identity("vec4"));
      }
    }

    if (shader != null) {
      if (indices !== 4) {
        operator.pipe(truncateVec(4, indices));
      }

      operator.callback();
      if (indices !== 4) {
        operator.pipe(extendVec(indices, 4));
      }
      if (any) {
        operator.pipe(binaryOperator(4, "-", vec));
      }
      operator.pipe(this.bind.source.sourceShader(this._shaders.shader()));
      if (channels !== 4) {
        operator.pipe(truncateVec(4, channels));
      }
      operator.join();

      if (this.bind.shader != null) {
        operator.pipe(this.bind.shader.shaderBind(uniforms));
      }

      if (channels !== 4) {
        operator.pipe(extendVec(channels, 4));
      }
    } else {
      if (any) {
        operator.pipe(binaryOperator(4, "-", vec));
      }
      operator.pipe(this.bind.source.sourceShader(this._shaders.shader()));
    }

    if (any && resize) {
      indexer.pipe(binaryOperator(4, "-", vec));
    }

    this.operator = operator;
    this.indexer = indexer;
    this.indices = indices;

    this.relativeSample = relativeSample;
    return (this.relativeSize = relativeSize);
  }

  unmake() {
    super.unmake();
    return (this.operator = null);
  }

  resize() {
    if (this.bind.source == null) {
      return;
    }

    const dims = this.bind.source.getActiveDimensions();
    const target = this.getActiveDimensions();

    const axis = (key) => {
      const centered = this.centered[key];
      const pad = this.padding[key];

      target[key] += pad * 2;

      const res = centered
        ? dims[key] / Math.max(1, target[key])
        : Math.max(1, dims[key] - 1) / Math.max(1, target[key] - 1);
      return [res, pad];
    };

    const [rw, bw] = Array.from(axis("width"));
    const [rh, bh] = Array.from(axis("height"));
    const [rd, bd] = Array.from(axis("depth"));
    const [ri, bi] = Array.from(axis("items"));

    if (this.indices === 1) {
      this.dataResolution.value = 1 / dims.width;
      this.targetResolution.value = 1 / target.width;

      this.dataSize.value = dims.width;
      this.targetSize.value = target.width;
    } else {
      this.dataResolution.value.set(
        1 / dims.width,
        1 / dims.height,
        1 / dims.depth,
        1 / dims.items
      );
      this.targetResolution.value.set(
        1 / target.width,
        1 / target.height,
        1 / target.depth,
        1 / target.items
      );

      this.dataSize.value.set(dims.width, dims.height, dims.depth, dims.items);
      this.targetSize.value.set(
        target.width,
        target.height,
        target.depth,
        target.items
      );
    }

    this.resampleFactor.value.set(rw, rh, rd, ri);
    this.resampleBias.value.set(bw, bh, bd, bi);

    return super.resize();
  }

  change(changed, touched, _init) {
    if (
      touched["operator"] ||
      touched["resample"] ||
      touched["sampler"] ||
      touched["include"]
    ) {
      return this.rebuild();
    }
  }
}
Resample.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/text/retext.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Retext extends Resample {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "operator",
      "resample",
      "sampler:x",
      "sampler:y",
      "sampler:z",
      "sampler:w",
      "include",
      "text",
    ];
  }

  init() {
    return (this.sourceSpec = [{ to: "operator.source", trait: "text" }]);
  }

  textShader(shader) {
    return this.bind.source.textShader(shader);
  }

  textIsSDF() {
    return (
      (this.bind.source != null ? this.bind.source.props.sdf : undefined) > 0
    );
  }
  textHeight() {
    return this.bind.source != null ? this.bind.source.props.detail : undefined;
  }
}
Retext.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/text/index.js





;// CONCATENATED MODULE: ./src/primitives/types/time/clock.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Clock extends Parent {
  static initClass() {
    this.traits = ["node", "clock", "seek", "play"];
  }

  init() {
    this.skew = 0;
    this.last = 0;
    return (this.time = {
      now: +new Date() / 1000,
      time: 0,
      delta: 0,
      clock: 0,
      step: 0,
    });
  }

  make() {
    // Listen to parent clock
    return this._listen("clock", "clock.tick", this.tick);
  }

  reset() {
    return (this.skew = 0);
  }

  tick(e) {
    const { from, to, speed, seek, pace, delay, realtime } = this.props;

    const parent = this._inherit("clock").getTime();

    const time = realtime ? parent.time : parent.clock;
    const delta = realtime ? parent.delta : parent.step;
    const ratio = speed / pace;

    this.skew += delta * (ratio - 1);
    if (this.last > time) {
      this.skew = 0;
    }

    this.time.now = parent.now + this.skew;

    this.time.time = parent.time;
    this.time.delta = parent.delta;

    const clock = seek != null ? seek : parent.clock + this.skew;
    this.time.clock = Math.min(to, from + Math.max(0, clock - delay * ratio));
    this.time.step = delta * ratio;

    this.last = time;

    return this.trigger(e);
  }

  getTime() {
    return this.time;
  }
}
Clock.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/time/now.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Now extends Parent {
  static initClass() {
    this.traits = ["node", "clock", "now"];
  }

  init() {
    let now;
    this.now = now = +new Date() / 1000;
    this.skew = 0;
    return (this.time = {
      now,
      time: 0,
      delta: 0,
      clock: 0,
      step: 0,
    });
  }

  make() {
    // Listen to parent clock
    this.clockParent = this._inherit("clock");
    return this._listen("clock", "clock.tick", this.tick);
  }

  unmake() {
    return (this.clockParent = null);
  }

  change(changed, _touched, _init) {
    if (changed["date.now"]) {
      return (this.skew = 0);
    }
  }

  tick(e) {
    const { seek, pace, speed } = this.props;

    const parent = this.clockParent.getTime();

    this.skew += (parent.step * pace) / speed;
    if (seek != null) {
      this.skew = seek;
    }

    this.time.now =
      this.time.time =
      this.time.clock =
        (this.props.now != null ? this.props.now : this.now) + this.skew;
    this.time.delta = this.time.step = parent.delta;

    return this.trigger(e);
  }

  getTime() {
    return this.time;
  }
}
Now.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/time/index.js



;// CONCATENATED MODULE: ./src/primitives/types/transform/transform.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Transform extends Parent {
  static initClass() {
    this.traits = ["node", "vertex", "fragment"];
  }

  vertex(shader, pass) {
    let left;
    return (left = transform_guard_(this._inherit("vertex"), (x) =>
      x.vertex(shader, pass)
    )) != null
      ? left
      : shader;
  }

  fragment(shader, pass) {
    let left;
    return (left = transform_guard_(this._inherit("fragment"), (x) =>
      x.fragment(shader, pass)
    )) != null
      ? left
      : shader;
  }
}
Transform.initClass();

function transform_guard_(value, xform) {
  return typeof value !== "undefined" && value !== null
    ? xform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/primitives/types/transform/transform3.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Transform3 extends Transform {
  static initClass() {
    this.traits = ["node", "vertex", "transform3"];
  }

  make() {
    this.uniforms = {
      transformMatrix: this._attributes.make(this._types.mat4()),
    };

    return (this.composer = transformComposer());
  }

  unmake() {
    return delete this.uniforms;
  }

  change(changed, touched, init) {
    if (changed["transform3.pass"]) {
      return this.rebuild();
    }
    if (!touched["transform3"] && !init) {
      return;
    }

    const p = this.props.position;
    const q = this.props.quaternion;
    const r = this.props.rotation;
    const s = this.props.scale;
    const m = this.props.matrix;
    const e = this.props.eulerOrder;

    return (this.uniforms.transformMatrix.value = this.composer(
      p,
      r,
      q,
      s,
      m,
      e
    ));
  }

  vertex(shader, pass) {
    if (pass === this.props.pass) {
      shader.pipe("transform3.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }
}
Transform3.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/transform/transform4.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Transform4 extends Transform {
  static initClass() {
    this.traits = ["node", "vertex", "transform4"];
  }

  make() {
    this.uniforms = {
      transformMatrix: this._attributes.make(this._types.mat4()),
      transformOffset: this.node.attributes["transform4.position"],
    };

    return (this.transformMatrix = this.uniforms.transformMatrix.value);
  }

  unmake() {
    return delete this.uniforms;
  }

  change(changed, touched, init) {
    if (changed["transform4.pass"]) {
      return this.rebuild();
    }
    if (!touched["transform4"] && !init) {
      return;
    }

    const s = this.props.scale;
    const m = this.props.matrix;

    const t = this.transformMatrix;
    t.copy(m);
    return t.scale(s);
  }

  vertex(shader, pass) {
    if (pass === this.props.pass) {
      shader.pipe("transform4.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }
}
Transform4.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/transform/vertex.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Vertex extends Transform {
  static initClass() {
    this.traits = ["node", "include", "vertex", "bind"];
  }

  make() {
    // Bind to attached shader
    return this._helpers.bind.make([
      { to: "include.shader", trait: "shader", optional: true },
    ]);
  }

  unmake() {
    return this._helpers.bind.unmake();
  }

  change(changed, touched, _init) {
    if (touched["include"]) {
      return this.rebuild();
    }
  }

  vertex(shader, pass) {
    if (this.bind.shader != null) {
      if (pass === this.props.pass) {
        shader.pipe(this.bind.shader.shaderBind());
      }
    }
    return super.vertex(shader, pass);
  }
}
Vertex.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/transform/fragment.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Fragment extends Transform {
  static initClass() {
    this.traits = ["node", "include", "fragment", "bind"];
  }

  make() {
    // Bind to attached shader
    return this._helpers.bind.make([
      { to: "include.shader", trait: "shader", optional: true },
    ]);
  }

  unmake() {
    return this._helpers.bind.unmake();
  }

  change(changed, touched, _init) {
    if (touched["include"] || changed["fragment.gamma"]) {
      return this.rebuild();
    }
  }

  fragment(shader, pass) {
    if (this.bind.shader != null) {
      if (pass === this.props.pass) {
        if (this.props.gamma) {
          shader.pipe("mesh.gamma.out");
        }
        shader.pipe(this.bind.shader.shaderBind());
        shader.split();
        if (this.props.gamma) {
          shader.pipe("mesh.gamma.in");
        }
        shader.pass();
      }
    }
    return super.fragment(shader, pass);
  }
}
Fragment.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/transform/layer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Layer extends Transform {
  static initClass() {
    this.traits = ["node", "vertex", "layer"];
  }

  make() {
    this._listen("root", "root.resize", this.update);

    return (this.uniforms = {
      layerScale: this._attributes.make(this._types.vec4()),
      layerBias: this._attributes.make(this._types.vec4()),
    });
  }

  update() {
    const camera = this._inherit("root").getCamera();

    const aspect = camera.aspect != null ? camera.aspect : 1;
    const fov = camera.fov != null ? camera.fov : 1;

    const pitch = Math.tan((fov * Math.PI) / 360);

    const _enum = this.node.attributes["layer.fit"].enum;

    let { fit } = this.props;
    const { depth } = this.props;

    // Convert contain/cover into x/y
    switch (fit) {
      case _enum.contain:
        fit = aspect > 1 ? _enum.y : _enum.x;
        break;
      case _enum.cover:
        fit = aspect > 1 ? _enum.x : _enum.y;
        break;
    }

    // Fit x/y
    switch (fit) {
      case _enum.x:
        this.uniforms.layerScale.value.set(
          pitch * aspect,
          pitch * aspect,
          1,
          1
        );
        break;
      case _enum.y:
        this.uniforms.layerScale.value.set(pitch, pitch, 1, 1);
        break;
    }

    return this.uniforms.layerBias.value.set(0, 0, -depth, 0);
  }

  change(changed, touched, init) {
    if (changed["layer.fit"] || changed["layer.depth"] || init) {
      return this.update();
    }
  }

  // End transform chain here without applying camera view
  vertex(shader, pass) {
    if (pass === 2) {
      return shader.pipe("layer.position", this.uniforms);
    }
    if (pass === 3) {
      return shader.pipe("root.position");
    }
    return shader;
  }
}
Layer.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/transform/mask.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Mask extends Parent {
  static initClass() {
    this.traits = ["node", "include", "mask", "bind"];
  }

  make() {
    // Bind to attached shader
    return this._helpers.bind.make([
      { to: "include.shader", trait: "shader", optional: true },
    ]);
  }

  unmake() {
    return this._helpers.bind.unmake();
  }

  change(changed, touched, _init) {
    if (touched["include"]) {
      return this.rebuild();
    }
  }

  mask(shader) {
    let left, s;
    if (this.bind.shader != null) {
      if (shader) {
        s = this._shaders.shader();
        s.pipe(identity("vec4"));
        s.fan();
        s.pipe(shader);
        s.next();
        s.pipe(this.bind.shader.shaderBind());
        s.end();
        s.pipe("float combine(float a, float b) { return min(a, b); }");
      } else {
        s = this._shaders.shader();
        s.pipe(this.bind.shader.shaderBind());
      }
    } else {
      s = shader;
    }

    return (left = mask_guard_(this._inherit("mask"), (x) => x.mask(s))) != null
      ? left
      : s;
  }
}
Mask.initClass();

function mask_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/primitives/types/transform/index.js








;// CONCATENATED MODULE: ./src/primitives/types/operator/clamp.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Clamp extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "clamp"];
  }

  indexShader(shader) {
    shader.pipe(this.operator);
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    shader.pipe(this.operator);
    return super.sourceShader(shader);
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Max index on all 4 dimensions
    const uniforms = { clampLimit: this._attributes.make(this._types.vec4()) };
    this.clampLimit = uniforms.clampLimit;

    // Build shader to clamp along all dimensions
    const transform = this._shaders.shader();
    transform.pipe("clamp.position", uniforms);
    return (this.operator = transform);
  }

  unmake() {
    return super.unmake();
  }

  resize() {
    if (this.bind.source != null) {
      const dims = this.bind.source.getActiveDimensions();
      this.clampLimit.value.set(
        dims.width - 1,
        dims.height - 1,
        dims.depth - 1,
        dims.items - 1
      );
    }

    return super.resize();
  }

  change(changed, touched, _init) {
    if (touched["operator"] || touched["clamp"]) {
      return this.rebuild();
    }
  }
}
Clamp.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/grow.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Grow extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "grow"];
  }

  sourceShader(shader) {
    return shader.pipe(this.operator);
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Uniforms
    const uniforms = {
      growScale: this.node.attributes["grow.scale"],
      growMask: this._attributes.make(this._types.vec4()),
      growAnchor: this._attributes.make(this._types.vec4()),
    };

    this.growMask = uniforms.growMask.value;
    this.growAnchor = uniforms.growAnchor.value;

    // Build shader to spread data on one dimension
    const transform = this._shaders.shader();
    transform.require(this.bind.source.sourceShader(this._shaders.shader()));
    transform.pipe("grow.position", uniforms);

    return (this.operator = transform);
  }

  unmake() {
    return super.unmake();
  }

  resize() {
    this.update();
    return super.resize();
  }

  update() {
    // Size to fit to include future history
    const dims = this.bind.source.getFutureDimensions();

    const order = ["width", "height", "depth", "items"];

    const m = (d, anchor) => ((d || 1) - 1) * (0.5 - anchor * 0.5);

    return (() => {
      const result = [];
      for (let i = 0; i < order.length; i++) {
        const key = order[i];
        const anchor = this.props[key];

        this.growMask.setComponent(i, +(anchor == null));
        result.push(
          this.growAnchor.setComponent(
            i,
            anchor != null ? m(dims[key], anchor) : 0
          )
        );
      }
      return result;
    })();
  }

  change(changed, touched, _init) {
    if (touched["operator"]) {
      return this.rebuild();
    }

    if (touched["grow"]) {
      return this.update();
    }
  }
}
Grow.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/join.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
split:
  order:       Types.transpose('wxyz')
  axis:        Types.axis()
  overlap:     Types.int(0)
*/

class Join extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "join"];
  }

  indexShader(shader) {
    shader.pipe(this.operator);
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    shader.pipe(this.operator);
    return super.sourceShader(shader);
  }

  getDimensions() {
    return this._resample(this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._resample(this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._resample(this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._resample(this.bind.source.getIndexDimensions());
  }

  _resample(dims) {
    let left;
    let dim;
    const { order, axis, stride } = this;

    const labels = ["width", "height", "depth", "items"];
    const mapped = order.map((x) => labels[x - 1]);
    const index = order.indexOf(axis);
    let set = (() => {
      const result = [];
      for (dim of Array.from(mapped)) {
        result.push(dims[dim]);
      }
      return result;
    })();
    const product = ((left = set[index + 1]) != null ? left : 1) * stride;

    set.splice(index, 2, product);
    set = set.slice(0, 3);
    set.push(1);

    const out = {};
    for (let i = 0; i < mapped.length; i++) {
      dim = mapped[i];
      out[dim] = set[i];
    }

    //console.log 'join', order, axis, length, stride
    //console.log dims, out

    return out;
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    const { order } = this.props;
    let { axis } = this.props;
    let { overlap } = this.props;

    /*
    Calculate index transform

    order: wxyz
    length: 3
    overlap: 1

    axis: w
    index: 0
    rest: 00xy

    axis: x
    index: 1
    rest: w00y

    axis: y
    index: 2
    rest: wx00

    axis: z
    index: 3
    rest: wxy0

    */

    const permute = order.join("");
    if (axis == null) {
      axis = order[0];
    }
    const index = permute.indexOf(axis);
    const rest = permute.replace(axis, "00").substring(0, 4);

    const labels = [null, "width", "height", "depth", "items"];
    const major = labels[axis];

    // Prepare uniforms
    const dims = this.bind.source.getDimensions();
    const length = dims[major];

    overlap = Math.min(length - 1, overlap);
    const stride = length - overlap;

    const uniforms = {
      joinStride: this._attributes.make(this._types.number(stride)),
      joinStrideInv: this._attributes.make(this._types.number(1 / stride)),
    };

    // Build shader to split a dimension into two
    const transform = this._shaders.shader();
    transform.require(swizzleVec4(axis, 1));
    transform.require(swizzleVec4(rest, 4));
    transform.require(injectVec4([index, index + 1]));
    transform.pipe("join.position", uniforms);
    transform.pipe(invertSwizzleVec4(order));

    this.operator = transform;

    this.order = order;
    this.axis = axis;
    this.overlap = overlap;
    this.length = length;
    return (this.stride = stride);
  }

  unmake() {
    return super.unmake();
  }

  change(changed, touched, _init) {
    if (touched["join"] || touched["operator"]) {
      return this.rebuild();
    }
  }
}
Join.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/lerp.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Lerp extends Operator {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "operator",
      "source",
      "index",
      "lerp",
      "sampler:x",
      "sampler:y",
      "sampler:z",
      "sampler:w",
    ];
  }

  indexShader(shader) {
    shader.pipe(this.indexer);
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    return shader.pipe(this.operator);
  }

  getDimensions() {
    return this._resample(this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._resample(this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._resample(this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._resample(this.bind.source.getIndexDimensions());
  }

  _resample(dims) {
    const r = this.resampled;
    const c = this.centered;
    const p = this.padding;

    if (this.relativeSize) {
      if (!c.items) {
        dims.items--;
      }
      if (!c.width) {
        dims.width--;
      }
      if (!c.height) {
        dims.height--;
      }
      if (!c.depth) {
        dims.depth--;
      }

      if (r.items != null) {
        dims.items *= r.items;
      }
      if (r.width != null) {
        dims.width *= r.width;
      }
      if (r.height != null) {
        dims.height *= r.height;
      }
      if (r.depth != null) {
        dims.depth *= r.depth;
      }

      if (!c.items) {
        dims.items++;
      }
      if (!c.width) {
        dims.width++;
      }
      if (!c.height) {
        dims.height++;
      }
      if (!c.depth) {
        dims.depth++;
      }

      dims.items -= p.items * 2;
      dims.width -= p.width * 2;
      dims.height -= p.height * 2;
      dims.depth -= p.depth * 2;
    } else {
      if (r.items != null) {
        dims.items = r.items;
      }
      if (r.width != null) {
        dims.width = r.width;
      }
      if (r.height != null) {
        dims.height = r.height;
      }
      if (r.depth != null) {
        dims.depth = r.depth;
      }
    }

    dims.items = Math.max(0, Math.floor(dims.items));
    dims.width = Math.max(0, Math.floor(dims.width));
    dims.height = Math.max(0, Math.floor(dims.height));
    dims.depth = Math.max(0, Math.floor(dims.depth));

    return dims;
  }

  make() {
    let i, key;
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Get resampled dimensions
    const { size, items, width, height, depth } = this.props;

    // Sampler behavior
    const relativeSize =
      size === this.node.attributes["lerp.size"].enum.relative;

    this.resampled = {};
    if (items != null) {
      this.resampled.items = items;
    }
    if (width != null) {
      this.resampled.width = width;
    }
    if (height != null) {
      this.resampled.height = height;
    }
    if (depth != null) {
      this.resampled.depth = depth;
    }

    this.centered = {};
    this.centered.items = this.props.centeredW;
    this.centered.width = this.props.centeredX;
    this.centered.height = this.props.centeredY;
    this.centered.depth = this.props.centeredZ;

    this.padding = {};
    this.padding.items = this.props.paddingW;
    this.padding.width = this.props.paddingX;
    this.padding.height = this.props.paddingY;
    this.padding.depth = this.props.paddingZ;

    // Build shader to resample data
    const operator = this._shaders.shader();
    const indexer = this._shaders.shader();

    // Uniforms
    const uniforms = {
      resampleFactor: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
      resampleBias: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
    };

    this.resampleFactor = uniforms.resampleFactor;
    this.resampleBias = uniforms.resampleBias;

    // Has resize props?
    const resize =
      items != null || width != null || height != null || depth != null;

    // Add padding
    operator.pipe("resample.padding", uniforms);

    // Prepare centered sampling offset
    const vec = [];
    let any = false;
    const iterable = ["width", "height", "depth", "items"];
    for (i = 0; i < iterable.length; i++) {
      key = iterable[i];
      const centered = this.centered[key];
      if (!any) {
        any = centered;
      }
      vec[i] = centered ? "0.5" : "0.0";
    }

    let vec4;

    // Add centered sampling offset (from source)
    if (any && resize) {
      vec4 = `vec4(${vec})`;
      operator.pipe(binaryOperator(4, "+", vec4));
      indexer.pipe(binaryOperator(4, "+", vec4));
    }

    // Addressing relative to target
    if (resize) {
      operator.pipe("resample.relative", uniforms);
      indexer.pipe("resample.relative", uniforms);
    } else {
      operator.pipe(identity("vec4"));
      indexer.pipe(identity("vec4"));
    }

    // Remove centered sampling offset (to target)
    if (any && resize) {
      operator.pipe(binaryOperator(4, "-", vec4));
      indexer.pipe(binaryOperator(4, "-", vec4));
    }

    // Make sampler
    let sampler = this.bind.source.sourceShader(this._shaders.shader());

    // Iterate over dimensions (items, width, height, depth)
    const iterable1 = ["width", "height", "depth", "items"];
    for (i = 0; i < iterable1.length; i++) {
      key = iterable1[i];
      const id = `lerp.${key}`;

      if (this.props[key] != null) {
        sampler = this._shaders.shader().require(sampler);
        sampler.pipe(id, uniforms);
      }
    }

    // Combine operator and composite lerp sampler
    operator.pipe(sampler);

    this.operator = operator;
    this.indexer = indexer;

    return (this.relativeSize = relativeSize);
  }

  unmake() {
    super.unmake();
    return (this.operator = null);
  }

  resize() {
    if (this.bind.source == null) {
      return;
    }

    const dims = this.bind.source.getActiveDimensions();
    const target = this.getActiveDimensions();

    const axis = (key) => {
      const centered = this.centered[key];
      const pad = this.padding[key];

      target[key] += pad * 2;

      const res = centered
        ? dims[key] / Math.max(1, target[key])
        : Math.max(1, dims[key] - 1) / Math.max(1, target[key] - 1);
      return [res, pad];
    };

    const [rw, bw] = Array.from(axis("width"));
    const [rh, bh] = Array.from(axis("height"));
    const [rd, bd] = Array.from(axis("depth"));
    const [ri, bi] = Array.from(axis("items"));

    this.resampleFactor.value.set(rw, rh, rd, ri);
    this.resampleBias.value.set(bw, bh, bd, bi);

    return super.resize();
  }

  change(changed, touched, _init) {
    if (touched["operator"] || touched["lerp"] || touched["sampler"]) {
      return this.rebuild();
    }
  }
}
Lerp.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/memo.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Memo extends Operator {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "active",
      "operator",
      "source",
      "index",
      "texture",
      "memo",
    ];
  }

  sourceShader(shader) {
    return this.memo.shaderAbsolute(shader, 1);
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Listen for updates
    this._helpers.active.make();
    this._listen("root", "root.update", () => {
      if (this.isActive) {
        return this.update();
      }
    });

    // Read sampling parameters
    const { minFilter, magFilter, type } = this.props;

    // Fetch geometry dimensions
    const dims = this.bind.source.getDimensions();
    const { items, width, height, depth } = dims;

    // Prepare memoization RTT
    this.memo = this._renderables.make("memo", {
      items,
      width,
      height,
      depth,
      minFilter,
      magFilter,
      type,
    });

    // Build shader to remap data (do it after RTT creation to allow feedback)
    const operator = this._shaders.shader();
    this.bind.source.sourceShader(operator);

    // Make screen renderable inside RTT scene
    this.compose = this._renderables.make("memoScreen", {
      map: operator,
      items,
      width,
      height,
      depth,
    });
    this.memo.adopt(this.compose);

    this.objects = [this.compose];
    return (this.renders = this.compose.renders);
  }

  unmake() {
    this._helpers.active.unmake();

    if (this.bind.source != null) {
      this.memo.unadopt(this.compose);
      this.memo.dispose();
      this.memo = this.compose = null;

      super.unmake();
    }
  }

  update() {
    return this.memo != null ? this.memo.render() : undefined;
  }

  resize() {
    if (this.bind.source == null) {
      return;
    }

    // Fetch geometry dimensions
    const dims = this.bind.source.getActiveDimensions();
    const { width, height, depth } = dims;

    // Cover only part of the RTT viewport
    this.compose.cover(width, height, depth);

    return super.resize();
  }

  change(changed, touched, _init) {
    if (touched["texture"] || touched["operator"]) {
      return this.rebuild();
    }
  }
}
Memo.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/readback.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Readback extends Primitive {
  static initClass() {
    this.traits = ["node", "bind", "operator", "readback", "entity", "active"];
    this.finals = { channels: 4 };
  }

  init() {
    this.emitter = this.root = null;
    return (this.active = {});
  }

  make() {
    super.make();

    this._compute("readback.data", () =>
      this.readback != null ? this.readback.data : undefined
    );
    this._compute("readback.items", () =>
      this.readback != null ? this.readback.items : undefined
    );
    this._compute("readback.width", () =>
      this.readback != null ? this.readback.width : undefined
    );
    this._compute("readback.height", () =>
      this.readback != null ? this.readback.height : undefined
    );
    this._compute("readback.depth", () =>
      this.readback != null ? this.readback.depth : undefined
    );

    // Bind to attached objects
    this._helpers.bind.make([{ to: "operator.source", trait: "source" }]);

    if (this.bind.source == null) {
      return;
    }

    // Sampler props
    const { type, channels, expr } = this.props;

    // Listen for updates
    this.root = this._inherit("root");
    this._listen("root", "root.update", this.update);

    // Fetch source dimensions
    const { items, width, height, depth } = this.bind.source.getDimensions();

    // Build shader to sample source data
    const sampler = this.bind.source.sourceShader(this._shaders.shader());

    // Prepare readback/memo RTT
    this.readback = this._renderables.make("readback", {
      map: sampler,
      items,
      width,
      height,
      depth,
      channels,
      type,
    });

    // Prepare readback consumer
    if (expr != null) {
      this.readback.setCallback(expr);
    }

    this._helpers.active.make();
  }

  unmake() {
    if (this.readback != null) {
      this.readback.dispose();
      this.readback = null;

      this.root = null;
      this.emitter = null;
      this.active = {};
    }

    this._helpers.active.unmake();
    return this._helpers.bind.unmake();
  }

  update() {
    if (this.readback == null) {
      return;
    }
    if (this.isActive) {
      this.readback.update(
        this.root != null ? this.root.getCamera() : undefined
      );
      this.readback.post();
      if (this.props.expr != null) {
        this.readback.iterate();
      }
    }
  }

  resize() {
    let sI, sJ;
    if (this.readback == null) {
      return;
    }

    // Fetch geometry/html dimensions
    const { items, width, height, depth } =
      this.bind.source.getActiveDimensions();

    // Limit readback to active area
    this.readback.setActive(items, width, height, depth);

    // Recalculate iteration strides
    this.strideI = sI = items;
    this.strideJ = sJ = sI * width;
    return (this.strideK = sJ * height);
  }

  change(changed, _touched, _init) {
    if (changed["readback.type"]) {
      return this.rebuild();
    }

    if (changed["readback.expr"] && this.readback) {
      return this.readback.setCallback(this.props.expr);
    }
  }
}
Readback.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/repeat.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Repeat extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "repeat"];
  }

  indexShader(shader) {
    shader.pipe(this.operator);
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    shader.pipe(this.operator);
    return super.sourceShader(shader);
  }

  getDimensions() {
    return this._resample(this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._resample(this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._resample(this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._resample(this.bind.source.getIndexDimensions());
  }

  _resample(dims) {
    const r = this.resample;
    return {
      items: r.items * dims.items,
      width: r.width * dims.width,
      height: r.height * dims.height,
      depth: r.depth * dims.depth,
    };
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Repeat multipliers
    this.resample = {};

    // Modulus on all 4 dimensions
    const uniforms = {
      repeatModulus: this._attributes.make(this._types.vec4()),
    };
    this.repeatModulus = uniforms.repeatModulus;

    // Build shader to repeat along all dimensions
    const transform = this._shaders.shader();
    transform.pipe("repeat.position", uniforms);
    return (this.operator = transform);
  }

  unmake() {
    return super.unmake();
  }

  resize() {
    if (this.bind.source != null) {
      const dims = this.bind.source.getActiveDimensions();
      this.repeatModulus.value.set(
        dims.width,
        dims.height,
        dims.depth,
        dims.items
      );
    }

    return super.resize();
  }

  change(changed, touched, init) {
    if (touched["operator"] || touched["repeat"]) {
      return this.rebuild();
    }

    if (init) {
      return ["items", "width", "height", "depth"].map(
        (key) => (this.resample[key] = this.props[key])
      );
    }
  }
}
Repeat.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/reverse.js


class Reverse extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "reverse"];
  }

  getDimensions() {
    return this.bind.source.getDimensions();
  }
  getActiveDimensions() {
    return this.bind.source.getActiveDimensions();
  }
  getFutureDimensions() {
    return this.bind.source.getFutureDimensions();
  }
  getIndexDimensions() {
    return this.bind.source.getIndexDimensions();
  }

  sourceShader(shader) {
    shader.pipe("reverse.position", this.uniforms);
    return this.bind.source.sourceShader(shader);
  }

  _resolveScale(key, _dims) {
    const range = this.props[key];
    return range ? -1 : 1;
  }

  _resolveOffset(key, dims) {
    const range = this.props[key];
    const dim = dims[key];
    if (range) {
      return dim - 1;
    } else {
      return 0;
    }
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    return (this.uniforms = {
      reverseScale: this._attributes.make(this._types.vec4()),
      reverseOffset: this._attributes.make(this._types.vec4()),
    });
  }

  unmake() {
    return super.unmake();
  }

  resize() {
    if (this.bind.source == null) {
      return;
    }

    const dims = this.bind.source.getActiveDimensions();

    this.uniforms.reverseScale.value.set(
      this._resolveScale("width", dims),
      this._resolveScale("height", dims),
      this._resolveScale("depth", dims),
      this._resolveScale("items", dims)
    );

    this.uniforms.reverseOffset.value.set(
      this._resolveOffset("width", dims),
      this._resolveOffset("height", dims),
      this._resolveOffset("depth", dims),
      this._resolveOffset("items", dims)
    );

    return super.resize();
  }

  change(_changed, touched, _init) {
    if (touched["operator"]) {
      return this.rebuild();
    }

    if (touched["reverse"]) {
      return this.resize();
    }
  }
}
Reverse.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/swizzle.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Swizzle extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "swizzle"];
  }

  sourceShader(shader) {
    shader = super.sourceShader(shader);
    if (this.swizzler) {
      shader.pipe(this.swizzler);
    }
    return shader;
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Swizzling order
    const { order } = this.props;
    if (order.join() !== "1234") {
      return (this.swizzler = swizzleVec4(order, 4));
    }
  }

  unmake() {
    super.unmake();
    return (this.swizzler = null);
  }

  change(changed, touched, _init) {
    if (touched["swizzle"] || touched["operator"]) {
      return this.rebuild();
    }
  }
}
Swizzle.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/spread.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Spread extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "spread"];
  }

  sourceShader(shader) {
    return shader.pipe(this.operator);
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Uniforms
    const uniforms = {
      spreadMatrix: this._attributes.make(this._types.mat4()),
      spreadOffset: this._attributes.make(this._types.vec4()),
    };

    this.spreadMatrix = uniforms.spreadMatrix;
    this.spreadOffset = uniforms.spreadOffset;

    // Build shader to spread data on one dimension
    const transform = this._shaders.shader();
    transform.require(this.bind.source.sourceShader(this._shaders.shader()));
    transform.pipe("spread.position", uniforms);

    return (this.operator = transform);
  }

  unmake() {
    return super.unmake();
  }

  resize() {
    this.update();
    return super.resize();
  }

  update() {
    // Size to fit to include future history
    let key, i, k, v;
    const dims = this.bind.source.getFutureDimensions();

    const matrix = this.spreadMatrix.value;
    const els = matrix.elements;

    const order = ["width", "height", "depth", "items"];
    const align = ["alignWidth", "alignHeight", "alignDepth", "alignItems"];

    const { unit } = this.props;
    const unitEnum = this.node.attributes["spread.unit"].enum;

    const map = (() => {
      switch (unit) {
        case unitEnum.relative:
          return (key, i, k, v) =>
            (els[i * 4 + k] = v / Math.max(1, dims[key] - 1));
        case unitEnum.absolute:
          return (key, i, k, v) => (els[i * 4 + k] = v);
      }
    })();

    return (() => {
      const result = [];
      for (i = 0; i < order.length; i++) {
        let offset;
        key = order[i];
        const spread = this.props[key];
        const anchor = this.props[align[i]];

        if (spread != null) {
          const d = dims[key] != null ? dims[key] : 1;
          offset = -(d - 1) * (0.5 - anchor * 0.5);
        } else {
          offset = 0;
        }
        this.spreadOffset.value.setComponent(i, offset);

        result.push(
          (() => {
            const result1 = [];
            for (k = 0; k <= 3; k++) {
              let left;
              v =
                (left = spread != null ? spread.getComponent(k) : undefined) !=
                null
                  ? left
                  : 0;
              result1.push((els[i * 4 + k] = map(key, i, k, v)));
            }
            return result1;
          })()
        );
      }
      return result;
    })();
  }

  change(changed, touched, _init) {
    if (touched["operator"]) {
      return this.rebuild();
    }

    if (touched["spread"]) {
      return this.update();
    }
  }
}
Spread.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/split.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
split:
  order:       Types.transpose('wxyz')
  axis:        Types.axis()
  length:      Types.int(1)
  overlap:     Types.int(0)
*/

class Split extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "split"];
  }

  indexShader(shader) {
    shader.pipe(this.operator);
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    shader.pipe(this.operator);
    return super.sourceShader(shader);
  }

  getDimensions() {
    return this._resample(this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._resample(this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._resample(this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._resample(this.bind.source.getIndexDimensions());
  }

  _resample(dims) {
    let dim;
    const { order } = this;
    const { axis } = this;
    const { overlap } = this;
    const { length } = this;
    const { stride } = this;

    const labels = ["width", "height", "depth", "items"];
    const mapped = order.map((x) => labels[x - 1]);
    const index = order.indexOf(axis);
    let set = (() => {
      const result = [];
      for (dim of Array.from(mapped)) {
        result.push(dims[dim]);
      }
      return result;
    })();
    const remain = Math.floor((set[index] - overlap) / stride);

    set.splice(index, 1, length, remain);
    set = set.slice(0, 4);

    const out = {};
    for (let i = 0; i < mapped.length; i++) {
      dim = mapped[i];
      out[dim] = set[i];
    }

    //console.log 'split', order, axis, length, stride
    //console.log dims, out

    return out;
  }

  make() {
    let left;
    super.make();
    if (this.bind.source == null) {
      return;
    }

    const { order } = this.props;
    let { axis } = this.props;
    let { overlap } = this.props;
    const { length } = this.props;

    /*
    Calculate index transform

    order: wxyz
    length: 3
    overlap: 1

    axis: w
    index: 0
    split: wx
    rest:  0yz0
           s

    axis: x
    index: 1
    split: xy
    rest:  w0z0
            s

    axis: y
    index: 2
    split: yz
    rest:  wx00
             s

    axis: z
    index: 3
    split: z0
    rest: wxy0
             s

    */

    const permute = order.join("");
    if (axis == null) {
      axis = order[0];
    }

    const index = permute.indexOf(axis);
    const split =
      permute[index] + ((left = permute[index + 1]) != null ? left : 0);
    const rest = permute.replace(split[1], "").replace(split[0], "0") + "0";

    // Prepare uniforms
    overlap = Math.min(length - 1, overlap);
    const stride = length - overlap;

    const uniforms = {
      splitStride: this._attributes.make(this._types.number(stride)),
    };

    // Build shader to split a dimension into two
    const transform = this._shaders.shader();
    transform.require(swizzleVec4(split, 2));
    transform.require(swizzleVec4(rest, 4));
    transform.require(injectVec4(index));
    transform.pipe("split.position", uniforms);
    transform.pipe(invertSwizzleVec4(order));

    this.operator = transform;

    this.order = order;
    this.axis = axis;
    this.overlap = overlap;
    this.length = length;
    return (this.stride = stride);
  }

  unmake() {
    return super.unmake();
  }

  change(changed, touched, _init) {
    if (
      changed["split.axis"] ||
      changed["split.order"] ||
      touched["operator"]
    ) {
      return this.rebuild();
    }
  }
}
Split.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/slice.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Slice extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "slice"];
  }

  getDimensions() {
    return this._resample(this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._resample(this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._resample(this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._resample(this.bind.source.getIndexDimensions());
  }

  sourceShader(shader) {
    shader.pipe("slice.position", this.uniforms);
    return this.bind.source.sourceShader(shader);
  }

  _resolve(key, dims) {
    const range = this.props[key];
    const dim = dims[key];
    if (range == null) {
      return [0, dim];
    }

    const index = function (i, dim) {
      if (i < 0) {
        return dim + i;
      } else {
        return i;
      }
    };

    const start = index(Math.round(range.x), dim);
    let end = index(Math.round(range.y), dim);

    end = Math.max(start, end);
    return [start, end - start];
  }

  _resample(dims) {
    dims.width = this._resolve("width", dims)[1];
    dims.height = this._resolve("height", dims)[1];
    dims.depth = this._resolve("depth", dims)[1];
    dims.items = this._resolve("items", dims)[1];
    return dims;
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    return (this.uniforms = {
      sliceOffset: this._attributes.make(this._types.vec4()),
    });
  }

  unmake() {
    return super.unmake();
  }

  resize() {
    if (this.bind.source == null) {
      return;
    }

    const dims = this.bind.source.getActiveDimensions();

    this.uniforms.sliceOffset.value.set(
      this._resolve("width", dims)[0],
      this._resolve("height", dims)[0],
      this._resolve("depth", dims)[0],
      this._resolve("items", dims)[0]
    );

    return super.resize();
  }

  change(changed, touched, _init) {
    if (touched["operator"]) {
      return this.rebuild();
    }

    if (touched["slice"]) {
      return this.resize();
    }
  }
}
Slice.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/subdivide.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Subdivide extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "subdivide"];
  }

  indexShader(shader) {
    shader.pipe(this.indexer);
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    return shader.pipe(this.operator);
  }

  getDimensions() {
    return this._resample(this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._resample(this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._resample(this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._resample(this.bind.source.getIndexDimensions());
  }

  _resample(dims) {
    const r = this.resampled;

    dims.items--;
    dims.width--;
    dims.height--;
    dims.depth--;

    if (r.items != null) {
      dims.items *= r.items;
    }
    if (r.width != null) {
      dims.width *= r.width;
    }
    if (r.height != null) {
      dims.height *= r.height;
    }
    if (r.depth != null) {
      dims.depth *= r.depth;
    }

    dims.items++;
    dims.width++;
    dims.height++;
    dims.depth++;

    return dims;
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Get resampled dimensions
    let { lerp } = this.props;
    const { items, width, height, depth } = this.props;

    this.resampled = {};
    if (items != null) {
      this.resampled.items = items;
    }
    if (width != null) {
      this.resampled.width = width;
    }
    if (height != null) {
      this.resampled.height = height;
    }
    if (depth != null) {
      this.resampled.depth = depth;
    }

    // Build shader to resample data
    const operator = this._shaders.shader();
    const indexer = this._shaders.shader();

    // Uniforms
    const uniforms = {
      resampleFactor: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
      subdivideBevel: this.node.attributes["subdivide.bevel"],
    };

    this.resampleFactor = uniforms.resampleFactor;
    this.resampleBias = uniforms.resampleBias;

    // Has resize props?
    const resize =
      items != null || width != null || height != null || depth != null;

    // Addressing relative to target
    if (resize) {
      operator.pipe("resample.relative", uniforms);
      indexer.pipe("resample.relative", uniforms);
    } else {
      operator.pipe(identity("vec4"));
      indexer.pipe(identity("vec4"));
    }

    // Make sampler
    let sampler = this.bind.source.sourceShader(this._shaders.shader());
    lerp = lerp ? ".lerp" : "";

    // Iterate over dimensions (items, width, height, depth)
    const iterable = ["width", "height", "depth", "items"];
    for (let i = 0; i < iterable.length; i++) {
      const key = iterable[i];
      const id = `subdivide.${key}${lerp}`;

      if (this.props[key] != null) {
        sampler = this._shaders.shader().require(sampler);
        sampler.pipe(id, uniforms);
      }
    }

    // Combine operator and composite lerp sampler
    operator.pipe(sampler);

    this.operator = operator;
    return (this.indexer = indexer);
  }

  unmake() {
    super.unmake();
    return (this.operator = null);
  }

  resize() {
    if (this.bind.source == null) {
      return;
    }

    const dims = this.bind.source.getActiveDimensions();
    const target = this.getActiveDimensions();

    const axis = (key) =>
      Math.max(1, dims[key] - 1) / Math.max(1, target[key] - 1);

    const rw = axis("width");
    const rh = axis("height");
    const rd = axis("depth");
    const ri = axis("items");

    this.resampleFactor.value.set(rw, rh, rd, ri);

    return super.resize();
  }

  change(changed, touched, _init) {
    if (touched["operator"] || touched["subdivide"]) {
      return this.rebuild();
    }
  }
}
Subdivide.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/transpose.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




const labels = {
  1: "width",
  2: "height",
  3: "depth",
  4: "items",
};

class Transpose extends Operator {
  static initClass() {
    this.traits = ["node", "bind", "operator", "source", "index", "transpose"];
  }

  indexShader(shader) {
    if (this.swizzler) {
      shader.pipe(this.swizzler);
    }
    return super.indexShader(shader);
  }

  sourceShader(shader) {
    if (this.swizzler) {
      shader.pipe(this.swizzler);
    }
    return super.sourceShader(shader);
  }

  getDimensions() {
    return this._remap(this.transpose, this.bind.source.getDimensions());
  }
  getActiveDimensions() {
    return this._remap(this.transpose, this.bind.source.getActiveDimensions());
  }
  getFutureDimensions() {
    return this._remap(this.transpose, this.bind.source.getFutureDimensions());
  }
  getIndexDimensions() {
    return this._remap(this.transpose, this.bind.source.getIndexDimensions());
  }

  _remap(transpose, dims) {
    // Map dimensions onto their new axis
    const out = {};

    for (let i = 0; i <= 3; i++) {
      const dst = labels[i + 1];
      const src = labels[transpose[i]];
      out[dst] = dims[src] != null ? dims[src] : 1;
    }

    return out;
  }

  make() {
    super.make();
    if (this.bind.source == null) {
      return;
    }

    // Transposition order
    const { order } = this.props;
    if (order.join() !== "1234") {
      this.swizzler = invertSwizzleVec4(order);
    }
    this.transpose = order;

    // Notify of reallocation
    return this.trigger({
      type: "source.rebuild",
    });
  }

  unmake() {
    super.unmake();
    return (this.swizzler = null);
  }

  change(changed, touched, _init) {
    if (touched["transpose"] || touched["operator"]) {
      return this.rebuild();
    }
  }
}
Transpose.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/operator/index.js
















;// CONCATENATED MODULE: ./src/primitives/types/present/transition.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Transition extends Parent {
  static initClass() {
    this.traits = [
      "node",
      "transition",
      "transform",
      "mask",
      "visible",
      "active",
    ];
  }

  init() {
    this.animate = null;
    this.uniforms = null;

    this.state = {
      isVisible: true,
      isActive: true,
      enter: 1,
      exit: 1,
    };

    this.latched = null;
    return (this.locked = null);
  }

  make() {
    this.uniforms = {
      transitionFrom: this._attributes.make(this._types.vec4()),
      transitionTo: this._attributes.make(this._types.vec4()),

      transitionActive: this._attributes.make(this._types.bool()),
      transitionScale: this._attributes.make(this._types.vec4()),
      transitionBias: this._attributes.make(this._types.vec4()),
      transitionEnter: this._attributes.make(this._types.number()),
      transitionExit: this._attributes.make(this._types.number()),
      transitionSkew: this._attributes.make(this._types.number()),
    };

    const slideParent = this._inherit("slide");
    const visibleParent = this._inherit("visible");
    const activeParent = this._inherit("active");

    this._listen(slideParent, "transition.latch", (e) => this.latch(e.step));
    this._listen(slideParent, "transition.release", () => this.release());

    this._listen(visibleParent, "visible.change", () => {
      //console.log @node.toString(), 'visible.change ^', visibleParent.isVisible
      return this.update((this.state.isVisible = visibleParent.isVisible));
    });

    this._listen(activeParent, "active.change", () => {
      //console.log @node.toString(), 'active.change ^', activeParent.isActive
      return this.update((this.state.isActive = activeParent.isActive));
    });

    this.animate = this._animator.make(this._types.vec2(1, 1), {
      step: (value) => {
        this.state.enter = value.x;
        this.state.exit = value.y;
        return this.update();
      },
      complete: (done) => this.complete(done),
    });

    return (this.move = this.props.from != null || this.props.to != null);
  }

  //@_helpers.visible.make()
  //@_helpers.active.make()

  unmake() {
    return this.animate.dispose();
  }

  //@_helpers.visible.unmake()
  //@_helpers.active.unmake()

  latch(step) {
    let latched;
    this.locked = null;
    this.latched = latched = {
      isVisible: this.state.isVisible,
      isActive: this.state.isActive,
      step,
    };

    // Reset enter/exit animation if invisible
    const visible = this.isVisible;
    if (!visible) {
      const forward = latched.step >= 0;
      const [enter, exit] = Array.from(forward ? [0, 1] : [1, 0]);
      return this.animate.set(enter, exit);
    }
  }

  //console.log @node.toString(), 'transition::latch', @latched, enter, exit

  release() {
    // Get before/after and unlatch state
    const { latched } = this;
    const { state } = this;
    this.latched = null;

    //console.log @node.toString(), 'transition::release', JSON.parse JSON.stringify {latched, state}

    //p = @; console.log '-> ', p.node.toString(), p.isVisible while p = p._inherit 'visible'

    // Transition if visibility state change
    if (latched.isVisible !== state.isVisible) {
      // Maintain step direction
      const forward = latched.step >= 0;
      const visible = state.isVisible;
      const [enter, exit] = Array.from(
        visible ? [1, 1] : forward ? [1, 0] : [0, 1]
      );

      // Get duration
      let { duration, durationEnter, durationExit } = this.props;
      if (durationEnter == null) {
        durationEnter = duration;
      }
      if (durationExit == null) {
        durationExit = duration;
      }
      duration = visible * durationEnter + !visible * durationExit;

      // Get delay
      let { delay, delayEnter, delayExit } = this.props;
      if (delayEnter == null) {
        delayEnter = delay;
      }
      if (delayExit == null) {
        delayExit = delay;
      }
      delay = visible * delayEnter + !visible * delayExit;

      // Animate enter/exit
      //console.log @node.toString(), '@animate.immediate', {x: enter, y: exit}, {duration, delay, ease: 'linear'}
      this.animate.immediate(
        { x: enter, y: exit },
        { duration, delay, ease: "linear" }
      );

      // Lock visibility and active open during transition
      this.locked = {
        isVisible: true,
        isActive: latched.isActive || state.isActive,
      };
    }

    return this.update();
  }

  complete(done) {
    if (!done) {
      return;
    }
    this.locked = null;
    return this.update();
  }

  update() {
    if (this.latched != null) {
      return;
    } // latched

    let { enter, exit } = this.props;

    // Resolve transition state
    if (enter == null) {
      ({ enter } = this.state);
    }
    if (exit == null) {
      ({ exit } = this.state);
    }

    const level = enter * exit;
    let visible = level > 0;
    const partial = level < 1;

    this.uniforms.transitionEnter.value = enter;
    this.uniforms.transitionExit.value = exit;
    this.uniforms.transitionActive.value = partial;

    // Resolve visibility state
    if (visible) {
      visible = !!this.state.isVisible;
    }
    if (this.locked != null) {
      visible = this.locked.isVisible;
    }

    if (this.isVisible !== visible) {
      this.isVisible = visible;
      this.trigger({ type: "visible.change" });
    }

    // Resolve active state
    const active = !!(
      this.state.isActive ||
      (this.locked != null ? this.locked.isActive : undefined)
    );

    if (this.isActive !== active) {
      this.isActive = active;
      return this.trigger({ type: "active.change" });
    }
  }

  //console.log 'transition update', 'enter', enter, 'exit', exit, 'visible', visible, 'active', active

  change(changed, touched, init) {
    if (changed["transition.enter"] || changed["transition.exit"] || init) {
      this.update();
    }

    if (changed["transition.stagger"] || init) {
      const { stagger } = this.props;

      // Precompute shader constants

      const flipX = stagger.x < 0;
      const flipY = stagger.y < 0;
      const flipZ = stagger.z < 0;
      const flipW = stagger.w < 0;

      const staggerX = Math.abs(stagger.x);
      const staggerY = Math.abs(stagger.y);
      const staggerZ = Math.abs(stagger.z);
      const staggerW = Math.abs(stagger.w);

      this.uniforms.transitionSkew.value =
        staggerX + staggerY + staggerZ + staggerW;

      this.uniforms.transitionScale.value.set(
        (1 - flipX * 2) * staggerX,
        (1 - flipY * 2) * staggerY,
        (1 - flipZ * 2) * staggerZ,
        (1 - flipW * 2) * staggerW
      );

      return this.uniforms.transitionBias.value.set(
        flipX * staggerX,
        flipY * staggerY,
        flipZ * staggerZ,
        flipW * staggerW
      );
    }
  }
}
Transition.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/present/move.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Move extends Transition {
  static initClass() {
    this.traits = ["node", "transition", "vertex", "move", "visible", "active"];
  }

  make() {
    super.make();

    const object = {
      moveFrom: this.node.attributes["move.from"],
      moveTo: this.node.attributes["move.to"],
    };
    for (const k in object) {
      const v = object[k];
      this.uniforms[k] = v;
    }
  }

  vertex(shader, pass) {
    let left;
    if (pass === this.props.pass) {
      shader.pipe("move.position", this.uniforms);
    }
    return (left = move_guard_(this._inherit("vertex"), (x) =>
      x.vertex(shader, pass)
    )) != null
      ? left
      : shader;
  }
}
Move.initClass();

function move_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/util/ease.js
function clamp(x, a, b) {
  return Math.max(a, Math.min(b, x));
}

function cosine(x) {
  return 0.5 - 0.5 * Math.cos(clamp(x, 0, 1) * Math.PI);
}

function binary(x) {
  return +(x >= 0.5);
}

function hold(x) {
  return +(x >= 1);
}

;// CONCATENATED MODULE: ./src/primitives/types/present/track.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




const deepCopy = function (x) {
  const out = {};
  for (const k in x) {
    const v = x[k];
    if (v instanceof Array) {
      out[k] = v.slice();
    } else if (v != null && typeof v === "object") {
      out[k] = deepCopy(v);
    } else {
      out[k] = v;
    }
  }

  return out;
};

class Track extends Primitive {
  static initClass() {
    this.traits = ["node", "track", "seek", "bind"];
  }

  init() {
    this.handlers = {};
    this.script = null;
    this.values = null;
    this.playhead = 0;
    this.velocity = null;
    this.section = null;
    return (this.expr = null);
  }

  make() {
    // Bind to attached data sources
    let ref;
    this._helpers.bind.make([
      { to: "track.target", trait: "node", callback: null },
    ]);

    const { script } = this.props;
    const { node } = this.bind.target;

    this.targetNode = node;
    return (
      ([this.script, this.values, this.start, this.end] = Array.from(
        (ref = this._process(node, script))
      )),
      ref
    );
  }

  unmake() {
    this.unbindExpr();
    this._helpers.bind.unmake();
    this.script =
      this.values =
      this.start =
      this.end =
      this.section =
      this.expr =
        null;
    return (this.playhead = 0);
  }

  // Bind animated expressions
  bindExpr(expr) {
    this.unbindExpr();
    this.expr = expr;
    this.targetNode.bind(expr, true);

    // Measure playhead velocity on attribute computation
    const { clock } = this.targetNode;
    const self = this;
    return this._attributes.bind(
      (this.measure = (function () {
        let playhead = null;
        return () => {
          const { step } = clock.getTime();
          if (playhead != null) {
            self.velocity = (self.playhead - playhead) / step;
          }
          return (playhead = self.playhead);
        };
      })())
    );
  }

  unbindExpr() {
    if (this.expr != null) {
      this.targetNode.unbind(this.expr, true);
    }
    if (this.measure != null) {
      this._attributes.unbind(this.measure);
    }
    return (this.expr = this.measure = null);
  }

  // Process script steps by filling out missing props
  _process(object, script) {
    let k, key, last, message, s, step, v;
    if (script instanceof Array) {
      // Normalize array to numbered dict
      s = {};
      for (let i = 0; i < script.length; i++) {
        step = script[i];
        s[i] = step;
      }
      script = s;
    }

    // Normalize keyed steps to array of step objects
    s = [];
    for (key in script) {
      step = script[key];
      if (step == null) {
        step = [];
      }

      if (step instanceof Array) {
        // [props, bind] array
        step = {
          key: +key,
          props: step[0] != null ? deepCopy(step[0]) : {},
          bind: step[1] != null ? deepCopy(step[1]) : {},
        };
      } else {
        if (step.key == null && !step.props && !step.bind) {
          // Direct props object (iffy, but people will do this anyhow)
          step = { props: deepCopy(step) };
        } else {
          // Proper step
          step = deepCopy(step);
        }

        // Prepare step object
        step.key = step.key != null ? +step.key : +key;
        if (step.props == null) {
          step.props = {};
        }
        if (step.bind == null) {
          step.bind = {};
        }
      }

      s.push(step);
    }
    script = s;

    if (!script.length) {
      return [[], {}, 0, 0];
    }

    // Sort by keys
    script.sort((a, b) => a.key - b.key);
    const start = script[0].key;
    const end = script[script.length - 1].key;

    // Connect steps
    for (key in script) {
      step = script[key];
      if (last != null) {
        last.next = step;
      }
      last = step;
    }

    // Last step leads to itself
    last.next = last;
    script = s;

    // Determine starting props
    const props = {};
    const values = {};
    for (key in script) {
      step = script[key];
      for (k in step.props) {
        v = step.props[k];
        props[k] = true;
      }
    }
    for (key in script) {
      step = script[key];
      for (k in step.bind) {
        v = step.bind[k];
        props[k] = true;
      }
    }
    for (k in props) {
      props[k] = object.get(k);
    }
    try {
      // Need two sources and one destination value for correct mixing of live expressions
      for (k in props) {
        values[k] = [
          object.attribute(k).T.make(),
          object.attribute(k).T.make(),
          object.attribute(k).T.make(),
        ];
      }
    } catch (error) {
      console.warn(this.node.toMarkup());
      message = `${this.node.toString()} - Target ${object} has no \`${k}\` property`;
      throw new Error(message);
    }

    const result = [];

    // Normalize script props, insert held values
    for (step of Array.from(script)) {
      for (k in props) {
        v = props[k];
        v = object.validate(k, step.props[k] != null ? step.props[k] : v);
        props[k] = step.props[k] = v;

        if (step.bind[k] != null && typeof step.bind[k] !== "function") {
          console.warn(this.node.toMarkup());
          message = `${this.node.toString()} - Bind expression \`${
            step.bind[k]
          }\` on property \`${k}\` is not a function`;
          throw new Error(message);
        }
      }
      result.push(step);
    }

    return [result, values, start, end];
  }

  update() {
    let { playhead } = this;
    const { script } = this;
    const { ease, seek } = this.props;
    const node = this.targetNode;

    if (seek != null) {
      playhead = seek;
    }

    if (script.length) {
      let k;
      const find = function () {
        let last = script[0];
        for (let i = 0; i < script.length; i++) {
          const step = script[i];
          if (step.key > playhead) {
            break;
          }
          last = step;
        }
        return last;
      };

      let { section } = this;
      if (!section || playhead < section.key || playhead > section.next.key) {
        section = find(script, playhead);
      }

      if (section === this.section) {
        return;
      }
      this.section = section;

      const from = section;
      const to = section.next;
      const start = from.key;
      const end = to.key;

      // Easing of playhead along track
      const easeMethod = (() => {
        switch (ease) {
          case "linear":
          case 0:
            return clamp;
          case "cosine":
          case 1:
            return cosine;
          case "binary":
          case 2:
            return binary;
          case "hold":
          case 3:
            return hold;
          default:
            return cosine;
        }
      })();

      // Callback for live playhead interpolator (linear approx time travel)
      const { clock } = node;
      const getPlayhead = (time) => {
        if (this.velocity == null) {
          return this.playhead;
        }
        const now = clock.getTime();
        return this.playhead + this.velocity * (time - now.time);
      };

      const getLerpFactor = (function () {
        const scale = 1 / Math.max(0.0001, end - start);
        return (time) => easeMethod((getPlayhead(time) - start) * scale, 0, 1);
      })();

      // Create prop expression interpolator
      const live = (key) => {
        const fromE = from.bind[key];
        const toE = to.bind[key];
        const fromP = from.props[key];
        const toP = to.props[key];

        const invalid = function () {
          console.warn(node.toMarkup());
          throw new Error(
            `${this.node.toString()} - Invalid expression result on track \`${key}\``
          );
        };

        const attr = node.attribute(key);
        const values = this.values[key];
        const animator = this._animator;

        // Lerp between two expressions
        if (fromE && toE) {
          return ((values, _from, _to) =>
            function (time, delta) {
              let _from, _to;
              values[0] = _from = attr.T.validate(
                fromE(time, delta),
                values[0],
                invalid
              );
              values[1] = _to = attr.T.validate(
                toE(time, delta),
                values[1],
                invalid
              );
              return (values[2] = animator.lerp(
                attr.T,
                _from,
                _to,
                getLerpFactor(time),
                values[2]
              ));
            })(values, from, to);

          // Lerp between an expression and a constant
        } else if (fromE) {
          return ((values, _from, _to) =>
            function (time, delta) {
              let _from;
              values[0] = _from = attr.T.validate(
                fromE(time, delta),
                values[0],
                invalid
              );
              return (values[1] = animator.lerp(
                attr.T,
                _from,
                toP,
                getLerpFactor(time),
                values[1]
              ));
            })(values, from, to);

          // Lerp between a constant and an expression
        } else if (toE) {
          return ((values, _from, _to) =>
            function (time, delta) {
              let _to;
              values[0] = _to = attr.T.validate(
                toE(time, delta),
                values[0],
                invalid
              );
              return (values[1] = animator.lerp(
                attr.T,
                fromP,
                _to,
                getLerpFactor(time),
                values[1]
              ));
            })(values, from, to);

          // Lerp between two constants
        } else {
          return (
            (values, _from, _to) => (time, _delta) =>
              (values[0] = animator.lerp(
                attr.T,
                fromP,
                toP,
                getLerpFactor(time),
                values[0]
              ))
          )(values, from, to);
        }
      };

      // Handle expr / props on both ends
      const expr = {};
      for (k in from.bind) {
        if (expr[k] == null) {
          expr[k] = live(k);
        }
      }
      for (k in to.bind) {
        if (expr[k] == null) {
          expr[k] = live(k);
        }
      }
      for (k in from.props) {
        if (expr[k] == null) {
          expr[k] = live(k);
        }
      }
      for (k in to.props) {
        if (expr[k] == null) {
          expr[k] = live(k);
        }
      }

      // Bind node props
      return this.bindExpr(expr);
    }
  }

  change(changed, touched, init) {
    if (
      changed["track.target"] ||
      changed["track.script"] ||
      changed["track.mode"]
    ) {
      return this.rebuild();
    }

    if (changed["seek.seek"] || init) {
      return this.update();
    }
  }
}
Track.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/present/play.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Play extends Track {
  static initClass() {
    this.traits = ["node", "track", "trigger", "play", "bind"];
  }

  init() {
    super.init();
    this.skew = null;
    return (this.start = null);
  }

  reset(go) {
    if (go == null) {
      go = true;
    }
    this.skew = go ? 0 : null;
    return (this.start = null);
  }

  make() {
    super.make();

    // Start on slide, or immediately if not inside slide
    this._listen("slide", "slide.step", (e) => {
      const { trigger } = this.props;
      if (trigger != null && e.index === trigger) {
        return this.reset();
      }
      if (trigger != null && e.index === 0) {
        return this.reset(false);
      }
    });
    if (!this.props.trigger || this._inherit("slide") == null) {
      this.reset();
    }

    // Find parent clock
    const parentClock = this._inherit("clock");

    // Update clock
    return this._listen(parentClock, "clock.tick", () => {
      const { from, to, speed, pace, delay, realtime } = this.props;

      const time = parentClock.getTime();
      if (this.skew != null) {
        const now = realtime ? time.time : time.clock;
        const delta = realtime ? time.delta : time.step;
        const ratio = speed / pace;

        if (this.start == null) {
          this.start = now;
        }
        this.skew += delta * (ratio - 1);

        let offset = Math.max(0, now - this.start + this.skew - delay * ratio);
        if (this.props.loop) {
          offset = offset % (to - from);
        }

        this.playhead = Math.min(to, from + offset);
      } else {
        this.playhead = 0;
      }

      return this.update();
    });
  }

  update() {
    return super.update();
  }

  change(changed, touched, init) {
    if (changed["trigger.trigger"] || changed["play.realtime"]) {
      return this.rebuild();
    }
    return super.change(changed, touched, init);
  }
}
Play.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/present/present.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS202: Simplify dynamic range loops
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Present extends Parent {
  static initClass() {
    this.traits = ["node", "present"];
  }

  init() {}

  make() {
    this.nodes = [];
    this.steps = [];
    this.length = 0;
    this.last = [];
    this.index = 0;
    this.dirty = [];

    this._listen("root", "root.update", this.update);
    return this._compute("present.length", () => this.length);
  }

  adopt(controller) {
    const { node } = controller;
    if (this.nodes.indexOf(controller) < 0) {
      this.nodes.push(node);
    }
    return this.dirty.push(controller);
  }

  unadopt(controller) {
    this.nodes = this.nodes.filter((x) => x !== controller);
    return this.dirty.push(controller);
  }

  update() {
    if (!this.dirty.length) {
      return;
    }

    for (const controller of Array.from(this.dirty)) {
      this.slideReset(controller);
    }

    [this.steps, this.indices] = Array.from(this.process(this.nodes));

    this.length = this.steps.length;
    this.index = null;
    this.go(this.props.index);

    return (this.dirty = []);
  }

  slideLatch(controller, enabled, step) {
    return controller.slideLatch(enabled, step);
  }
  slideStep(controller, index, step) {
    return controller.slideStep(this.mapIndex(controller, index), step);
  }
  slideRelease(controller, _step) {
    return controller.slideRelease();
  }
  slideReset(controller) {
    return controller.slideReset();
  }

  mapIndex(controller, index) {
    return index - this.indices[controller.node._id];
  }

  process(nodes) {
    // Grab nodes' path of slide parents
    const slides = (nodes) =>
      Array.from(nodes).map((el) => parents(el).filter(isSlide));
    const traverse = (map) => (el) =>
      (() => {
        let ref, ref1;
        const result = [];
        while (el && (([el, ref] = Array.from((ref1 = [map(el), el]))), ref1)) {
          result.push(ref);
        }
        return result;
      })();

    const parents = traverse(function (el) {
      if (el.parent.traits.hash.present) {
        return null;
      } else {
        return el.parent;
      }
    });

    // Helpers
    const isSlide = (el) => nodes.indexOf(el) >= 0;

    // Order paths (leaf -> parent slide -> ...)
    const order = (paths) =>
      paths.sort(function (a, b) {
        // Path lengths
        const c = a.length;
        const d = b.length;

        // Compare from outside in
        let e = Math.min(c, d);
        for (
          let i = 1, end = e, asc = 1 <= end;
          asc ? i <= end : i >= end;
          asc ? i++ : i--
        ) {
          // inclusive end
          const nodeA = a[c - i];
          const nodeB = b[d - i];

          // Explicit sibling order (natural)
          const f = nodeA.props.order;
          const g = nodeB.props.order;
          if (f != null || g != null) {
            if (f != null && g != null && (e = f - g) !== 0) {
              return e;
            }
            if (f != null) {
              return -1;
            }
            if (g != null) {
              return 1;
            }
          }

          // Document sibling order (inverted)
          if (nodeB.order !== nodeA.order) {
            return nodeB.order - nodeA.order;
          }
        }

        // Different tree level
        e = c - d;
        if (e !== 0) {
          return e;
        }

        // Equal
        return 0;
      });

    const split = function (steps) {
      const relative = [];
      const absolute = [];
      for (const step of Array.from(steps)) {
        (step[0].props.steps != null ? relative : absolute).push(step);
      }
      return [relative, absolute];
    };

    const expand = function (lists) {
      let step;
      const [relative, absolute] = Array.from(lists);

      const limit = 100;

      const indices = {};
      let steps = [];
      const slide = function (step, index) {
        let node;
        const { props } = (node = step[0]);
        const parent = step[1];

        const parentIndex = parent != null ? indices[parent._id] : 0;
        //throw "parent index missing" if !parentIndex?
        const childIndex = index;

        let from =
          props.from != null
            ? parentIndex + props.from
            : childIndex - props.early;
        let to =
          props.to != null
            ? parentIndex + props.to
            : childIndex + props.steps + props.late;

        from = Math.max(0, from);
        to = Math.min(limit, to);

        if (indices[node._id] == null) {
          indices[node._id] = from;
        }
        for (
          let i = from, end = to, asc = from <= end;
          asc ? i < end : i > end;
          asc ? i++ : i--
        ) {
          steps[i] = (steps[i] != null ? steps[i] : (steps[i] = [])).concat(
            step
          );
        }

        return props.steps;
      };

      let i = 0;
      for (step of Array.from(relative)) {
        i += slide(step, i);
      }
      for (step of Array.from(absolute)) {
        slide(step, 0);
      }

      // Dedupe and order
      steps = (() => {
        const result = [];
        for (step of Array.from(steps)) {
          result.push(finalize(dedupe(step)));
        }
        return result;
      })();

      return [steps, indices];
    };

    // Remove duplicates
    const dedupe = function (step) {
      if (step) {
        return (() => {
          const result = [];
          for (let i = 0; i < step.length; i++) {
            const node = step[i];
            if (step.indexOf(node) === i) {
              result.push(node);
            }
          }
          return result;
        })();
      } else {
        return [];
      }
    };

    // Finalize individual step by document order
    const finalize = (step) => step.sort((a, b) => a.order - b.order);

    const paths = slides(nodes);
    const steps = order(paths);
    return expand(split(steps));
  }

  go(index) {
    // Pad with an empty slide before and after for initial enter/final exit
    let left;
    let node;
    index = Math.max(0, Math.min(this.length + 1, +index || 0));

    const active = (left = this.steps[index - 1]) != null ? left : [];
    const step = this.props.directed ? index - this.index : 1;
    this.index = index;

    const enter = (() => {
      const result = [];
      for (node of Array.from(active)) {
        if (this.last.indexOf(node) < 0) {
          result.push(node);
        }
      }
      return result;
    })();
    const exit = (() => {
      const result1 = [];
      for (node of Array.from(this.last)) {
        if (active.indexOf(node) < 0) {
          result1.push(node);
        }
      }
      return result1;
    })();
    const stay = (() => {
      const result2 = [];
      for (node of Array.from(active)) {
        if (enter.indexOf(node) < 0 && exit.indexOf(node) < 0) {
          result2.push(node);
        }
      }
      return result2;
    })();

    const ascend = (nodes) => nodes.sort((a, b) => a.order - b.order);
    const descend = (nodes) => nodes.sort((a, b) => b.order - a.order);

    //const toStr = (x) => x.toString();
    //console.log '============================================================'
    //console.log 'go',  index, {enter: enter.map(toStr), stay: stay.map(toStr), exit: exit.map(toStr)}

    for (node of Array.from(ascend(enter))) {
      this.slideLatch(node.controller, true, step);
    }
    for (node of Array.from(ascend(stay))) {
      this.slideLatch(node.controller, null, step);
    }
    for (node of Array.from(ascend(exit))) {
      this.slideLatch(node.controller, false, step);
    }

    for (node of Array.from(enter)) {
      this.slideStep(node.controller, index, step);
    }
    for (node of Array.from(stay)) {
      this.slideStep(node.controller, index, step);
    }
    for (node of Array.from(exit)) {
      this.slideStep(node.controller, index, step);
    }

    for (node of Array.from(descend(enter))) {
      this.slideRelease(node.controller);
    }
    for (node of Array.from(descend(stay))) {
      this.slideRelease(node.controller);
    }
    for (node of Array.from(descend(exit))) {
      this.slideRelease(node.controller);
    }

    this.last = active;
  }

  change(changed, touched, init) {
    if (changed["present.index"] || init) {
      return this.go(this.props.index);
    }
  }
}
Present.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/present/reveal.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Reveal extends Transition {
  static initClass() {
    this.traits = ["node", "transition", "mask", "visible", "active"];
  }

  mask(shader) {
    let left, s;
    if (shader) {
      s = this._shaders.shader();
      s.pipe(identity("vec4"));
      s.fan();
      s.pipe(shader, this.uniforms);
      s.next();
      s.pipe("reveal.mask", this.uniforms);
      s.end();
      s.pipe("float combine(float a, float b) { return min(a, b); }");
    } else {
      s = this._shaders.shader();
      s.pipe("reveal.mask", this.uniforms);
    }

    return (left = reveal_guard_(this._inherit("mask"), (x) => x.mask(s))) != null
      ? left
      : s;
  }
}
Reveal.initClass();

function reveal_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/primitives/types/present/slide.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Slide extends Parent {
  static initClass() {
    this.traits = ["node", "slide", "visible", "active"];
  }

  make() {
    this._helpers.visible.make();
    this._helpers.active.make();

    if (!this._inherit("present")) {
      throw new Error(
        `${this.node.toString()} must be placed inside <present></present>`
      );
    }

    return this._inherit("present").adopt(this);
  }

  unmake() {
    this._helpers.visible.unmake();
    this._helpers.active.unmake();

    return this._inherit("present").unadopt(this);
  }

  change(changed, _touched, _init) {
    if (
      changed["slide.early"] ||
      changed["slide.late"] ||
      changed["slide.steps"] ||
      changed["slide.from"] ||
      changed["slide.to"]
    ) {
      return this.rebuild();
    }
  }

  slideLatch(enabled, step) {
    //console.log 'slide:latch', @node.toString(), enabled, step
    this.trigger({
      type: "transition.latch",
      step: step,
    });

    if (enabled != null) {
      return this._instant(enabled);
    }
  }

  slideStep(index, step) {
    //console.log 'slide:step', @node.toString(), index, step
    return this.trigger({
      type: "slide.step",
      index: index,
      step: step,
    });
  }

  slideRelease() {
    //console.log 'slide:release', @node.toString()
    return this.trigger({
      type: "transition.release",
    });
  }

  slideReset() {
    this._instant(false);
    return this.trigger({
      type: "slide.reset",
    });
  }

  _instant(enabled) {
    //console.log 'slide:instant', @node.toString(), enabled
    this.setVisible(enabled);
    return this.setActive(enabled);
  }
}
Slide.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/present/step.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Step extends Track {
  static initClass() {
    this.traits = ["node", "track", "step", "trigger", "bind"];
  }

  make() {
    super.make();

    const clock = this._inherit("clock");

    if (this.actualIndex == null) {
      this.actualIndex = null;
    }
    this.animateIndex = this._animator.make(this._types.number(0), {
      clock,
      realtime: this.props.realtime,
      step: (value) => {
        return (this.actualIndex = value);
      },
    });

    if (this.lastIndex == null) {
      this.lastIndex = null;
    }
    this.animateStep = this._animator.make(this._types.number(0), {
      clock,
      realtime: this.props.realtime,
      step: (value) => {
        this.playhead = value;
        return this.update();
      },
    });

    this.stops =
      this.props.stops != null
        ? this.props.stops
        : step_range_(0, this.script.length, false);

    // Seek instantly after reset
    this._listen("slide", "slide.reset", (_e) => {
      return (this.lastIndex = null);
    });

    // Update playhead in response to slide change
    return this._listen("slide", "slide.step", (e) => {
      let left;
      let { duration } = this.props;
      const { delay, pace, speed, playback, rewind, skip, trigger } =
        this.props;

      // Note: enter phase is from index 0 to 1
      const i = Math.max(0, Math.min(this.stops.length - 1, e.index - trigger));

      // Animation range
      const from = this.playhead;
      const to = this.stops[i];

      // Seek if first step after reset
      if (this.lastIndex == null && trigger) {
        this.lastIndex = i;
        this.animateStep.set(to);
        this.animateIndex.set(i);
        return;
      }

      // Calculate actual step from current offset (may be still animating)
      let last =
        (left = this.actualIndex != null ? this.actualIndex : this.lastIndex) !=
        null
          ? left
          : 0;
      const step = i - last;

      // Don't count duped stops
      const skips = this.stops.slice(Math.min(last, i), Math.max(last, i));
      let free = 0;
      last = skips.shift();
      for (const stop of Array.from(skips)) {
        if (last === stop) {
          free++;
        }
        last = stop;
      }

      // Remember last intended stop
      this.lastIndex = i;

      // Apply rewind factor
      let factor = speed * (e.step >= 0 ? 1 : rewind);

      // Pass through multiple steps at faster rate if skip is enabled
      factor *= skip ? Math.max(1, Math.abs(step) - free) : 1;

      // Apply pace
      duration += (Math.abs(to - from) * pace) / factor;

      if (from !== to) {
        this.animateIndex.immediate(i, { delay, duration, ease: playback });
        return this.animateStep.immediate(to, {
          delay,
          duration,
          ease: playback,
        });
      }
    });
  }

  made() {
    return this.update();
  }

  unmake() {
    this.animateIndex.dispose();
    this.animateStep.dispose();
    this.animateIndex = this.animateStep = null;

    return super.unmake();
  }

  change(changed, touched, init) {
    if (changed["step.stops"] || changed["step.realtime"]) {
      return this.rebuild();
    }
    return super.change(changed, touched, init);
  }
}
Step.initClass();

function step_range_(left, right, inclusive) {
  const range = [];
  const ascending = left < right;
  const end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}

;// CONCATENATED MODULE: ./src/primitives/types/present/index.js







;// CONCATENATED MODULE: ./src/primitives/types/rtt/rtt.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class RTT extends Parent {
  static initClass() {
    this.traits = [
      "node",
      "root",
      "scene",
      "vertex",
      "texture",
      "rtt",
      "source",
      "index",
      "image",
    ];
    this.defaults = {
      minFilter: "linear",
      magFilter: "linear",
      type: "unsignedByte",
    };
  }

  init() {
    return (this.rtt =
      this.scene =
      this.camera =
      this.width =
      this.height =
      this.history =
      this.rootSize =
      this.size =
        null);
  }

  indexShader(shader) {
    return shader;
  }
  imageShader(shader) {
    return this.rtt.shaderRelative(shader);
  }
  sourceShader(shader) {
    return this.rtt.shaderAbsolute(shader, this.history);
  }

  getDimensions() {
    return {
      items: 1,
      width: this.width,
      height: this.height,
      depth: this.history,
    };
  }

  getActiveDimensions() {
    return this.getDimensions();
  }

  make() {
    let aspect;
    this.parentRoot = this._inherit("root");
    this.rootSize = this.parentRoot.getSize();

    this._listen(this.parentRoot, "root.pre", this.pre);
    this._listen(this.parentRoot, "root.update", this.update);
    this._listen(this.parentRoot, "root.render", this.render);
    this._listen(this.parentRoot, "root.post", this.post);
    this._listen(this.parentRoot, "root.camera", this.setCamera);
    this._listen(this.parentRoot, "root.resize", function (event) {
      return this.resize(event.size);
    });

    if (this.rootSize == null) {
      return;
    }

    const { minFilter, magFilter, type } = this.props;

    const { width, height, history, size } = this.props;

    const relativeSize =
      size === this.node.attributes["rtt.size"].enum.relative;
    const widthFactor = relativeSize ? this.rootSize.renderWidth : 1;
    const heightFactor = relativeSize ? this.rootSize.renderHeight : 1;

    this.width = Math.round(
      width != null ? width * widthFactor : this.rootSize.renderWidth
    );
    this.height = Math.round(
      height != null ? height * heightFactor : this.rootSize.renderHeight
    );
    this.history = history;
    this.aspect = aspect = this.width / this.height;

    if (this.scene == null) {
      this.scene = this._renderables.make("scene");
    }
    this.rtt = this._renderables.make("renderToTexture", {
      scene: this.scene,
      camera: this._context.defaultCamera,
      width: this.width,
      height: this.height,
      frames: this.history,
      minFilter,
      magFilter,
      type,
    });

    aspect = width || height ? aspect : this.rootSize.aspect;
    const viewWidth = width != null ? width : this.rootSize.viewWidth;
    const viewHeight = height != null ? height : this.rootSize.viewHeight;

    return (this.size = {
      renderWidth: this.width,
      renderHeight: this.height,
      aspect,
      viewWidth,
      viewHeight,
      pixelRatio: this.height / viewHeight,
    });
  }

  made() {
    // Notify of buffer reallocation
    this.trigger({
      type: "source.rebuild",
    });

    if (this.size) {
      return this.trigger({
        type: "root.resize",
        size: this.size,
      });
    }
  }

  unmake(rebuild) {
    if (this.rtt == null) {
      return;
    }

    this.rtt.dispose();
    if (!rebuild) {
      this.scene.dispose();
    }

    return (this.rtt = this.width = this.height = this.history = null);
  }

  change(changed, touched, init) {
    if (touched["texture"] || changed["rtt.width"] || changed["rtt.height"]) {
      return this.rebuild();
    }

    if (changed["root.camera"] || init) {
      this._unattach();
      this._attach(
        this.props.camera,
        "camera",
        this.setCamera,
        this,
        this,
        true
      );
      return this.setCamera();
    }
  }

  adopt(renderable) {
    return Array.from(renderable.renders).map((object) =>
      this.scene.add(object)
    );
  }
  unadopt(renderable) {
    return Array.from(renderable.renders).map((object) =>
      this.scene.remove(object)
    );
  }

  resize(size) {
    let height, width;
    this.rootSize = size;

    ({ width, height, size } = this.props);
    const relativeSize =
      size === this.node.attributes["rtt.size"].enum.relative;

    if (!this.rtt || width == null || height == null || relativeSize) {
      return this.rebuild();
    }
  }

  select(selector) {
    return this._root.node.model.select(selector, [this.node]);
  }

  watch(selector, handler) {
    return this._root.node.model.watch(selector, handler);
  }

  unwatch(handler) {
    return this._root.node.model.unwatch(handler);
  }

  pre(e) {
    return this.trigger(e);
  }
  update(e) {
    let camera;
    if ((camera = this.getOwnCamera()) != null) {
      camera.aspect = this.aspect || 1;
      camera.updateProjectionMatrix();
    }
    return this.trigger(e);
  }
  render(e) {
    this.trigger(e);
    return this.rtt != null ? this.rtt.render(this.getCamera()) : undefined;
  }
  post(e) {
    return this.trigger(e);
  }

  setCamera() {
    const camera = rtt_guard_(
      this.select(this.props.camera)[0],
      (x) => x.controller
    );
    if (this.camera !== camera) {
      this.camera = camera;
      this.rtt.camera = this.getCamera();
      return this.trigger({ type: "root.camera" });
    } else if (!this.camera) {
      return this.trigger({ type: "root.camera" });
    }
  }

  getOwnCamera() {
    return this.camera != null ? this.camera.getCamera() : undefined;
  }
  getCamera() {
    let left;
    return (left = this.getOwnCamera()) != null
      ? left
      : this._inherit("root").getCamera();
  }

  // End transform chain here
  vertex(shader, pass) {
    if (pass === 2) {
      return shader.pipe("view.position");
    }
    if (pass === 3) {
      return shader.pipe("root.position");
    }
    return shader;
  }
}
RTT.initClass();

function rtt_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/primitives/types/rtt/compose.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Compose extends Primitive {
  static initClass() {
    this.traits = [
      "node",
      "bind",
      "object",
      "visible",
      "operator",
      "style",
      "compose",
    ];
    this.defaults = {
      zWrite: false,
      zTest: false,
      color: "#ffffff",
    };
  }

  init() {
    return (this.compose = null);
  }

  //rebuild: () ->
  //  console.log 'compose.rebuild', @node.get(null, true), @bind.source?
  //  super()

  resize() {
    if (!this.compose || !this.bind.source) {
      return;
    }

    const dims = this.bind.source.getActiveDimensions();
    const { width } = dims;
    const { height } = dims;

    return this.remapUVScale.set(width, height);
  }

  make() {
    // Bind to attached data sources
    this._helpers.bind.make([{ to: "operator.source", trait: "source" }]);

    if (this.bind.source == null) {
      return;
    }

    // Prepare uniforms for remapping to absolute coords on the fly
    const resampleUniforms = {
      remapUVScale: this._attributes.make(this._types.vec2()),
    };
    this.remapUVScale = resampleUniforms.remapUVScale.value;

    // Build fragment shader
    let fragment = this._shaders.shader();
    const { alpha } = this.props;

    if (this.bind.source.is("image")) {
      // Sample image directly in 2D UV
      fragment.pipe("screen.pass.uv", resampleUniforms);
      fragment = this.bind.source.imageShader(fragment);
    } else {
      // Sample data source in 4D
      fragment.pipe("screen.map.xy", resampleUniforms);
      fragment = this.bind.source.sourceShader(fragment);
    }

    // Force pixels to solid if requested
    if (!alpha) {
      fragment.pipe("color.opaque");
    }

    // Make screen renderable
    const composeUniforms = this._helpers.style.uniforms();
    this.compose = this._renderables.make("screen", {
      map: fragment,
      uniforms: composeUniforms,
      linear: true,
    });

    this._helpers.visible.make();
    return this._helpers.object.make([this.compose]);
  }

  made() {
    return this.resize();
  }

  unmake() {
    this._helpers.bind.unmake();
    this._helpers.visible.unmake();
    return this._helpers.object.unmake();
  }

  change(changed, _touched, _init) {
    if (changed["operator.source"] || changed["compose.alpha"]) {
      return this.rebuild();
    }
  }
}
Compose.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/rtt/index.js



;// CONCATENATED MODULE: ./src/primitives/types/view/view.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



class View extends Transform {
  static initClass() {
    this.traits = ["node", "object", "visible", "view", "vertex"];
  }

  make() {
    return this._helpers.visible.make();
  }

  unmake() {
    return this._helpers.visible.unmake();
  }

  axis(dimension) {
    return this.props.range[dimension - 1];
  }
}
View.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/view/cartesian.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Cartesian extends View {
  static initClass() {
    this.traits = ["node", "object", "visible", "view", "view3", "vertex"];
  }

  make() {
    super.make();

    this.uniforms = { viewMatrix: this._attributes.make(this._types.mat4()) };

    this.viewMatrix = this.uniforms.viewMatrix.value;
    this.composer = transformComposer();
  }

  unmake() {
    super.unmake();

    delete this.viewMatrix;
    delete this.objectMatrix;
    delete this.uniforms;
  }

  change(changed, touched, init) {
    if (!touched["view"] && !touched["view3"] && !init) {
      return;
    }

    const p = this.props.position;
    const s = this.props.scale;
    const q = this.props.quaternion;
    const r = this.props.rotation;
    const g = this.props.range;
    const e = this.props.eulerOrder;

    const { x } = g[0];
    const y = g[1].x;
    const z = g[2].x;
    const dx = g[0].y - x || 1;
    const dy = g[1].y - y || 1;
    const dz = g[2].y - z || 1;

    // Forward transform
    this.viewMatrix.set(
      2 / dx,
      0,
      0,
      -(2 * x + dx) / dx,
      0,
      2 / dy,
      0,
      -(2 * y + dy) / dy,
      0,
      0,
      2 / dz,
      -(2 * z + dz) / dz,
      0,
      0,
      0,
      1
    );

    const transformMatrix = this.composer(p, r, q, s, null, e);
    this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);

    if (changed["view.range"]) {
      this.trigger({
        type: "view.range",
      });
    }
  }

  vertex(shader, pass) {
    if (pass === 1) {
      shader.pipe("cartesian.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }
}
Cartesian.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/view/cartesian4.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Cartesian4 extends View {
  static initClass() {
    this.traits = ["node", "object", "visible", "view", "view4", "vertex"];
  }

  make() {
    super.make();

    this.uniforms = {
      basisOffset: this._attributes.make(this._types.vec4()),
      basisScale: this._attributes.make(this._types.vec4()),
    };

    this.basisScale = this.uniforms.basisScale.value;
    return (this.basisOffset = this.uniforms.basisOffset.value);
  }

  unmake() {
    super.unmake();
    delete this.basisScale;
    delete this.basisOffset;
    return delete this.uniforms;
  }

  change(changed, touched, init) {
    if (!touched["view"] && !touched["view4"] && !init) {
      return;
    }

    const p = this.props.position;
    const s = this.props.scale;
    const g = this.props.range;

    const { x } = g[0];
    const y = g[1].x;
    const z = g[2].x;
    const w = g[3].x;
    const dx = g[0].y - x || 1;
    const dy = g[1].y - y || 1;
    const dz = g[2].y - z || 1;
    const dw = g[3].y - w || 1;

    const mult = function (a, b) {
      a.x *= b.x;
      a.y *= b.y;
      a.z *= b.z;
      return (a.w *= b.w);
    };

    // 4D axis adjustment
    this.basisScale.set(2 / dx, 2 / dy, 2 / dz, 2 / dw);
    this.basisOffset.set(
      -(2 * x + dx) / dx,
      -(2 * y + dy) / dy,
      -(2 * z + dz) / dz,
      -(2 * w + dw) / dw
    );

    // 4D scale
    mult(this.basisScale, s);
    mult(this.basisOffset, s);

    // 4D position
    this.basisOffset.add(p);

    if (changed["view.range"]) {
      return this.trigger({
        type: "view.range",
      });
    }
  }

  vertex(shader, pass) {
    if (pass === 1) {
      shader.pipe("cartesian4.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }
}
Cartesian4.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/view/polar.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */







class Polar extends View {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "view",
      "view3",
      "polar",
      "vertex",
    ];
  }

  make() {
    super.make();

    const { types } = this._attributes;
    this.uniforms = {
      polarBend: this.node.attributes["polar.bend"],
      polarHelix: this.node.attributes["polar.helix"],
      polarFocus: this._attributes.make(types.number()),
      polarAspect: this._attributes.make(types.number()),
      viewMatrix: this._attributes.make(types.mat4()),
    };

    this.viewMatrix = this.uniforms.viewMatrix.value;
    this.composer = transformComposer();

    return (this.aspect = 1);
  }

  unmake() {
    super.unmake();

    delete this.viewMatrix;
    delete this.objectMatrix;
    delete this.aspect;
    return delete this.uniforms;
  }

  change(changed, touched, init) {
    let aspect, bend, focus;
    if (!touched["view"] && !touched["view3"] && !touched["polar"] && !init) {
      return;
    }

    this.helix = this.props.helix;
    this.bend = bend = this.props.bend;

    this.focus = focus = bend > 0 ? 1 / bend - 1 : 0;

    const p = this.props.position;
    const s = this.props.scale;
    const q = this.props.quaternion;
    const r = this.props.rotation;
    const g = this.props.range;
    const e = this.props.eulerOrder;

    const { x } = g[0];
    let y = g[1].x;
    const z = g[2].x;
    const dx = g[0].y - x || 1;
    let dy = g[1].y - y || 1;
    const dz = g[2].y - z || 1;
    const sx = s.x;
    const sy = s.y;

    // Watch for negative scales.
    const idx = dx > 0 ? 1 : -1;

    // Recenter viewport on origin the more it's bent
    [y, dy] = Array.from(recenterAxis(y, dy, bend));

    // Adjust viewport range for polar transform.
    // As the viewport goes polar, the X-range is interpolated to the Y-range instead,
    // creating a square/circular viewport.
    const ady = Math.abs(dy);
    const fdx = dx + (ady * idx - dx) * bend;
    const sdx = fdx / sx;
    const sdy = dy / sy;
    this.aspect = aspect = Math.abs(sdx / sdy);

    this.uniforms.polarFocus.value = focus;
    this.uniforms.polarAspect.value = aspect;

    // Forward transform
    this.viewMatrix.set(
      2 / fdx,
      0,
      0,
      -(2 * x + dx) / dx,
      0,
      2 / dy,
      0,
      -(2 * y + dy) / dy,
      0,
      0,
      2 / dz,
      -(2 * z + dz) / dz,
      0,
      0,
      0,
      1 //,
    );

    const transformMatrix = this.composer(p, r, q, s, null, e);
    this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);

    if (changed["view.range"] || touched["polar"]) {
      this.trigger({
        type: "view.range",
      });
    }
  }

  vertex(shader, pass) {
    if (pass === 1) {
      shader.pipe("polar.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }

  axis(dimension) {
    const range = this.props.range[dimension - 1];
    let min = range.x;
    let max = range.y;

    // Correct Y extents during polar warp.
    if (dimension === 2 && this.bend > 0) {
      max = Math.max(Math.abs(max), Math.abs(min));
      min = Math.max(-this.focus / this.aspect, min);
    }

    return new external_THREE_.Vector2(min, max);
  }
}
Polar.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/view/spherical.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */







class Spherical extends View {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "view",
      "view3",
      "spherical",
      "vertex",
    ];
  }

  make() {
    super.make();

    this.uniforms = {
      sphericalBend: this.node.attributes["spherical.bend"],
      sphericalFocus: this._attributes.make(this._types.number()),
      sphericalAspectX: this._attributes.make(this._types.number()),
      sphericalAspectY: this._attributes.make(this._types.number()),
      sphericalScaleY: this._attributes.make(this._types.number()),
      viewMatrix: this._attributes.make(this._types.mat4()),
    };

    this.viewMatrix = this.uniforms.viewMatrix.value;
    this.composer = transformComposer();

    this.aspectX = 1;
    return (this.aspectY = 1);
  }

  unmake() {
    super.unmake();

    delete this.viewMatrix;
    delete this.objectMatrix;
    delete this.aspectX;
    delete this.aspectY;
    return delete this.uniforms;
  }

  change(changed, touched, init) {
    let aspectX, aspectY, bend, focus, scaleY;
    if (
      !touched["view"] &&
      !touched["view3"] &&
      !touched["spherical"] &&
      !init
    ) {
      return;
    }

    this.bend = bend = this.props.bend;
    this.focus = focus = bend > 0 ? 1 / bend - 1 : 0;

    const p = this.props.position;
    const s = this.props.scale;
    const q = this.props.quaternion;
    const r = this.props.rotation;
    const g = this.props.range;
    const e = this.props.eulerOrder;

    const { x } = g[0];
    let y = g[1].x;
    let z = g[2].x;
    const dx = g[0].y - x || 1;
    let dy = g[1].y - y || 1;
    let dz = g[2].y - z || 1;
    const sx = s.x;
    const sy = s.y;
    const sz = s.z;

    // Recenter viewport on origin the more it's bent
    [y, dy] = Array.from(recenterAxis(y, dy, bend));
    [z, dz] = Array.from(recenterAxis(z, dz, bend));

    // Watch for negative scales.
    const idx = dx > 0 ? 1 : -1;
    const idy = dy > 0 ? 1 : -1;

    // Adjust viewport range for spherical transform.
    // As the viewport goes spherical, the X/Y-ranges are interpolated to the Z-range,
    // creating a perfectly spherical viewport.
    const adz = Math.abs(dz);
    const fdx = dx + (adz * idx - dx) * bend;
    const fdy = dy + (adz * idy - dy) * bend;
    const sdx = fdx / sx;
    const sdy = fdy / sy;
    const sdz = dz / sz;
    this.aspectX = aspectX = Math.abs(sdx / sdz);
    this.aspectY = aspectY = Math.abs(sdy / sdz / aspectX);

    // Scale Y coordinates before transforming, but cap at aspectY/alpha to prevent from poking through the poles mid-transform.
    // See shaders/glsl/spherical.position.glsl
    const aspectZ = (((dy / dx) * sx) / sy) * 2; // Factor of 2 due to the fact that in the Y direction we only go 180º from pole to pole.
    this.scaleY = scaleY = Math.min(aspectY / bend, 1 + (aspectZ - 1) * bend);

    this.uniforms.sphericalBend.value = bend;
    this.uniforms.sphericalFocus.value = focus;
    this.uniforms.sphericalAspectX.value = aspectX;
    this.uniforms.sphericalAspectY.value = aspectY;
    this.uniforms.sphericalScaleY.value = scaleY;

    // Forward transform
    this.viewMatrix.set(
      2 / fdx,
      0,
      0,
      -(2 * x + dx) / dx,
      0,
      2 / fdy,
      0,
      -(2 * y + dy) / dy,
      0,
      0,
      2 / dz,
      -(2 * z + dz) / dz,
      0,
      0,
      0,
      1 //,
    );

    const transformMatrix = this.composer(p, r, q, s, null, e);
    this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);

    if (changed["view.range"] || touched["spherical"]) {
      return this.trigger({
        type: "view.range",
      });
    }
  }

  vertex(shader, pass) {
    if (pass === 1) {
      shader.pipe("spherical.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }

  axis(dimension) {
    const range = this.props.range[dimension - 1];
    let min = range.x;
    let max = range.y;

    // Correct Z extents during polar warp.
    if (dimension === 3 && this.bend > 0) {
      max = Math.max(Math.abs(max), Math.abs(min));
      min = Math.max(-this.focus / this.aspectX + 0.001, min);
    }

    return new external_THREE_.Vector2(min, max);
  }
}
Spherical.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/view/stereographic.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */






class Stereographic extends View {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "view",
      "view3",
      "stereographic",
      "vertex",
    ];
  }

  make() {
    super.make();

    this.uniforms = {
      stereoBend: this.node.attributes["stereographic.bend"],
      viewMatrix: this._attributes.make(this._types.mat4()),
    };

    this.viewMatrix = this.uniforms.viewMatrix.value;
    return (this.composer = transformComposer());
  }

  unmake() {
    super.unmake();

    delete this.viewMatrix;
    delete this.rotationMatrix;
    return delete this.uniforms;
  }

  change(changed, touched, init) {
    let bend;
    if (
      !touched["view"] &&
      !touched["view3"] &&
      !touched["stereographic"] &&
      !init
    ) {
      return;
    }

    this.bend = bend = this.props.bend;

    const p = this.props.position;
    const s = this.props.scale;
    const q = this.props.quaternion;
    const r = this.props.rotation;
    const g = this.props.range;
    const e = this.props.eulerOrder;

    const { x } = g[0];
    const y = g[1].x;
    let z = g[2].x;
    const dx = g[0].y - x || 1;
    const dy = g[1].y - y || 1;
    let dz = g[2].y - z || 1;

    // Recenter viewport on projection point the more it's bent
    [z, dz] = Array.from(recenterAxis(z, dz, bend, 1));

    this.uniforms.stereoBend.value = bend;

    // Forward transform
    this.viewMatrix.set(
      2 / dx,
      0,
      0,
      -(2 * x + dx) / dx,
      0,
      2 / dy,
      0,
      -(2 * y + dy) / dy,
      0,
      0,
      2 / dz,
      -(2 * z + dz) / dz,
      0,
      0,
      0,
      1 //,
    );

    const transformMatrix = this.composer(p, r, q, s, null, e);
    this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);

    if (changed["view.range"] || touched["stereographic"]) {
      return this.trigger({
        type: "view.range",
      });
    }
  }

  vertex(shader, pass) {
    if (pass === 1) {
      shader.pipe("stereographic.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }
}
Stereographic.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/view/stereographic4.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Stereographic4 extends View {
  static initClass() {
    this.traits = [
      "node",
      "object",
      "visible",
      "view",
      "view4",
      "stereographic",
      "vertex",
    ];
  }

  make() {
    super.make();

    this.uniforms = {
      basisOffset: this._attributes.make(this._types.vec4()),
      basisScale: this._attributes.make(this._types.vec4()),
      stereoBend: this.node.attributes["stereographic.bend"],
    };

    this.basisScale = this.uniforms.basisScale.value;
    this.basisOffset = this.uniforms.basisOffset.value;
  }

  unmake() {
    super.unmake();

    delete this.basisScale;
    delete this.basisOffset;
    delete this.uniforms;
  }

  change(changed, touched, init) {
    let bend;
    if (
      !touched["view"] &&
      !touched["view4"] &&
      !touched["stereographic"] &&
      !init
    ) {
      return;
    }

    this.bend = bend = this.props.bend;

    const p = this.props.position;
    const s = this.props.scale;
    const g = this.props.range;

    const { x } = g[0];
    const y = g[1].x;
    const z = g[2].x;
    let w = g[3].x;
    const dx = g[0].y - x || 1;
    const dy = g[1].y - y || 1;
    const dz = g[2].y - z || 1;
    let dw = g[3].y - w || 1;

    const mult = function (a, b) {
      a.x *= b.x;
      a.y *= b.y;
      a.z *= b.z;
      a.w *= b.w;
    };

    // Recenter viewport on projection point the more it's bent
    [w, dw] = Array.from(recenterAxis(w, dw, bend, 1));

    // 4D axis adjustment
    this.basisScale.set(2 / dx, 2 / dy, 2 / dz, 2 / dw);
    this.basisOffset.set(
      -(2 * x + dx) / dx,
      -(2 * y + dy) / dy,
      -(2 * z + dz) / dz,
      -(2 * w + dw) / dw
    );

    // 4D scale
    mult(this.basisScale, s);
    mult(this.basisOffset, s);

    // 4D position
    this.basisOffset.add(p);

    if (changed["view.range"] || touched["stereographic"]) {
      this.trigger({
        type: "view.range",
      });
    }
  }

  vertex(shader, pass) {
    if (pass === 1) {
      shader.pipe("stereographic4.position", this.uniforms);
    }
    return super.vertex(shader, pass);
  }
}
Stereographic4.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/view/index.js








;// CONCATENATED MODULE: ./src/primitives/types/shader/shader.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Shader extends Primitive {
  static initClass() {
    this.traits = ["node", "bind", "shader"];
    this.freeform = true;
  }

  init() {
    return (this.shader = null);
  }

  make() {
    const { language, code } = this.props;
    if (language !== "glsl") {
      throw new Error("GLSL required");
    }

    // Bind to attached data sources
    this._helpers.bind.make([
      { to: "shader.sources", trait: "source", multiple: true },
    ]);

    // Parse snippet w/ shadergraph (will do implicit DOM script tag by ID
    // lookup if simple selector or ID given)
    const snippet = this._shaders.fetch(code);

    // Convert uniforms to attributes
    const types = this._types;
    const uniforms = {};
    const make = (type) => {
      let t;
      switch (type) {
        case "i":
          return types.int();
        case "f":
          return types.number();
        case "v2":
          return types.vec2();
        case "v3":
          return types.vec3();
        case "v4":
          return types.vec4();
        case "m3":
          return types.mat3();
        case "m4":
          return types.mat4();
        case "t":
          return types.object();
        default:
          t = type.split("");
          if (t.pop() === "v") {
            return types.array(make(t.join("")));
          } else {
            return null;
          }
      }
    };

    for (const def of Array.from(snippet._signatures.uniform)) {
      let type;
      if ((type = make(def.type))) {
        uniforms[def.name] = type;
      }
    }

    // Reconfigure node model
    return this.reconfigure({ props: { uniform: uniforms } });
  }

  made() {
    // Notify of shader reallocation
    return this.trigger({
      type: "source.rebuild",
    });
  }

  unmake() {
    return (this.shader = null);
  }

  change(changed, _touched, _init) {
    if (
      changed["shader.uniforms"] ||
      changed["shader.code"] ||
      changed["shader.language"]
    ) {
      return this.rebuild();
    }
  }

  shaderBind(uniforms) {
    let k, u, v;
    if (uniforms == null) {
      uniforms = {};
    }
    const { code, indices, channels } = this.props;

    // Merge in prop attributes as uniforms
    for (k in this.node.attributes) {
      v = this.node.attributes[k];
      if (v.type != null && v.short != null && v.ns === "uniform") {
        if (uniforms[v.short] == null) {
          uniforms[v.short] = v;
        }
      }
    }

    // Merge in explicit uniform object if set
    if ((u = this.props.uniforms) != null) {
      for (k in u) {
        v = u[k];
        uniforms[k] = v;
      }
    }

    // New shader
    const s = this._shaders.shader();

    // Require sources
    if (this.bind.sources != null) {
      for (const source of Array.from(this.bind.sources)) {
        s.callback();
        if (indices != 4) {
          s.pipe(extendVec(indices, 4));
        }
        s.pipe(source.sourceShader(this._shaders.shader()));
        if (channels != 4) {
          s.pipe(truncateVec(4, channels));
        }
        s.join();
      }
    }

    // Build bound shader
    return s.pipe(code, uniforms);
  }
}
Shader.initClass();

;// CONCATENATED MODULE: ./src/primitives/types/shader/index.js


;// CONCATENATED MODULE: ./src/primitives/types/classes.js
/* eslint-disable sort-imports */















const classes_Classes = {
  axis: Axis,
  face: Face,
  grid: Grid,
  line: Line,
  point: Point,
  strip: Strip,
  surface: Surface,
  ticks: Ticks,
  vector: Vector,

  view: View,
  cartesian: Cartesian,
  cartesian4: Cartesian4,
  polar: Polar,
  spherical: Spherical,
  stereographic: Stereographic,
  stereographic4: Stereographic4,

  transform: Transform3,
  transform4: Transform4,
  vertex: Vertex,
  fragment: Fragment,
  layer: Layer,
  mask: Mask,

  array: Array_,
  interval: Interval,
  matrix: Matrix,
  area: Area,
  voxel: Voxel,
  volume: Volume,
  scale: Scale,
  latch: Latch,

  html: HTML,
  dom: dom_DOM,

  text: Text,
  format: Format,
  label: Label,
  retext: Retext,

  clamp: Clamp,
  grow: Grow,
  join: Join,
  lerp: Lerp,
  memo: Memo,
  readback: Readback,
  resample: Resample,
  repeat: Repeat,
  reverse: Reverse,
  swizzle: Swizzle,
  spread: Spread,
  split: Split,
  slice: Slice,
  subdivide: Subdivide,
  transpose: Transpose,

  group: group_Group,
  inherit: Inherit,
  root: Root,
  unit: Unit,

  shader: Shader,

  camera: Camera,

  rtt: RTT,
  compose: Compose,

  clock: Clock,
  now: Now,

  move: Move,
  play: Play,
  present: Present,
  reveal: Reveal,
  slide: Slide,
  step: Step,
};

;// CONCATENATED MODULE: ./src/primitives/types/types.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */






// Property types
//
// The weird calling convention is for double-buffering the values
// while validating compound types like arrays and nullables.
//
// validate: (value, target, invalid) ->
//
//   # Option 1: Call invalid() to reject
//   return invalid() if value < 0
//
//   # Option 2: Change target in-place
//   target.set(value)
//   return target
//
//   # Option 3: Return new value
//   return +value
//
const _Types = {
  array(type, size, value = null) {
    const lerp = type.lerp
      ? function (a, b, target, f) {
          const l = Math.min(a.length, b.length);
          for (
            let i = 0, end = l, asc = 0 <= end;
            asc ? i < end : i > end;
            asc ? i++ : i--
          ) {
            target[i] = type.lerp(a[i], b[i], target[i], f);
          }
          return target;
        }
      : undefined;

    const op = type.op
      ? function (a, b, target, op) {
          const l = Math.min(a.length, b.length);
          for (
            let i = 0, end = l, asc = 0 <= end;
            asc ? i < end : i > end;
            asc ? i++ : i--
          ) {
            target[i] = type.op(a[i], b[i], target[i], op);
          }
          return target;
        }
      : undefined;

    if (value != null && !(value instanceof Array)) {
      value = [value];
    }

    return {
      uniform() {
        if (type.uniform) {
          return type.uniform() + "v";
        } else {
          return undefined;
        }
      },
      make() {
        if (value != null) {
          return value.slice();
        }
        if (!size) {
          return [];
        }
        return types_range_(0, size, false).map((_i) => type.make());
      },
      validate(value, target, invalid) {
        if (!(value instanceof Array)) {
          value = [value];
        }

        const l = (target.length = size ? size : value.length);
        for (
          let i = 0, end = l, asc = 0 <= end;
          asc ? i < end : i > end;
          asc ? i++ : i--
        ) {
          const input = value[i] != null ? value[i] : type.make();
          target[i] = type.validate(input, target[i], invalid);
        }

        return target;
      },
      equals(a, b) {
        const al = a.length;
        const bl = b.length;
        if (al !== bl) {
          return false;
        }

        const l = Math.min(al, bl);
        for (
          let i = 0, end = l, asc = 0 <= end;
          asc ? i < end : i > end;
          asc ? i++ : i--
        ) {
          if (
            !(typeof type.equals === "function"
              ? type.equals(a[i], b[i])
              : undefined)
          ) {
            return false;
          }
        }
        return true;
      },
      lerp,
      op,
      clone(v) {
        return Array.from(v).map((x) => type.clone(x));
      },
    };
  },

  letters(type, size, value = null) {
    if (value != null) {
      if (value === "" + value) {
        value = value.split("");
      }
      for (let i = 0; i < value.length; i++) {
        const v = value[i];
        value[i] = type.validate(v, v);
      }
    }

    const array = types_Types.array(type, size, value);

    return {
      uniform() {
        return array.uniform();
      },
      make() {
        return array.make();
      },
      validate(value, target, invalid) {
        if (value === "" + value) {
          value = value.split("");
        }
        return array.validate(value, target, invalid);
      },
      equals(a, b) {
        return array.equals(a, b);
      },
      clone: array.clone,
    };
  },

  nullable(type, make) {
    if (make == null) {
      make = false;
    }
    let value = make ? type.make() : null;

    const emitter = type.emitter
      ? function (expr1, expr2) {
          if (expr2 == null) {
            return expr1;
          }
          if (expr1 == null) {
            return expr2;
          }
          return type.emitter(expr1, expr2);
        }
      : undefined;

    const lerp = type.lerp
      ? function (a, b, target, f) {
          if (a === null || b === null) {
            if (f < 0.5) {
              return a;
            } else {
              return b;
            }
          }
          if (target == null) {
            target = type.make();
          }
          value = type.lerp(a, b, target, f);
          return target;
        }
      : undefined;

    const op = type.op
      ? function (a, b, target, op) {
          if (a === null || b === null) {
            return null;
          }
          if (target == null) {
            target = type.make();
          }
          value = type.op(a, b, target, op);
          return value;
        }
      : undefined;

    return {
      make() {
        return value;
      },
      validate(value, target, invalid) {
        if (value === null) {
          return value;
        }
        if (target === null) {
          target = type.make();
        }
        return type.validate(value, target, invalid);
      },
      uniform() {
        return typeof type.uniform === "function" ? type.uniform() : undefined;
      },
      equals(a, b) {
        let left;
        const an = a === null;
        const bn = b === null;
        if (an && bn) {
          return true;
        }
        if (an ^ bn) {
          return false;
        }
        return (left =
          typeof type.equals === "function" ? type.equals(a, b) : undefined) !=
          null
          ? left
          : a === b;
      },
      lerp,
      op,
      emitter,
    };
  },

  enum(value, keys, map) {
    let key;
    if (keys == null) {
      keys = [];
    }
    if (map == null) {
      map = {};
    }
    let i = 0;
    const values = {};
    for (key of Array.from(keys)) {
      if (key !== +key) {
        if (map[key] == null) {
          map[key] = i++;
        }
      }
    }
    for (key of Array.from(keys)) {
      if (key === +key) {
        values[key] = key;
      }
    }
    for (key in map) {
      i = map[key];
      values[i] = true;
    }

    if (values[value] == null) {
      value = map[value];
    }

    return {
      enum() {
        return map;
      },
      make() {
        return value;
      },
      validate(value, target, invalid) {
        const v = values[value] ? value : map[value];
        if (v != null) {
          return v;
        }
        return invalid();
      },
    };
  },

  enumber(value, keys, map) {
    if (map == null) {
      map = {};
    }
    const _enum = types_Types.enum(value, keys, map);

    return {
      enum: _enum.enum,
      uniform() {
        return "f";
      },
      make() {
        let left;
        return (left = _enum.make()) != null ? left : +value;
      },
      validate(value, target, invalid) {
        if (value === +value) {
          return value;
        }
        return _enum.validate(value, target, invalid);
      },
      op(a, b, target, op) {
        return op(a, b);
      },
    };
  },

  select(value) {
    if (value == null) {
      value = "<";
    }
    value;
    return {
      make() {
        return value;
      },
      validate(value, target, invalid) {
        if (typeof value === "string") {
          return value;
        }
        if (typeof value === "object") {
          return value;
        }
        return invalid();
      },
    };
  },

  bool(value) {
    value = !!value;
    return {
      uniform() {
        return "f";
      },
      make() {
        return value;
      },
      validate(value, _target, _invalid) {
        return !!value;
      },
    };
  },

  int(value) {
    if (value == null) {
      value = 0;
    }
    value = +Math.round(value);
    return {
      uniform() {
        return "i";
      },
      make() {
        return value;
      },
      validate(value, target, invalid) {
        let x;
        if (value !== (x = +value)) {
          return invalid();
        }
        return Math.round(x) || 0;
      },
      op(a, b, target, op) {
        return op(a, b);
      },
    };
  },

  round(value) {
    if (value == null) {
      value = 0;
    }
    value = +Math.round(value);
    return {
      uniform() {
        return "f";
      },
      make() {
        return value;
      },
      validate(value, target, invalid) {
        let x;
        if (value !== (x = +value)) {
          return invalid();
        }
        return Math.round(x) || 0;
      },
      op(a, b, target, op) {
        return op(a, b);
      },
    };
  },

  number(value) {
    if (value == null) {
      value = 0;
    }
    return {
      uniform() {
        return "f";
      },
      make() {
        return +value;
      },
      validate(value, target, invalid) {
        let x;
        if (value !== (x = +value)) {
          return invalid();
        }
        return x || 0;
      },
      op(a, b, target, op) {
        return op(a, b);
      },
    };
  },

  positive(type, strict) {
    if (strict == null) {
      strict = false;
    }
    return {
      uniform: type.uniform,
      make: type.make,
      validate(value, target, invalid) {
        value = type.validate(value, target, invalid);
        if (value < 0 || (strict && value <= 0)) {
          return invalid();
        }
        return value;
      },
      op(a, b, target, op) {
        return op(a, b);
      },
    };
  },

  string(value) {
    if (value == null) {
      value = "";
    }
    return {
      make() {
        return "" + value;
      },
      validate(value, target, invalid) {
        let x;
        if (value !== (x = "" + value)) {
          return invalid();
        }
        return x;
      },
    };
  },

  func() {
    return {
      make() {
        return function () {};
      },
      validate(value, target, invalid) {
        if (typeof value === "function") {
          return value;
        }
        return invalid();
      },
    };
  },

  emitter() {
    return {
      make() {
        return (emit) => emit(1, 1, 1, 1);
      },
      validate(value, target, invalid) {
        if (typeof value === "function") {
          return value;
        }
        return invalid();
      },
      emitter(a, b) {
        return getLerpEmitter(a, b);
      },
    };
  },

  object(value) {
    return {
      make() {
        return value != null ? value : {};
      },
      validate(value, target, invalid) {
        if (typeof value === "object") {
          return value;
        }
        return invalid();
      },
      clone(v) {
        return JSON.parse(JSON.stringify(v));
      },
    };
  },

  timestamp(value = null) {
    if (typeof value === "string") {
      value = Date.parse(value);
    }

    return {
      uniform() {
        return "f";
      },
      make() {
        return value != null ? value : +new Date();
      },
      validate(value, target, invalid) {
        value = Date.parse(value);
        if (value !== +value) {
          return invalid();
        }
        return value;
      },
      op(a, b, target, op) {
        return op(a, b);
      },
    };
  },

  vec2(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    const defaults = [x, y];
    return {
      uniform() {
        return "v2";
      },
      make() {
        return new external_THREE_.Vector2(x, y);
      },
      validate(value, target, invalid) {
        if (value === +value) {
          value = [value];
        }

        if (value?.isVector2) {
          target.copy(value);
        } else if (value instanceof Array) {
          value = value.concat(defaults.slice(value.length));
          target.set.apply(target, value);
        } else if (value != null) {
          const xx = value.x != null ? value.x : x;
          const yy = value.y != null ? value.y : y;
          target.set(xx, yy);
        } else {
          return invalid();
        }
        return target;
      },

      equals(a, b) {
        return a.x === b.x && a.y === b.y;
      },
      op(a, b, target, op) {
        target.x = op(a.x, b.x);
        target.y = op(a.y, b.y);
        return target;
      },
    };
  },

  ivec2(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    const vec2 = types_Types.vec2(x, y);
    const { validate } = vec2;
    vec2.validate = function (value, target, invalid) {
      validate(value, target, invalid);
      target.x = Math.round(target.x);
      target.y = Math.round(target.y);
      return target;
    };
    return vec2;
  },

  vec3(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    const defaults = [x, y, z];
    return {
      uniform() {
        return "v3";
      },
      make() {
        return new external_THREE_.Vector3(x, y, z);
      },
      validate(value, target, invalid) {
        if (value === +value) {
          value = [value];
        }

        if (value?.isVector3) {
          target.copy(value);
        } else if (value instanceof Array) {
          value = value.concat(defaults.slice(value.length));
          target.set.apply(target, value);
        } else if (value != null) {
          const xx = value.x != null ? value.x : x;
          const yy = value.y != null ? value.y : y;
          const zz = value.z != null ? value.z : z;
          target.set(xx, yy, zz);
        } else {
          return invalid();
        }
        return target;
      },

      equals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z;
      },
      op(a, b, target, op) {
        target.x = op(a.x, b.x);
        target.y = op(a.y, b.y);
        target.z = op(a.z, b.z);
        return target;
      },
    };
  },

  ivec3(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    const vec3 = types_Types.vec3(x, y, z);
    const { validate } = vec3;
    vec3.validate = function (value, target, invalid) {
      validate(value, target, invalid);
      target.x = Math.round(target.x);
      target.y = Math.round(target.y);
      target.z = Math.round(target.z);
      return target;
    };
    return vec3;
  },

  vec4(x, y, z, w) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    if (w == null) {
      w = 0;
    }
    const defaults = [x, y, z, w];
    return {
      uniform() {
        return "v4";
      },
      make() {
        return new external_THREE_.Vector4(x, y, z, w);
      },
      validate(value, target, invalid) {
        if (value === +value) {
          value = [value];
        }

        if (value?.isVector4) {
          target.copy(value);
        } else if (value instanceof Array) {
          value = value.concat(defaults.slice(value.length));
          target.set.apply(target, value);
        } else if (value != null) {
          const xx = value.x != null ? value.x : x;
          const yy = value.y != null ? value.y : y;
          const zz = value.z != null ? value.z : z;
          const ww = value.w != null ? value.w : w;
          target.set(xx, yy, zz, ww);
        } else {
          return invalid();
        }
        return target;
      },
      equals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
      },
      op(a, b, target, op) {
        target.x = op(a.x, b.x);
        target.y = op(a.y, b.y);
        target.z = op(a.z, b.z);
        target.w = op(a.w, b.w);
        return target;
      },
    };
  },

  ivec4(x, y, z, w) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    if (w == null) {
      w = 0;
    }
    const vec4 = types_Types.vec4(x, y, z, w);
    const { validate } = vec4;
    vec4.validate = function (value, target, invalid) {
      validate(value, target, invalid);
      target.x = Math.round(target.x);
      target.y = Math.round(target.y);
      target.z = Math.round(target.z);
      target.w = Math.round(target.w);
      return target;
    };
    return vec4;
  },

  mat3(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    if (n11 == null) {
      n11 = 1;
    }
    if (n12 == null) {
      n12 = 0;
    }
    if (n13 == null) {
      n13 = 0;
    }
    if (n21 == null) {
      n21 = 0;
    }
    if (n22 == null) {
      n22 = 1;
    }
    if (n23 == null) {
      n23 = 0;
    }
    if (n31 == null) {
      n31 = 0;
    }
    if (n32 == null) {
      n32 = 0;
    }
    if (n33 == null) {
      n33 = 1;
    }
    const defaults = [n11, n12, n13, n21, n22, n23, n31, n32, n33];

    return {
      uniform() {
        return "m4";
      },
      make() {
        const m = new external_THREE_.Matrix3();
        m.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
        return m;
      },
      validate(value, target, invalid) {
        if (value?.isMatrix3) {
          target.copy(value);
        } else if (value instanceof Array) {
          value = value.concat(defaults.slice(value.length));
          target.set.apply(target, value);
        } else {
          return invalid();
        }
        return target;
      },
    };
  },

  mat4(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44
  ) {
    if (n11 == null) {
      n11 = 1;
    }
    if (n12 == null) {
      n12 = 0;
    }
    if (n13 == null) {
      n13 = 0;
    }
    if (n14 == null) {
      n14 = 0;
    }
    if (n21 == null) {
      n21 = 0;
    }
    if (n22 == null) {
      n22 = 1;
    }
    if (n23 == null) {
      n23 = 0;
    }
    if (n24 == null) {
      n24 = 0;
    }
    if (n31 == null) {
      n31 = 0;
    }
    if (n32 == null) {
      n32 = 0;
    }
    if (n33 == null) {
      n33 = 1;
    }
    if (n34 == null) {
      n34 = 0;
    }
    if (n41 == null) {
      n41 = 0;
    }
    if (n42 == null) {
      n42 = 0;
    }
    if (n43 == null) {
      n43 = 0;
    }
    if (n44 == null) {
      n44 = 1;
    }
    const defaults = [
      n11,
      n12,
      n13,
      n14,
      n21,
      n22,
      n23,
      n24,
      n31,
      n32,
      n33,
      n34,
      n41,
      n42,
      n43,
      n44,
    ];

    return {
      uniform() {
        return "m4";
      },
      make() {
        const m = new external_THREE_.Matrix4();
        m.set(
          n11,
          n12,
          n13,
          n14,
          n21,
          n22,
          n23,
          n24,
          n31,
          n32,
          n33,
          n34,
          n41,
          n42,
          n43,
          n44
        );
        return m;
      },
      validate(value, target, invalid) {
        if (value?.isMatrix4) {
          target.copy(value);
        } else if (value instanceof Array) {
          value = value.concat(defaults.slice(value.length));
          target.set.apply(target, value);
        } else {
          return invalid();
        }
        return target;
      },
    };
  },

  quat(x, y, z, w) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    if (w == null) {
      w = 1;
    }
    const vec4 = types_Types.vec4(x, y, z, w);

    return {
      uniform() {
        return "v4";
      },
      make() {
        return new external_THREE_.Quaternion();
      },
      validate(value, target, invalid) {
        if (value?.isQuaternion) {
          target.copy(value);
        } else {
          target = vec4.validate(value, target, invalid);
        }
        target.normalize();
        return target;
      },
      equals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
      },
      op(a, b, target, op) {
        target.x = op(a.x, b.x);
        target.y = op(a.y, b.y);
        target.z = op(a.z, b.z);
        target.w = op(a.w, b.w);
        target.normalize();
        return target;
      },
      lerp(a, b, target, f) {
        if (target.slerpQuaternions) {
          // NOTE: slerpQuaternions replaced the static slerp method in three.js
          // r127. This switch removes the deprecation warning and keeps the
          // project three.js compatible across this version.
          target.slerpQuaternions(a, b, f);
        } else {
          external_THREE_.Quaternion.slerp(a, b, target, f);
        }
        return target;
      },
    };
  },

  color(r, g, b) {
    if (r == null) {
      r = 0.5;
    }
    if (g == null) {
      g = 0.5;
    }
    if (b == null) {
      b = 0.5;
    }
    const defaults = [r, g, b];

    return {
      uniform() {
        return "c";
      },
      make() {
        return new external_THREE_.Color(r, g, b);
      },
      validate(value, target, invalid) {
        if (value === "" + value) {
          value = new external_THREE_.Color().setStyle(value);
        } else if (value === +value) {
          value = new external_THREE_.Color(value);
        }

        if (value?.isColor) {
          target.copy(value);
        } else if (value instanceof Array) {
          value = value.concat(defaults.slice(value.length));
          target.setRGB.apply(target, value);
        } else if (value != null) {
          const rr = value.r != null ? value.r : r;
          const gg = value.g != null ? value.g : g;
          const bb = value.b != null ? value.b : b;
          target.set(rr, gg, bb);
        } else {
          return invalid();
        }
        return target;
      },

      equals(a, b) {
        return a.r === b.r && a.g === b.g && a.b === b.b;
      },
      op(a, b, target, op) {
        target.r = op(a.r, b.r);
        target.g = op(a.g, b.g);
        target.b = op(a.b, b.b);
        return target;
      },
    };
  },

  axis(value, allowZero) {
    let v;
    if (value == null) {
      value = 1;
    }
    if (allowZero == null) {
      allowZero = false;
    }
    const map = {
      x: 1,
      y: 2,
      z: 3,
      w: 4,
      W: 1,
      H: 2,
      D: 3,
      I: 4,
      zero: 0,
      null: 0,
      width: 1,
      height: 2,
      depth: 3,
      items: 4,
    };

    const range = allowZero ? [0, 1, 2, 3, 4] : [1, 2, 3, 4];
    if ((v = map[value]) != null) {
      value = v;
    }

    return {
      make() {
        return value;
      },
      validate(value, target, invalid) {
        let left;
        if ((v = map[value]) != null) {
          value = v;
        }
        value = (left = Math.round(value)) != null ? left : 0;
        if (Array.from(range).includes(value)) {
          return value;
        }
        return invalid();
      },
    };
  },

  transpose(order) {
    if (order == null) {
      order = [1, 2, 3, 4];
    }
    const looseArray = types_Types.letters(types_Types.axis(null, false), 0, order);
    const axesArray = types_Types.letters(types_Types.axis(null, false), 4, order);

    return {
      make() {
        return axesArray.make();
      },
      validate(value, target, invalid) {
        let temp = [1, 2, 3, 4];
        looseArray.validate(value, temp, invalid);

        if (temp.length < 4) {
          const missing = [1, 2, 3, 4].filter((x) => temp.indexOf(x) === -1);
          temp = temp.concat(missing);
        }

        const unique = Array.from(temp).map(
          (letter, i) => temp.indexOf(letter) === i
        );
        if (unique.indexOf(false) < 0) {
          return axesArray.validate(temp, target, invalid);
        }
        return invalid();
      },
      equals: axesArray.equals,
      clone: axesArray.clone,
    };
  },

  swizzle(order, size = null) {
    if (order == null) {
      order = [1, 2, 3, 4];
    }
    if (size == null) {
      size = order.length;
    }
    order = order.slice(0, size);
    const looseArray = types_Types.letters(types_Types.axis(null, false), 0, order);
    const axesArray = types_Types.letters(types_Types.axis(null, true), size, order);

    return {
      make() {
        return axesArray.make();
      },
      validate(value, target, invalid) {
        let temp = order.slice();
        looseArray.validate(value, temp, invalid);

        if (temp.length < size) {
          temp = temp.concat([0, 0, 0, 0]).slice(0, size);
        }

        return axesArray.validate(temp, target, invalid);
      },
      equals: axesArray.equals,
      clone: axesArray.clone,
    };
  },

  classes() {
    const stringArray = types_Types.array(types_Types.string());

    return {
      make() {
        return stringArray.make();
      },
      validate(value, target, invalid) {
        if (value === "" + value) {
          value = value.split(" ");
        }
        value = value.filter((x) => !!x.length);
        return stringArray.validate(value, target, invalid);
      },
      equals: stringArray.equals,
      clone: stringArray.clone,
    };
  },

  blending(value) {
    if (value == null) {
      value = "normal";
    }
    const keys = ["no", "normal", "add", "subtract", "multiply", "custom"];
    return types_Types.enum(value, keys);
  },

  filter(value) {
    if (value == null) {
      value = "nearest";
    }
    const map = {
      nearest: external_THREE_.NearestFilter,
      nearestMipMapNearest: external_THREE_.NearestMipMapNearestFilter,
      nearestMipMapLinear: external_THREE_.NearestMipMapLinearFilter,
      linear: external_THREE_.LinearFilter,
      linearMipMapNearest: external_THREE_.LinearMipMapNearestFilter,
      linearMipmapLinear: external_THREE_.LinearMipMapLinearFilter,
    };

    return types_Types.enum(value, [], map);
  },

  type(value) {
    if (value == null) {
      value = "unsignedByte";
    }
    const map = {
      unsignedByte: external_THREE_.UnsignedByteType,
      byte: external_THREE_.ByteType,
      short: external_THREE_.ShortType,
      unsignedShort: external_THREE_.UnsignedShortType,
      int: external_THREE_.IntType,
      unsignedInt: external_THREE_.UnsignedIntType,
      float: external_THREE_.FloatType,
    };

    return types_Types.enum(value, [], map);
  },

  scale(value) {
    if (value == null) {
      value = "linear";
    }
    const keys = ["linear", "log"];
    return types_Types.enum(value, keys);
  },

  mapping(value) {
    if (value == null) {
      value = "relative";
    }
    const keys = ["relative", "absolute"];
    return types_Types.enum(value, keys);
  },

  indexing(value) {
    if (value == null) {
      value = "original";
    }
    const keys = ["original", "final"];
    return types_Types.enum(value, keys);
  },

  shape(value) {
    if (value == null) {
      value = "circle";
    }
    const keys = ["circle", "square", "diamond", "up", "down", "left", "right"];
    return types_Types.enum(value, keys);
  },

  join(value) {
    if (value == null) {
      value = "miter";
    }
    const keys = ["miter", "round", "bevel"];
    return types_Types.enum(value, keys);
  },

  stroke(value) {
    if (value == null) {
      value = "solid";
    }
    const keys = ["solid", "dotted", "dashed"];
    return types_Types.enum(value, keys);
  },

  vertexPass(value) {
    if (value == null) {
      value = "view";
    }
    const keys = ["data", "view", "world", "eye"];
    return types_Types.enum(value, keys);
  },

  fragmentPass(value) {
    if (value == null) {
      value = "light";
    }
    const keys = ["color", "light", "rgba"];
    return types_Types.enum(value, keys);
  },

  ease(value) {
    if (value == null) {
      value = "linear";
    }
    const keys = ["linear", "cosine", "binary", "hold"];
    return types_Types.enum(value, keys);
  },

  fit(value) {
    if (value == null) {
      value = "contain";
    }
    const keys = ["x", "y", "contain", "cover"];
    return types_Types.enum(value, keys);
  },

  anchor(value) {
    if (value == null) {
      value = "middle";
    }
    const map = {
      first: 1,
      middle: 0,
      last: -1,
    };

    return types_Types.enumber(value, [], map);
  },

  transitionState(value) {
    if (value == null) {
      value = "enter";
    }
    const map = {
      enter: -1,
      visible: 0,
      exit: 1,
    };

    return types_Types.enumber(value, [], map);
  },

  font(value) {
    if (value == null) {
      value = "sans-serif";
    }
    const parse = parseQuoted;
    if (!(value instanceof Array)) {
      value = parse(value);
    }
    const stringArray = types_Types.array(types_Types.string(), 0, value);

    return {
      make() {
        return stringArray.make();
      },
      validate(value, target, invalid) {
        try {
          if (!(value instanceof Array)) {
            value = parse(value);
          }
        } catch (error) {
          return invalid();
        }

        value = value.filter((x) => !!x.length);
        return stringArray.validate(value, target, invalid);
      },
      equals: stringArray.equals,
      clone: stringArray.clone,
    };
  },

  data(value) {
    if (value == null) {
      value = [];
    }
    return {
      make() {
        return [];
      },
      validate(value, target, invalid) {
        if (value instanceof Array) {
          return value;
        } else if ((value != null ? value.length : undefined) != null) {
          return value;
        } else {
          return invalid();
        }
      },

      emitter(a, b) {
        return getLerpThunk(a, b);
      },
    };
  },
};

const decorate = function (types) {
  for (const k in types) {
    const type = types[k];
    types[k] = ((type) =>
      function () {
        const t = type.apply(type, arguments);
        if (t.validate == null) {
          t.validate = (v) => v != null;
        }
        if (t.equals == null) {
          t.equals = (a, b) => a === b;
        }
        if (t.clone == null) {
          t.clone = function (v) {
            let left;
            return (left = types_guardMethod_(v, "clone", (o) => o.clone())) !=
              null
              ? left
              : v;
          };
        }
        return t;
      })(type);
  }
  return types;
};

const types_Types = decorate(_Types);

function types_range_(left, right, inclusive) {
  const range = [];
  const ascending = left < right;
  const end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}
function types_guardMethod_(obj, methodName, transform) {
  if (
    typeof obj !== "undefined" &&
    obj !== null &&
    typeof obj[methodName] === "function"
  ) {
    return transform(obj, methodName);
  } else {
    return undefined;
  }
}

;// CONCATENATED MODULE: ./src/primitives/types/types_typed.ts

const types_typed_Types = types_Types;

;// CONCATENATED MODULE: ./src/primitives/types/traits.ts
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.

const Traits = {
    node: {
        id: types_typed_Types.nullable(types_typed_Types.string()),
        classes: types_typed_Types.classes(),
    },
    entity: {
        active: types_typed_Types.bool(true),
    },
    object: {
        visible: types_typed_Types.bool(true),
    },
    latch: {
        data: types_typed_Types.nullable(types_typed_Types.object()),
        deep: types_typed_Types.nullable(types_typed_Types.bool(true)),
    },
    unit: {
        scale: types_typed_Types.nullable(types_typed_Types.number()),
        fov: types_typed_Types.nullable(types_typed_Types.number()),
        focus: types_typed_Types.nullable(types_typed_Types.number(1), true),
    },
    span: {
        range: types_typed_Types.nullable(types_typed_Types.vec2(-1, 1)),
    },
    view: {
        range: types_typed_Types.array(types_typed_Types.vec2(-1, 1), 4),
    },
    view3: {
        position: types_typed_Types.vec3(),
        quaternion: types_typed_Types.quat(),
        rotation: types_typed_Types.vec3(),
        scale: types_typed_Types.vec3(1, 1, 1),
        eulerOrder: types_typed_Types.swizzle("xyz"),
    },
    view4: {
        position: types_typed_Types.vec4(),
        scale: types_typed_Types.vec4(1, 1, 1, 1),
    },
    layer: {
        depth: types_typed_Types.number(1),
        fit: types_typed_Types.fit("y"),
    },
    vertex: {
        pass: types_typed_Types.vertexPass(),
    },
    fragment: {
        pass: types_typed_Types.fragmentPass(),
        gamma: types_typed_Types.bool(false),
    },
    transform3: {
        position: types_typed_Types.vec3(),
        quaternion: types_typed_Types.quat(),
        rotation: types_typed_Types.vec3(),
        eulerOrder: types_typed_Types.swizzle("xyz"),
        scale: types_typed_Types.vec3(1, 1, 1),
        matrix: types_typed_Types.mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
    },
    transform4: {
        position: types_typed_Types.vec4(),
        scale: types_typed_Types.vec4(1, 1, 1, 1),
        matrix: types_typed_Types.mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
    },
    camera: {
        proxy: types_typed_Types.bool(false),
        position: types_typed_Types.nullable(types_typed_Types.vec3()),
        quaternion: types_typed_Types.nullable(types_typed_Types.quat()),
        rotation: types_typed_Types.nullable(types_typed_Types.vec3()),
        lookAt: types_typed_Types.nullable(types_typed_Types.vec3()),
        up: types_typed_Types.nullable(types_typed_Types.vec3()),
        eulerOrder: types_typed_Types.swizzle("xyz"),
        fov: types_typed_Types.nullable(types_typed_Types.number(1)),
    },
    //ortho:             Types.nullable(Types.number(0))
    polar: {
        bend: types_typed_Types.number(1),
        helix: types_typed_Types.number(0),
    },
    spherical: {
        bend: types_typed_Types.number(1),
    },
    stereographic: {
        bend: types_typed_Types.number(1),
    },
    interval: {
        axis: types_typed_Types.axis(),
    },
    area: {
        axes: types_typed_Types.swizzle([1, 2], 2),
    },
    volume: {
        axes: types_typed_Types.swizzle([1, 2, 3], 3),
    },
    origin: {
        origin: types_typed_Types.vec4(),
    },
    scale: {
        divide: types_typed_Types.number(10),
        unit: types_typed_Types.number(1),
        base: types_typed_Types.number(10),
        mode: types_typed_Types.scale(),
        start: types_typed_Types.bool(true),
        end: types_typed_Types.bool(true),
        zero: types_typed_Types.bool(true),
        factor: types_typed_Types.positive(types_typed_Types.number(1)),
        nice: types_typed_Types.bool(true),
    },
    grid: {
        lineX: types_typed_Types.bool(true),
        lineY: types_typed_Types.bool(true),
        crossed: types_typed_Types.bool(false),
        closedX: types_typed_Types.bool(false),
        closedY: types_typed_Types.bool(false),
    },
    axis: {
        detail: types_typed_Types.int(1),
        crossed: types_typed_Types.bool(false),
    },
    data: {
        data: types_typed_Types.nullable(types_typed_Types.data()),
        expr: types_typed_Types.nullable(types_typed_Types.emitter()),
        bind: types_typed_Types.nullable(types_typed_Types.func()),
        live: types_typed_Types.bool(true),
    },
    buffer: {
        channels: types_typed_Types["enum"](4, [1, 2, 3, 4]),
        items: types_typed_Types.int(1),
        fps: types_typed_Types.nullable(types_typed_Types.int(60)),
        hurry: types_typed_Types.int(5),
        limit: types_typed_Types.int(60),
        realtime: types_typed_Types.bool(false),
        observe: types_typed_Types.bool(false),
        aligned: types_typed_Types.bool(false),
    },
    sampler: {
        centered: types_typed_Types.bool(false),
        padding: types_typed_Types.number(0),
    },
    array: {
        width: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(1), true)),
        bufferWidth: types_typed_Types.int(1),
        history: types_typed_Types.int(1),
    },
    matrix: {
        width: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(1), true)),
        height: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(1), true)),
        history: types_typed_Types.int(1),
        bufferWidth: types_typed_Types.int(1),
        bufferHeight: types_typed_Types.int(1),
    },
    voxel: {
        width: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(1), true)),
        height: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(1), true)),
        depth: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(1), true)),
        bufferWidth: types_typed_Types.int(1),
        bufferHeight: types_typed_Types.int(1),
        bufferDepth: types_typed_Types.int(1),
    },
    resolve: {
        expr: types_typed_Types.nullable(types_typed_Types.func()),
        items: types_typed_Types.int(1),
    },
    style: {
        opacity: types_typed_Types.positive(types_typed_Types.number(1)),
        color: types_typed_Types.color(),
        blending: types_typed_Types.blending(),
        zWrite: types_typed_Types.bool(true),
        zTest: types_typed_Types.bool(true),
        zIndex: types_typed_Types.positive(types_typed_Types.round()),
        zBias: types_typed_Types.number(0),
        zOrder: types_typed_Types.nullable(types_typed_Types.int()),
    },
    geometry: {
        points: types_typed_Types.select(),
        colors: types_typed_Types.nullable(types_typed_Types.select()),
    },
    point: {
        size: types_typed_Types.positive(types_typed_Types.number(4)),
        sizes: types_typed_Types.nullable(types_typed_Types.select()),
        shape: types_typed_Types.shape(),
        optical: types_typed_Types.bool(true),
        fill: types_typed_Types.bool(true),
        depth: types_typed_Types.number(1),
    },
    line: {
        width: types_typed_Types.positive(types_typed_Types.number(2)),
        depth: types_typed_Types.positive(types_typed_Types.number(1)),
        join: types_typed_Types.join(),
        stroke: types_typed_Types.stroke(),
        proximity: types_typed_Types.nullable(types_typed_Types.number(Infinity)),
        closed: types_typed_Types.bool(false),
    },
    mesh: {
        fill: types_typed_Types.bool(true),
        shaded: types_typed_Types.bool(false),
        normals: types_typed_Types.nullable(types_typed_Types.select()),
        map: types_typed_Types.nullable(types_typed_Types.select()),
        lineBias: types_typed_Types.number(5),
    },
    strip: {
        line: types_typed_Types.bool(false),
    },
    face: {
        line: types_typed_Types.bool(false),
    },
    arrow: {
        size: types_typed_Types.number(3),
        start: types_typed_Types.bool(false),
        end: types_typed_Types.bool(false),
    },
    ticks: {
        normal: types_typed_Types.vec3(0, 0, 1),
        size: types_typed_Types.positive(types_typed_Types.number(10)),
        epsilon: types_typed_Types.positive(types_typed_Types.number(0.001)),
    },
    attach: {
        offset: types_typed_Types.vec2(0, -20),
        snap: types_typed_Types.bool(false),
        depth: types_typed_Types.number(0),
    },
    format: {
        digits: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.number(3))),
        data: types_typed_Types.nullable(types_typed_Types.data()),
        expr: types_typed_Types.nullable(types_typed_Types.func()),
        live: types_typed_Types.bool(true),
    },
    font: {
        font: types_typed_Types.font("sans-serif"),
        style: types_typed_Types.string(),
        variant: types_typed_Types.string(),
        weight: types_typed_Types.string(),
        detail: types_typed_Types.number(24),
        sdf: types_typed_Types.number(5),
    },
    label: {
        text: types_typed_Types.select(),
        size: types_typed_Types.number(16),
        outline: types_typed_Types.number(2),
        expand: types_typed_Types.number(0),
        background: types_typed_Types.color(1, 1, 1),
    },
    overlay: {
        opacity: types_typed_Types.number(1),
        zIndex: types_typed_Types.positive(types_typed_Types.round(0)),
    },
    dom: {
        points: types_typed_Types.select(),
        html: types_typed_Types.select(),
        size: types_typed_Types.number(16),
        outline: types_typed_Types.number(2),
        zoom: types_typed_Types.number(1),
        color: types_typed_Types.nullable(types_typed_Types.color()),
        attributes: types_typed_Types.nullable(types_typed_Types.object()),
        pointerEvents: types_typed_Types.bool(false),
    },
    texture: {
        minFilter: types_typed_Types.filter("nearest"),
        magFilter: types_typed_Types.filter("nearest"),
        type: types_typed_Types.type("float"),
    },
    shader: {
        sources: types_typed_Types.nullable(types_typed_Types.select()),
        indices: types_typed_Types.number(4),
        channels: types_typed_Types.number(4),
        language: types_typed_Types.string("glsl"),
        code: types_typed_Types.string(),
        uniforms: types_typed_Types.nullable(types_typed_Types.object()),
    },
    include: {
        shader: types_typed_Types.select(),
    },
    operator: {
        source: types_typed_Types.select(),
    },
    spread: {
        unit: types_typed_Types.mapping(),
        items: types_typed_Types.nullable(types_typed_Types.vec4()),
        width: types_typed_Types.nullable(types_typed_Types.vec4()),
        height: types_typed_Types.nullable(types_typed_Types.vec4()),
        depth: types_typed_Types.nullable(types_typed_Types.vec4()),
        alignItems: types_typed_Types.anchor(),
        alignWidth: types_typed_Types.anchor(),
        alignHeight: types_typed_Types.anchor(),
        alignDepth: types_typed_Types.anchor(),
    },
    grow: {
        scale: types_typed_Types.number(1),
        items: types_typed_Types.nullable(types_typed_Types.anchor()),
        width: types_typed_Types.nullable(types_typed_Types.anchor()),
        height: types_typed_Types.nullable(types_typed_Types.anchor()),
        depth: types_typed_Types.nullable(types_typed_Types.anchor()),
    },
    split: {
        order: types_typed_Types.transpose("wxyz"),
        axis: types_typed_Types.nullable(types_typed_Types.axis()),
        length: types_typed_Types.int(1),
        overlap: types_typed_Types.int(0),
    },
    join: {
        order: types_typed_Types.transpose("wxyz"),
        axis: types_typed_Types.nullable(types_typed_Types.axis()),
        overlap: types_typed_Types.int(0),
    },
    swizzle: {
        order: types_typed_Types.swizzle(),
    },
    transpose: {
        order: types_typed_Types.transpose(),
    },
    repeat: {
        items: types_typed_Types.number(1),
        width: types_typed_Types.number(1),
        height: types_typed_Types.number(1),
        depth: types_typed_Types.number(1),
    },
    slice: {
        items: types_typed_Types.nullable(types_typed_Types.vec2()),
        width: types_typed_Types.nullable(types_typed_Types.vec2()),
        height: types_typed_Types.nullable(types_typed_Types.vec2()),
        depth: types_typed_Types.nullable(types_typed_Types.vec2()),
    },
    reverse: {
        items: types_typed_Types.bool(false),
        width: types_typed_Types.bool(false),
        height: types_typed_Types.bool(false),
        depth: types_typed_Types.bool(false),
    },
    lerp: {
        size: types_typed_Types.mapping("absolute"),
        items: types_typed_Types.nullable(types_typed_Types.number()),
        width: types_typed_Types.nullable(types_typed_Types.number()),
        height: types_typed_Types.nullable(types_typed_Types.number()),
        depth: types_typed_Types.nullable(types_typed_Types.number()),
    },
    subdivide: {
        items: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(), true)),
        width: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(), true)),
        height: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(), true)),
        depth: types_typed_Types.nullable(types_typed_Types.positive(types_typed_Types.int(), true)),
        bevel: types_typed_Types.number(1),
        lerp: types_typed_Types.bool(true),
    },
    resample: {
        indices: types_typed_Types.number(4),
        channels: types_typed_Types.number(4),
        sample: types_typed_Types.mapping(),
        size: types_typed_Types.mapping("absolute"),
        items: types_typed_Types.nullable(types_typed_Types.number()),
        width: types_typed_Types.nullable(types_typed_Types.number()),
        height: types_typed_Types.nullable(types_typed_Types.number()),
        depth: types_typed_Types.nullable(types_typed_Types.number()),
    },
    readback: {
        type: types_typed_Types.type("float"),
        expr: types_typed_Types.nullable(types_typed_Types.func()),
        data: types_typed_Types.data(),
        channels: types_typed_Types["enum"](4, [1, 2, 3, 4]),
        items: types_typed_Types.nullable(types_typed_Types.int()),
        width: types_typed_Types.nullable(types_typed_Types.int()),
        height: types_typed_Types.nullable(types_typed_Types.int()),
        depth: types_typed_Types.nullable(types_typed_Types.int()),
    },
    root: {
        speed: types_typed_Types.number(1),
        camera: types_typed_Types.select("[camera]"),
    },
    inherit: {
        source: types_typed_Types.select(),
        traits: types_typed_Types.array(types_typed_Types.string()),
    },
    rtt: {
        size: types_typed_Types.mapping("absolute"),
        width: types_typed_Types.nullable(types_typed_Types.number()),
        height: types_typed_Types.nullable(types_typed_Types.number()),
        history: types_typed_Types.int(1),
    },
    compose: {
        alpha: types_typed_Types.bool(false),
    },
    present: {
        index: types_typed_Types.int(1),
        directed: types_typed_Types.bool(true),
        length: types_typed_Types.number(0),
    },
    slide: {
        order: types_typed_Types.nullable(types_typed_Types.int(0)),
        steps: types_typed_Types.number(1),
        early: types_typed_Types.int(0),
        late: types_typed_Types.int(0),
        from: types_typed_Types.nullable(types_typed_Types.int(0)),
        to: types_typed_Types.nullable(types_typed_Types.int(1)),
    },
    transition: {
        stagger: types_typed_Types.vec4(),
        enter: types_typed_Types.nullable(types_typed_Types.number(1)),
        exit: types_typed_Types.nullable(types_typed_Types.number(1)),
        delay: types_typed_Types.number(0),
        delayEnter: types_typed_Types.nullable(types_typed_Types.number(0)),
        delayExit: types_typed_Types.nullable(types_typed_Types.number(0)),
        duration: types_typed_Types.number(0.3),
        durationEnter: types_typed_Types.nullable(types_typed_Types.number(0)),
        durationExit: types_typed_Types.nullable(types_typed_Types.number(0)),
    },
    move: {
        from: types_typed_Types.vec4(),
        to: types_typed_Types.vec4(),
    },
    seek: {
        seek: types_typed_Types.nullable(types_typed_Types.number(0)),
    },
    track: {
        target: types_typed_Types.select(),
        script: types_typed_Types.object({}),
        ease: types_typed_Types.ease("cosine"),
    },
    trigger: {
        trigger: types_typed_Types.nullable(types_typed_Types.int(1), true),
    },
    step: {
        playback: types_typed_Types.ease("linear"),
        stops: types_typed_Types.nullable(types_typed_Types.array(types_typed_Types.number())),
        delay: types_typed_Types.number(0),
        duration: types_typed_Types.number(0.3),
        pace: types_typed_Types.number(0),
        speed: types_typed_Types.number(1),
        rewind: types_typed_Types.number(2),
        skip: types_typed_Types.bool(true),
        realtime: types_typed_Types.bool(false),
    },
    play: {
        delay: types_typed_Types.number(0),
        pace: types_typed_Types.number(1),
        speed: types_typed_Types.number(1),
        from: types_typed_Types.number(0),
        to: types_typed_Types.number(Infinity),
        realtime: types_typed_Types.bool(false),
        loop: types_typed_Types.bool(false),
    },
    now: {
        now: types_typed_Types.nullable(types_typed_Types.timestamp()),
        seek: types_typed_Types.nullable(types_typed_Types.number(0)),
        pace: types_typed_Types.number(1),
        speed: types_typed_Types.number(1),
    },
};

;// CONCATENATED MODULE: ./src/util/ticks.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
 Generate equally spaced ticks in a range at sensible positions.

 @param min/max - Minimum and maximum of range
 @param n - Desired number of ticks in range
 @param unit - Base unit of scale (e.g. 1 or π).
 @param scale - Division scale (e.g. 2 = binary division, or 10 = decimal division).
 @param bias - Integer to bias divisions one or more levels up or down (to create nested scales)
 @param start - Whether to include a tick at the start
 @param end - Whether to include a tick at the end
 @param zero - Whether to include zero as a tick
 @param nice - Whether to round to a more reasonable interval
*/

const linear = function (
  min,
  max,
  n,
  unit,
  base,
  factor,
  start,
  end,
  zero,
  nice
) {
  let ticks;
  let i, f;
  if (nice == null) {
    nice = true;
  }
  if (!n) {
    n = 10;
  }
  if (!unit) {
    unit = 1;
  }
  if (!base) {
    base = 10;
  }
  if (!factor) {
    factor = 1;
  }

  // Calculate naive tick size.
  const span = max - min;
  const ideal = span / n;

  // Unsnapped division
  if (!nice) {
    ticks = (() => {
      let asc, end1;
      const result = [];
      for (
        i = 0, end1 = n, asc = 0 <= end1;
        asc ? i <= end1 : i >= end1;
        asc ? i++ : i--
      ) {
        result.push(min + i * ideal);
      }
      return result;
    })();
    if (!start) {
      ticks.shift();
    }
    if (!end) {
      ticks.pop();
    }
    if (!zero) {
      ticks = ticks.filter((x) => x !== 0);
    }
    return ticks;
  }

  // Round to the floor'd power of 'scale'
  if (!unit) {
    unit = 1;
  }
  if (!base) {
    base = 10;
  }
  const ref =
    unit * Math.pow(base, Math.floor(Math.log(ideal / unit) / Math.log(base)));

  // Make derived steps at sensible factors.
  const factors =
    base % 2 === 0
      ? [base / 2, 1, 1 / 2]
      : base % 3 === 0
      ? [base / 3, 1, 1 / 3]
      : [1];
  const steps = (() => {
    const result1 = [];
    for (f of Array.from(factors)) {
      result1.push(ref * f);
    }
    return result1;
  })();

  // Find step size closest to ideal.
  let distance = Infinity;
  let step = steps.reduce(function (ref, step) {
    f = step / ideal;
    const d = Math.max(f, 1 / f);

    if (d < distance) {
      distance = d;
      return step;
    } else {
      return ref;
    }
  }, ref);

  // Scale final step
  step *= factor;

  // Renormalize min/max onto aligned steps.
  min = Math.ceil(min / step + +!start) * step;
  max = (Math.floor(max / step) - +!end) * step;
  n = Math.ceil((max - min) / step);

  // Generate equally spaced ticks
  ticks = (() => {
    let asc1, end2;
    const result2 = [];
    for (
      i = 0, end2 = n, asc1 = 0 <= end2;
      asc1 ? i <= end2 : i >= end2;
      asc1 ? i++ : i--
    ) {
      result2.push(min + i * step);
    }
    return result2;
  })();
  if (!zero) {
    ticks = ticks.filter((x) => x !== 0);
  }
  return ticks;
};

/*
 Generate logarithmically spaced ticks in a range at sensible positions.
*/

const log = function (
  _min,
  _max,
  _n,
  _unit,
  _base,
  _bias,
  _start,
  _end,
  _zero,
  _nice
) {
  throw new Error("Log ticks not yet implemented.");
};

const LINEAR = 0;
const LOG = 1;

const make = function (
  type,
  min,
  max,
  n,
  unit,
  base,
  bias,
  start,
  end,
  zero,
  nice
) {
  switch (type) {
    case LINEAR:
      return linear(min, max, n, unit, base, bias, start, end, zero, nice);
    case LOG:
      return log(min, max, n, unit, base, bias, start, end, zero, nice);
  }
};

;// CONCATENATED MODULE: ./src/primitives/types/helpers.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */






/*

This is the general dumping ground for trait behavior.

Helpers are auto-attached to primitives that have the matching trait

*/

const helpers = {
  bind: {
    make(slots) {
      if (this.bind == null) {
        this.bind = {};
      }
      if (this.bound == null) {
        this.bound = [];
      }

      // Fetch attached objects and bind to them
      // Attach rebuild watcher for DOM changes to bound nodes
      for (const slot of Array.from(slots)) {
        let { callback } = slot;
        const { to, trait, optional, unique, multiple } = slot;

        if (callback == null) {
          callback = this.rebuild;
        }
        const name = to.split(/\./g).pop();
        const selector = this._get(to);

        // Find by selector
        let source = null;
        if (selector != null) {
          let start = this;
          let done = false;
          while (!done) {
            // Keep scanning back until a new node is found
            start = source = this._attach(
              selector,
              trait,
              callback,
              this,
              start,
              optional,
              multiple
            );
            const isUnique =
              unique && (source == null || this.bound.indexOf(source) < 0);
            done = multiple || optional || !unique || isUnique;
          }
        }

        // Monitor source for reallocation / resize
        if (source != null) {
          if (this.resize != null) {
            this._listen(source, "source.resize", this.resize);
          }
          if (callback) {
            this._listen(source, "source.rebuild", callback);
          }

          if (multiple) {
            for (const s of Array.from(source)) {
              this.bound.push(s);
            }
          } else {
            this.bound.push(source);
          }
        }

        this.bind[name] = source;
      }

      return null;
    },

    unmake() {
      if (!this.bind) {
        return;
      }
      delete this.bind;
      return delete this.bound;
    },
  },

  span: {
    make() {
      // Look up nearest view to inherit from
      // Monitor size changes
      this.spanView = this._inherit("view");
      return this._listen("view", "view.range", () =>
        this.trigger({ type: "span.range" })
      );
    },

    unmake() {
      return delete this.spanView;
    },

    get: (function () {
      const def = new external_THREE_.Vector2(-1, 1);

      return function (prefix, dimension) {
        // Return literal range
        let left;
        const range = this._get(prefix + "span.range");
        if (range != null) {
          return range;
        }

        // Inherit from view
        return (left =
          this.spanView != null ? this.spanView.axis(dimension) : undefined) !=
          null
          ? left
          : def;
      };
    })(),
  },

  scale: {
    // Divisions to allocate on scale
    divide(prefix) {
      const divide = this._get(prefix + "scale.divide");
      const factor = this._get(prefix + "scale.factor");
      return Math.round((divide * 2.5) / factor);
    },

    // Generate ticks on scale
    generate(prefix, buffer, min, max) {
      const mode = this._get(prefix + "scale.mode");
      const divide = this._get(prefix + "scale.divide");
      const unit = this._get(prefix + "scale.unit");
      const base = this._get(prefix + "scale.base");
      const factor = this._get(prefix + "scale.factor");
      const start = this._get(prefix + "scale.start");
      const end = this._get(prefix + "scale.end");
      const zero = this._get(prefix + "scale.zero");
      const nice = this._get(prefix + "scale.nice");

      const ticks = make(
        mode,
        min,
        max,
        divide,
        unit,
        base,
        factor,
        start,
        end,
        zero,
        nice
      );
      buffer.copy(ticks);
      return ticks;
    },
  },

  style: {
    // Return bound style uniforms
    uniforms() {
      return {
        styleColor: this.node.attributes["style.color"],
        styleOpacity: this.node.attributes["style.opacity"],
        styleZBias: this.node.attributes["style.zBias"],
        styleZIndex: this.node.attributes["style.zIndex"],
      };
    },
  },

  arrow: {
    // Return bound arrow style uniforms
    uniforms() {
      const { start } = this.props;
      const { end } = this.props;

      const space = this._attributes.make(
        this._types.number(1.25 / (start + end))
      );
      const style = this._attributes.make(this._types.vec2(+start, +end));
      const size = this.node.attributes["arrow.size"];

      return {
        clipStyle: style,
        clipRange: size,
        clipSpace: space,

        arrowSpace: space,
        arrowSize: size,
      };
    },
  },

  point: {
    // Return bound point style uniforms
    uniforms() {
      return {
        pointSize: this.node.attributes["point.size"],
        pointDepth: this.node.attributes["point.depth"],
      };
    },
  },

  line: {
    // Return bound line style uniforms
    uniforms() {
      return {
        lineWidth: this.node.attributes["line.width"],
        lineDepth: this.node.attributes["line.depth"],
        lineProximity: this.node.attributes["line.proximity"],
      };
    },
  },

  surface: {
    // Return bound surface style uniforms
    uniforms() {
      return {};
    },
  },

  shade: {
    pipeline(shader) {
      if (!this._inherit("fragment")) {
        return shader;
      }
      if (shader == null) {
        shader = this._shaders.shader();
      }
      for (let pass = 0; pass <= 2; pass++) {
        shader = helpers_guard_(this._inherit("fragment"), (x) =>
          x.fragment(shader, pass)
        );
      }
      shader.pipe("fragment.map.rgba");
      return shader;
    },

    normal(shader) {
      shader.pipe(swizzleVec4("xyz"));
      return shader;
    },

    map(shader) {
      if (!shader) {
        return shader;
      }
      return (shader = this._shaders
        .shader()
        .pipe("mesh.map.uvwo")
        .pipe(shader));
    },
  },

  position: {
    pipeline(shader) {
      if (!this._inherit("vertex")) {
        return shader;
      }
      if (shader == null) {
        shader = this._shaders.shader();
      }
      for (let pass = 0; pass <= 3; pass++) {
        shader = helpers_guard_(this._inherit("vertex"), (x) =>
          x.vertex(shader, pass)
        );
      }
      return shader;
    },

    swizzle(shader, order) {
      if (shader) {
        return this._shaders
          .shader()
          .pipe(swizzleVec4(order))
          .pipe(shader);
      }
    },

    swizzle2(shader, order1, order2) {
      if (shader) {
        return this._shaders
          .shader()
          .split()
          .pipe(swizzleVec4(order1))
          .next()
          .pipe(swizzleVec4(order2))
          .join()
          .pipe(shader);
      }
    },
  },

  visible: {
    make() {
      const e = { type: "visible.change" };

      let visible = null;
      this.setVisible = function (vis) {
        if (vis != null) {
          visible = vis;
        }
        return onVisible();
      };

      const onVisible = () => {
        let left;
        const last = this.isVisible;
        let self =
          (left = visible != null ? visible : this._get("object.visible")) !=
          null
            ? left
            : true;
        if (visibleParent != null) {
          if (self) {
            self = visibleParent.isVisible;
          }
        }
        this.isVisible = self;
        if (last !== this.isVisible) {
          return this.trigger(e);
        }
      };

      const visibleParent = this._inherit("visible");
      if (visibleParent) {
        this._listen(visibleParent, "visible.change", onVisible);
      }
      if (this.is("object")) {
        this._listen(this.node, "change:object", onVisible);
      }

      return onVisible();
    },

    unmake() {
      return delete this.isVisible;
    },
  },

  active: {
    make() {
      const e = { type: "active.change" };

      let active = null;
      this.setActive = function (act) {
        if (act != null) {
          active = act;
        }
        return onActive();
      };

      const onActive = () => {
        let left;
        const last = this.isActive;
        let self =
          (left = active != null ? active : this._get("entity.active")) != null
            ? left
            : true;
        if (activeParent != null) {
          if (self) {
            self = activeParent.isActive;
          }
        }
        this.isActive = self;
        if (last !== this.isActive) {
          return this.trigger(e);
        }
      };

      const activeParent = this._inherit("active");
      if (activeParent) {
        this._listen(activeParent, "active.change", onActive);
      }
      if (this.is("entity")) {
        this._listen(this.node, "change:entity", onActive);
      }

      return onActive();
    },

    unmake() {
      return delete this.isActive;
    },
  },

  object: {
    // Generic 3D renderable wrapper, handles the fiddly Three.js bits that require a 'style recalculation'.
    //
    // Pass renderables to nearest root for rendering
    // Track visibility from parent and notify children
    // Track blends / transparency for three.js materials
    make(objects) {
      // Aggregate rendered three objects for reference
      let blending, zOrder;
      if (objects == null) {
        objects = [];
      }
      this.objects = objects;
      this.renders = this.objects.reduce((a, b) => a.concat(b.renders), []);

      const objectScene = this._inherit("scene");

      let opacity = (blending = zOrder = null);

      const hasStyle = Array.from(this.traits).includes("style");
      opacity = 1;
      blending = external_THREE_.NormalBlending;
      let zWrite = true;
      let zTest = true;

      if (hasStyle) {
        ({ opacity } = this.props);
        ({ blending } = this.props);
        ({ zOrder } = this.props);
        ({ zWrite } = this.props);
        ({ zTest } = this.props);
      }

      const onChange = (event) => {
        const { changed } = event;
        let refresh = null;
        if (changed["style.opacity"]) {
          refresh = opacity = this.props.opacity;
        }
        if (changed["style.blending"]) {
          refresh = blending = this.props.blending;
        }
        if (changed["style.zOrder"]) {
          refresh = zOrder = this.props.zOrder;
        }
        if (changed["style.zWrite"]) {
          refresh = zWrite = this.props.zWrite;
        }
        if (changed["style.zTest"]) {
          refresh = zTest = this.props.zTest;
        }
        if (refresh != null) {
          return onVisible();
        }
      };

      const onVisible = () => {
        const order = zOrder != null ? -zOrder : this.node.order;

        const visible =
          (this.isVisible != null ? this.isVisible : true) && opacity > 0;

        if (visible) {
          if (hasStyle) {
            return (() => {
              const result = [];
              for (const o of Array.from(this.objects)) {
                o.show(opacity < 1, blending, order);
                result.push(o.depth(zWrite, zTest));
              }
              return result;
            })();
          } else {
            return (() => {
              const result1 = [];
              for (const o of Array.from(this.objects)) {
                result1.push(o.show(true, blending, order));
              }
              return result1;
            })();
          }
        } else {
          return (() => {
            const result2 = [];
            for (const o of Array.from(this.objects)) {
              result2.push(o.hide());
            }
            return result2;
          })();
        }
      };

      this._listen(this.node, "change:style", onChange);
      this._listen(this.node, "reindex", onVisible);
      this._listen(this, "visible.change", onVisible);

      for (const object of Array.from(this.objects)) {
        objectScene.adopt(object);
      }
      return onVisible();
    },

    unmake(dispose) {
      let object;
      if (dispose == null) {
        dispose = true;
      }
      if (!this.objects) {
        return;
      }

      const objectScene = this._inherit("scene");
      for (object of Array.from(this.objects)) {
        objectScene.unadopt(object);
      }
      if (dispose) {
        return (() => {
          const result = [];
          for (object of Array.from(this.objects)) {
            result.push(object.dispose());
          }
          return result;
        })();
      }
    },

    mask() {
      let mask, shader;
      if (!(mask = this._inherit("mask"))) {
        return;
      }
      return (shader = mask.mask(shader));
    },
  },

  unit: {
    make() {
      let focusDepth,
        pixelRatio,
        pixelUnit,
        renderAspect,
        renderHeight,
        renderOdd,
        renderScale,
        renderScaleInv,
        renderWidth,
        viewHeight,
        viewWidth,
        worldUnit;
      let π = Math.PI;

      this.unitUniforms = {
        renderScaleInv: (renderScaleInv = this._attributes.make(
          this._types.number(1)
        )),
        renderScale: (renderScale = this._attributes.make(
          this._types.number(1)
        )),
        renderAspect: (renderAspect = this._attributes.make(
          this._types.number(1)
        )),
        renderWidth: (renderWidth = this._attributes.make(
          this._types.number(0)
        )),
        renderHeight: (renderHeight = this._attributes.make(
          this._types.number(0)
        )),
        viewWidth: (viewWidth = this._attributes.make(this._types.number(0))),
        viewHeight: (viewHeight = this._attributes.make(this._types.number(0))),
        pixelRatio: (pixelRatio = this._attributes.make(this._types.number(1))),
        pixelUnit: (pixelUnit = this._attributes.make(this._types.number(1))),
        worldUnit: (worldUnit = this._attributes.make(this._types.number(1))),
        focusDepth: (focusDepth = this._attributes.make(this._types.number(1))),
        renderOdd: (renderOdd = this._attributes.make(this._types.vec2())),
      };

      const top = new external_THREE_.Vector3();
      const bottom = new external_THREE_.Vector3();

      const handler = () => {
        let camera, size;
        if ((size = root != null ? root.getSize() : undefined) == null) {
          return;
        }

        π = Math.PI;

        const { scale } = this.props;
        const { fov } = this.props;
        const focus =
          this.props.focus != null
            ? this.props.focus
            : this.inherit("unit").props.focus;

        const isAbsolute = scale === null;

        // Measure live FOV to be able to accurately predict anti-aliasing in
        // perspective
        let measure = 1;
        if ((camera = root != null ? root.getCamera() : undefined)) {
          const m = camera.projectionMatrix;

          // Measure top to bottom
          top.set(0, -0.5, 1).applyMatrix4(m);
          bottom.set(0, 0.5, 1).applyMatrix4(m);
          top.sub(bottom);
          measure = top.y;
        }

        // Calculate device pixel ratio
        const dpr = size.renderHeight / size.viewHeight;

        // Calculate correction for fixed on-screen size regardless of FOV
        const fovtan = fov != null ? measure * Math.tan((fov * π) / 360) : 1;

        // Calculate device pixels per virtual pixel
        const pixel = isAbsolute ? dpr : (size.renderHeight / scale) * fovtan;

        // Calculate device pixels per world unit
        const rscale = (size.renderHeight * measure) / 2;

        // Calculate world units per virtual pixel
        const world = pixel / rscale;

        viewWidth.value = size.viewWidth;
        viewHeight.value = size.viewHeight;
        renderWidth.value = size.renderWidth;
        renderHeight.value = size.renderHeight;
        renderAspect.value = size.aspect;
        renderScale.value = rscale;
        renderScaleInv.value = 1 / rscale;
        pixelRatio.value = dpr;
        pixelUnit.value = pixel;
        worldUnit.value = world;
        focusDepth.value = focus;

        return renderOdd.value
          .set(size.renderWidth % 2, size.renderHeight % 2)
          .multiplyScalar(0.5);
      };

      //console.log 'worldUnit', world, pixel, rscale, isAbsolute

      const root = this.is("root") ? this : this._inherit("root");
      //@_listen root, 'root.resize', handler
      //@_listen root, 'root.camera', handler
      //@_listen @node, 'change:unit', handler
      this._listen(root, "root.update", handler);

      return handler();
    },

    unmake() {
      return delete this.unitUniforms;
    },

    get() {
      const u = {};
      for (const k in this.unitUniforms) {
        const v = this.unitUniforms[k];
        u[k] = v.value;
      }
      return u;
    },

    uniforms() {
      return this.unitUniforms;
    },
  },
};

const Helpers = function (object, traits) {
  const h = {};
  for (const trait of Array.from(traits)) {
    let methods;
    if (!(methods = helpers[trait])) {
      continue;
    }

    h[trait] = {};
    for (const key in methods) {
      const method = methods[key];
      h[trait][key] = method.bind(object);
    }
  }
  return h;
};

function helpers_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/primitives/types/index.js





;// CONCATENATED MODULE: ./src/primitives/factory.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */

class PrimitiveFactory {
  constructor(definitions, context) {
    this.context = context;
    this.classes = definitions.Classes;
    this.helpers = definitions.Helpers;
  }

  getTypes() {
    return Object.keys(this.classes);
  }

  make(type, options, binds = null) {
    if (options == null) {
      options = {};
    }

    const klass = this.classes[type];

    if (klass == null) {
      throw new Error(`Unknown primitive class \`${type}\``);
    }

    const node = new klass.model(
      type,
      klass.defaults,
      options,
      binds,
      klass,
      this.context.attributes
    );

    // NOTE: keep for side effects.
    new klass(node, this.context, this.helpers);
    return node;
  }
}

;// CONCATENATED MODULE: ./src/primitives/index.js




const primitives_Types = primitives_types_namespaceObject;

;// CONCATENATED MODULE: ./src/render/renderable.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */

class Renderable {
  constructor(renderer, shaders) {
    this.renderer = renderer;
    this.shaders = shaders;
    this.gl = this.renderer.getContext();
    if (this.uniforms == null) {
      this.uniforms = {};
    }
  }

  dispose() {
    this.uniforms = null;
  }

  _adopt(uniforms) {
    for (const key in uniforms) {
      const value = uniforms[key];
      this.uniforms[key] = value;
    }
  }

  _set(uniforms) {
    for (const key in uniforms) {
      const value = uniforms[key];
      if (this.uniforms[key] != null) {
        this.uniforms[key].value = value;
      }
    }
  }
}

;// CONCATENATED MODULE: ./src/render/scene.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
 All MathBox renderables sit inside this root, to keep things tidy.
*/
class MathBox extends external_THREE_.Object3D {
  constructor() {
    super();
    this.rotationAutoUpdate = false;
    this.frustumCulled = false;
    this.matrixAutoUpdate = false;
  }
}

/*
 Holds the root and binds to a THREE.Scene

 Will hold objects and inject them a few at a time
 to avoid long UI blocks.

 Will render injected objects to a 1x1 scratch buffer to ensure availability
*/
class Scene extends Renderable {
  constructor(renderer, shaders, options) {
    super(renderer, shaders, options);
    this.root = new MathBox();

    if ((options != null ? options.scene : undefined) != null) {
      this.scene = options.scene;
    }
    if (this.scene == null) {
      this.scene = new external_THREE_.Scene();
    }

    this.pending = [];
    this.async = 0;

    this.scratch = new external_THREE_.WebGLRenderTarget(1, 1);
    this.camera = new external_THREE_.PerspectiveCamera();
  }

  inject(scene) {
    if (scene != null) {
      this.scene = scene;
    }
    return this.scene.add(this.root);
  }

  unject() {
    return this.scene != null ? this.scene.remove(this.root) : undefined;
  }

  add(object) {
    if (this.async) {
      return this.pending.push(object);
    } else {
      return this._add(object);
    }
  }

  remove(object) {
    this.pending = this.pending.filter((o) => o !== object);
    if (object.parent != null) {
      return this._remove(object);
    }
  }

  _add(object) {
    return this.root.add(object);
  }

  _remove(object) {
    return this.root.remove(object);
  }

  dispose() {
    if (this.root.parent != null) {
      return this.unject();
    }
  }

  warmup(n) {
    return (this.async = +n || 0);
  }

  render() {
    if (!this.pending.length) {
      return;
    }
    const { children } = this.root;

    // Insert up to @async children
    const added = [];
    for (
      let i = 0, end = this.async, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      const pending = this.pending.shift();
      if (!pending) {
        break;
      }

      // Insert new child
      this._add(pending);
      added.push(added);
    }

    // Remember current visibility
    const visible = children.map(function (o) {
      return o.visible;
    });

    // Force only this child visible
    children.map((o) => (o.visible = !Array.from(added).includes(o)));

    // Render and throw away
    const currentTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(this.scratch);
    this.renderer.render(this.scene, this.camera);
    this.renderer.setRenderTarget(currentTarget);

    // Restore visibility
    return children.map((o, i) => (o.visible = visible[i]));
  }

  toJSON() {
    return this.root.toJSON();
  }
}

;// CONCATENATED MODULE: ./src/render/factory.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
class RenderFactory {
  constructor(classes, renderer, shaders) {
    this.classes = classes;
    this.renderer = renderer;
    this.shaders = shaders;
  }

  getTypes() {
    return Object.keys(this.classes);
  }

  make(type, options) {
    return new this.classes[type](this.renderer, this.shaders, options);
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/buffer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
 * Base class for sample buffers
 */
class buffer_Buffer extends Renderable {
  constructor(renderer, shaders, options) {
    super(renderer, shaders);

    if (this.items == null) {
      this.items = options.items || 1;
    }
    if (this.samples == null) {
      this.samples = options.samples || 1;
    }
    if (this.channels == null) {
      this.channels = options.channels || 4;
    }
    if (this.callback == null) {
      this.callback = options.callback || function () {};
    }
  }

  dispose() {
    return super.dispose();
  }

  update() {
    const n = this.fill();
    this.write(n);
    return n;
  }

  setActive(_i, _j, _k, _l) {}

  setCallback(callback) {
    this.callback = callback;
  }

  write() {}
  fill() {}
  generate(data) {
    return getStreamer(data, this.samples, this.channels, this.items);
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/texture/datatexture.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */






/*
Manually allocated GL texture for data streaming.

Allows partial updates via subImage.
*/
class DataTexture {
  constructor(renderer, width, height, channels, options) {
    this.renderer = renderer;
    this.width = width;
    this.height = height;
    this.channels = channels;
    this.n = this.width * this.height * this.channels;

    const gl = this.renderer.getContext();
    this.gl = gl;
    const minFilter =
      (options != null ? options.minFilter : undefined) != null
        ? options != null
          ? options.minFilter
          : undefined
        : external_THREE_.NearestFilter;
    const magFilter =
      (options != null ? options.magFilter : undefined) != null
        ? options != null
          ? options.magFilter
          : undefined
        : external_THREE_.NearestFilter;
    const type =
      (options != null ? options.type : undefined) != null
        ? options != null
          ? options.type
          : undefined
        : external_THREE_.FloatType;

    this.minFilter = paramToGL(gl, minFilter);
    this.magFilter = paramToGL(gl, magFilter);
    this.type = paramToGL(gl, type);
    this.ctor = paramToArrayStorage(type);

    this.build(options);
  }

  build(options) {
    const { gl } = this;
    const state = this.renderer.state;

    // Make GL texture
    this.texture = gl.createTexture();
    this.format = [null, gl.LUMINANCE, gl.LUMINANCE_ALPHA, gl.RGB, gl.RGBA][
      this.channels
    ];
    this.format3 = [
      null,
      external_THREE_.LuminanceFormat,
      external_THREE_.LuminanceAlphaFormat,
      undefined, // CONST.RGBFormat was removed in r137 of ThreeJS
      external_THREE_.RGBAFormat,
    ][this.channels];

    state.bindTexture(gl.TEXTURE_2D, this.texture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.minFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.magFilter);

    // Attach empty data
    this.data = new this.ctor(this.n);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      this.format,
      this.width,
      this.height,
      0,
      this.format,
      this.type,
      this.data
    );

    // Make wrapper texture object.
    this.textureObject = new external_THREE_.Texture(
      new Image(),
      external_THREE_.UVMapping,
      external_THREE_.ClampToEdgeWrapping,
      external_THREE_.ClampToEdgeWrapping,
      options != null ? options.minFilter : undefined,
      options != null ? options.magFilter : undefined
    );

    // Pre-init texture to trick WebGLRenderer
    this.textureProperties = this.renderer.properties.get(this.textureObject);
    this.textureProperties.__webglInit = true;
    this.textureProperties.__webglTexture = this.texture;

    this.textureObject.format = this.format3;
    this.textureObject.type = external_THREE_.FloatType;
    this.textureObject.unpackAlignment = 1;
    this.textureObject.flipY = false;
    this.textureObject.generateMipmaps = false;

    // Create uniforms
    this.uniforms = {
      dataResolution: {
        type: "v2",
        value: new external_THREE_.Vector2(1 / this.width, 1 / this.height),
      },
      dataTexture: {
        type: "t",
        value: this.textureObject,
      },
    };
  }

  write(data, x, y, w, h) {
    const { gl } = this;
    const state = this.renderer.state;

    // Write to rectangle
    state.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    return gl.texSubImage2D(
      gl.TEXTURE_2D,
      0,
      x,
      y,
      w,
      h,
      this.format,
      this.type,
      data
    );
  }

  dispose() {
    this.gl.deleteTexture(this.texture);

    this.textureProperties.__webglInit = false;
    this.textureProperties.__webglTexture = null;
    this.textureProperties = null;
    return (this.textureObject = this.texture = null);
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/databuffer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */








/*
 * Data buffer on the GPU
 * - Stores samples (1-n) x items (1-n) x channels (1-4)
 * - Provides generic sampler shader
 * - Provides generic copy/write handler
 * => specialized into Array/Matrix/VoxelBuffer
 */
class DataBuffer extends buffer_Buffer {
  constructor(renderer, shaders, options, build) {
    if (build == null) {
      build = true;
    }
    const width = options.width || 1;
    const height = options.height || 1;
    const depth = options.depth || 1;
    const samples = width * height * depth;

    if (!options.samples) {
      options.samples = samples;
    }

    super(renderer, shaders, options);

    this.width = width;
    this.height = height;
    this.depth = depth;
    if (this.samples == null) {
      this.samples = samples;
    }

    if (build) {
      this.build(options);
    }
  }

  shader(shader, indices) {
    if (indices == null) {
      indices = 4;
    }
    if (this.items > 1 || this.depth > 1) {
      if (indices !== 4) {
        shader.pipe(extendVec(indices, 4));
      }
      shader.pipe("map.xyzw.texture", this.uniforms);
    } else {
      if (indices !== 2) {
        shader.pipe(truncateVec(indices, 2));
      }
    }

    const wrap = this.wrap ? ".wrap" : "";
    shader.pipe(`map.2d.data${wrap}`, this.uniforms);
    shader.pipe("sample.2d", this.uniforms);
    if (this.channels < 4) {
      shader.pipe(
        swizzleVec4(["0000", "x000", "xw00", "xyz0"][this.channels])
      );
    }
    return shader;
  }

  build(options) {
    this.data = new Float32Array(this.samples * this.channels * this.items);
    this.texture = new DataTexture(
      this.renderer,
      this.items * this.width,
      this.height * this.depth,
      this.channels,
      options
    );
    this.filled = 0;
    this.used = 0;

    this._adopt(this.texture.uniforms);
    this._adopt({
      dataPointer: { type: "v2", value: new external_THREE_.Vector2() },
      textureItems: { type: "f", value: this.items },
      textureHeight: { type: "f", value: this.height },
    });

    this.dataPointer = this.uniforms.dataPointer.value;
    this.streamer = this.generate(this.data);
  }

  dispose() {
    this.data = null;
    this.texture.dispose();
    return super.dispose();
  }

  getFilled() {
    return this.filled;
  }
  setCallback(callback) {
    this.callback = callback;
    return (this.filled = 0);
  }

  copy(data) {
    const n = Math.min(data.length, this.samples * this.channels * this.items);
    const d = this.data;
    for (
      let i = 0, end = n, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      d[i] = data[i];
    }
    this.write(Math.ceil(n / this.channels / this.items));
  }

  write(n) {
    if (n == null) {
      n = this.samples;
    }
    let height = n / this.width;
    n *= this.items;
    const width = height < 1 ? n : this.items * this.width;
    height = Math.ceil(height);

    this.texture.write(this.data, 0, 0, width, height);
    this.dataPointer.set(0.5, 0.5);

    this.filled = 1;
    this.used = n;
  }

  through(callback, target) {
    let dst, src;
    const { consume, done } = (src = this.streamer);
    const { emit } = (dst = target.streamer);

    let i = 0;

    let pipe = () => consume((x, y, z, w) => callback(emit, x, y, z, w, i));
    pipe = repeatCall(pipe, this.items);

    return () => {
      src.reset();
      dst.reset();
      const limit = this.used;
      i = 0;
      while (!done() && i < limit) {
        pipe();
        i++;
      }

      return src.count();
    };
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/arraybuffer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
 * 1D + history array
 */
class ArrayBuffer_ extends DataBuffer {
  constructor(renderer, shaders, options) {
    const width = options.width || 1;
    const history = options.history || 1;

    options.width = width;
    options.height = history;
    options.depth = 1;

    super(renderer, shaders, options, false);

    this.width = width;
    this.history = history;
    this.samples = width;
    this.wrap = history > 1;

    this.build(options);
  }

  build(_options) {
    super.build();

    this.index = 0;
    this.pad = 0;
    return (this.streamer = this.generate(this.data));
  }

  setActive(i) {
    return (this.pad = Math.max(0, this.width - i));
  }

  fill() {
    const { callback } = this;
    if (typeof callback.reset === "function") {
      callback.reset();
    }

    const { emit, count, done, reset } = this.streamer;
    reset();

    const limit = this.samples - this.pad;

    let i = 0;
    while (!done() && i < limit && callback(emit, i++) !== false) {
      true;
    }

    return Math.floor(count() / this.items);
  }

  write(n) {
    if (n == null) {
      n = this.samples;
    }
    n *= this.items;
    this.texture.write(this.data, 0, this.index, n, 1);
    this.dataPointer.set(0.5, this.index + 0.5);
    this.index = (this.index + this.history - 1) % this.history;
    return (this.filled = Math.min(this.history, this.filled + 1));
  }

  through(callback, target) {
    let dst, src;
    const { consume, done } = (src = this.streamer);
    const { emit } = (dst = target.streamer);

    let i = 0;

    let pipe = () => consume((x, y, z, w) => callback(emit, x, y, z, w, i));
    pipe = repeatCall(pipe, this.items);

    return () => {
      src.reset();
      dst.reset();
      const limit = this.samples - this.pad;
      i = 0;
      while (!done() && i < limit) {
        pipe();
        i++;
      }

      return src.count();
    };
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/geometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



class Geometry extends external_THREE_.BufferGeometry {
  constructor() {
    super();
    new external_THREE_.BufferGeometry(this);
    if (this.uniforms == null) {
      this.uniforms = {};
    }
    if (this.groups == null) {
      this.groups = [];
    }
  }

  _reduce(dims, maxs) {
    let multiple = false;
    for (let i = 0; i < dims.length; i++) {
      const dim = dims[i];
      const max = maxs[i];
      if (multiple) {
        dims[i] = max;
      }
      if (dim > 1) {
        multiple = true;
      }
    }

    return dims.reduce((a, b) => a * b);
  }

  _emitter(name) {
    const attribute =
      name == "index" ? this.getIndex() : this.getAttribute(name);
    const dimensions = attribute.itemSize;
    const { array } = attribute;

    let offset = 0;
    const one = function (a) {
      array[offset++] = a;
    };
    const two = function (a, b) {
      array[offset++] = a;
      array[offset++] = b;
    };
    const three = function (a, b, c) {
      array[offset++] = a;
      array[offset++] = b;
      array[offset++] = c;
    };
    const four = function (a, b, c, d) {
      array[offset++] = a;
      array[offset++] = b;
      array[offset++] = c;
      array[offset++] = d;
    };

    return [null, one, two, three, four][dimensions];
  }

  _finalize() {
    return;
  }

  _offsets(offsets) {
    this.groups = offsets;
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/clipgeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




// Instanced geometry that is clippable along 4 dimensions
class ClipGeometry extends Geometry {
  _clipUniforms() {
    this.geometryClip = new external_THREE_.Vector4(1e10, 1e10, 1e10, 1e10);
    this.geometryResolution = new external_THREE_.Vector4();
    this.mapSize = new external_THREE_.Vector4();

    if (this.uniforms == null) {
      this.uniforms = {};
    }
    this.uniforms.geometryClip = {
      type: "v4",
      value: this.geometryClip,
    };
    this.uniforms.geometryResolution = {
      type: "v4",
      value: this.geometryResolution,
    };
    return (this.uniforms.mapSize = {
      type: "v4",
      value: this.mapSize,
    });
  }

  _clipGeometry(width, height, depth, items) {
    const c = (x) => Math.max(0, x - 1);
    const r = (x) => 1 / Math.max(1, x - 1);

    this.geometryClip.set(c(width), c(height), c(depth), c(items));
    return this.geometryResolution.set(r(width), r(height), r(depth), r(items));
  }

  _clipMap(mapWidth, mapHeight, mapDepth, mapItems) {
    return this.mapSize.set(mapWidth, mapHeight, mapDepth, mapItems);
  }

  _clipOffsets(
    factor,
    width,
    height,
    depth,
    items,
    _width,
    _height,
    _depth,
    _items
  ) {
    const dims = [depth, height, width, items];
    const maxs = [_depth, _height, _width, _items];
    const elements = this._reduce(dims, maxs);

    return this._offsets([
      {
        start: 0,
        count: elements * factor,
        materialIndex: 0,
      },
    ]);
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/arrowgeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
Cones to attach as arrowheads on line strips

.....> .....> .....> .....>

.....> .....> .....> .....>

.....> .....> .....> .....>
*/

class ArrowGeometry extends ClipGeometry {
  constructor(options) {
    let anchor, flip, closed, k, layers, ribbons, samples, sides, strips;
    let asc, end;
    super(options);

    this._clipUniforms();

    this.sides = sides = +options.sides || 12;
    this.samples = samples = +options.samples || 2;
    this.strips = strips = +options.strips || 1;
    this.ribbons = ribbons = +options.ribbons || 1;
    this.layers = layers = +options.layers || 1;
    this.flip = flip = options.flip != null ? options.flip : false;
    this.closed = closed = options.closed != null ? options.closed : false;
    this.anchor = anchor =
      options.anchor != null
        ? options.anchor
        : flip || closed
        ? 0
        : samples - 1;

    const arrows = strips * ribbons * layers;
    const points = (sides + 2) * arrows;
    const triangles = sides * 2 * arrows;

    this.setIndex(new external_THREE_.BufferAttribute(new Uint32Array(triangles * 3), 1));

    this.setAttribute(
      "position4",
      new external_THREE_.BufferAttribute(new Float32Array(points * 4), 4)
    );
    this.setAttribute(
      "arrow",
      new external_THREE_.BufferAttribute(new Float32Array(points * 3), 3)
    );
    this.setAttribute(
      "attach",
      new external_THREE_.BufferAttribute(new Float32Array(points * 2), 2)
    );

    const index = this._emitter("index");
    const position = this._emitter("position4");
    const arrow = this._emitter("arrow");
    const attach = this._emitter("attach");

    const circle = [];
    for (
      k = 0, end = sides, asc = 0 <= end;
      asc ? k < end : k > end;
      asc ? k++ : k--
    ) {
      const angle = (k / sides) * 2 * Math.PI;
      circle.push([Math.cos(angle), Math.sin(angle), 1]);
    }

    let base = 0;
    for (
      let i = 0, end1 = arrows, asc1 = 0 <= end1;
      asc1 ? i < end1 : i > end1;
      asc1 ? i++ : i--
    ) {
      let asc2, end2;
      const tip = base++;
      const back = tip + sides + 1;

      for (
        k = 0, end2 = sides, asc2 = 0 <= end2;
        asc2 ? k < end2 : k > end2;
        asc2 ? k++ : k--
      ) {
        const a = base + (k % sides);
        const b = base + ((k + 1) % sides);

        index(tip);
        index(a);
        index(b);

        index(b);
        index(a);
        index(back);
      }

      base += sides + 1;
    }

    const near = flip ? 1 : closed ? samples - 1 : -1;
    const far = flip && !closed ? samples - 1 : 0;
    const x = anchor;

    for (
      let l = 0, end3 = layers, asc3 = 0 <= end3;
      asc3 ? l < end3 : l > end3;
      asc3 ? l++ : l--
    ) {
      for (
        let z = 0, end4 = ribbons, asc4 = 0 <= end4;
        asc4 ? z < end4 : z > end4;
        asc4 ? z++ : z--
      ) {
        for (
          let y = 0, end5 = strips, asc5 = 0 <= end5;
          asc5 ? y < end5 : y > end5;
          asc5 ? y++ : y--
        ) {
          let asc6, end6;
          position(x, y, z, l);
          arrow(0, 0, 0);
          attach(near, far);

          for (
            k = 0, end6 = sides, asc6 = 0 <= end6;
            asc6 ? k < end6 : k > end6;
            asc6 ? k++ : k--
          ) {
            position(x, y, z, l);

            const c = circle[k];
            arrow(c[0], c[1], c[2]);
            attach(near, far);
          }

          position(x, y, z, l);
          arrow(0, 0, 1);
          attach(near, far);
        }
      }
    }

    this._finalize();
    this.clip();
  }

  clip(samples, strips, ribbons, layers) {
    let quads;
    if (samples == null) {
      ({ samples } = this);
    }
    if (strips == null) {
      ({ strips } = this);
    }
    if (ribbons == null) {
      ({ ribbons } = this);
    }
    if (layers == null) {
      ({ layers } = this);
    }

    this._clipGeometry(samples, strips, ribbons, layers);

    if (samples > 0) {
      const dims = [layers, ribbons, strips];
      const maxs = [this.layers, this.ribbons, this.strips];
      quads = this.sides * this._reduce(dims, maxs);
    } else {
      quads = 0;
    }

    return this._offsets([
      {
        start: 0,
        count: quads * 6,
        materialIndex: 0,
      },
    ]);
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/base.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */






class Base extends Renderable {
  constructor(renderer, shaders, options) {
    super(renderer, shaders, options);
    this.zUnits = options.zUnits != null ? options.zUnits : 0;
  }

  raw() {
    for (const object of Array.from(this.renders)) {
      this._raw(object);
    }
    return null;
  }

  depth(write, test) {
    for (const object of Array.from(this.renders)) {
      this._depth(object, write, test);
    }
    return null;
  }

  polygonOffset(factor, units) {
    for (const object of Array.from(this.renders)) {
      this._polygonOffset(object, factor, units);
    }
    return null;
  }

  show(transparent, blending, order) {
    return Array.from(this.renders).map((object) =>
      this._show(object, transparent, blending, order)
    );
  }

  hide() {
    for (const object of Array.from(this.renders)) {
      this._hide(object);
    }
    return null;
  }

  _injectPreamble(preamble, code) {
    const program = preamble + "\n" + code;
    if (code.match(/#extension/)) {
      return this._hoist(program);
    } else {
      return program;
    }
  }

  _hoist(code) {
    const lines = code.split("\n");
    const out = [];
    for (const line of Array.from(lines)) {
      if (line.match(/^\s*#extension/)) {
        out.unshift(line);
      } else {
        out.push(line);
      }
    }
    return out.join("\n");
  }

  _material(options) {
    const precision = this.renderer.capabilities.precision;

    const vertexPrefix = `\
    precision ${precision} float;
    precision ${precision} int;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;\
`;

    const fragmentPrefix = `\
    precision ${precision} float;
    precision ${precision} int;
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;\
`;

    const shaderOptions = {};
    Object.assign(shaderOptions, options);
    delete shaderOptions.attributes;
    delete shaderOptions.varyings;
    delete shaderOptions.inspect;
    delete shaderOptions.vertexGraph;
    delete shaderOptions.fragmentGraph;

    const material = new external_THREE_.RawShaderMaterial(shaderOptions);

    ["vertexGraph", "fragmentGraph", "inspect"].forEach(
      (key) => (material[key] = options[key])
    );

    material.vertexShader = this._injectPreamble(
      vertexPrefix,
      material.vertexShader
    );
    material.fragmentShader = this._injectPreamble(
      fragmentPrefix,
      material.fragmentShader
    );
    return material;
  }

  _raw(object) {
    object.rotationAutoUpdate = false;
    object.frustumCulled = false;
    object.matrixAutoUpdate = false;
    object.material.defaultAttributeValues = undefined;
  }

  _depth(object, write, test) {
    const m = object.material;
    m.depthWrite = write;
    return (m.depthTest = test);
  }

  _polygonOffset(object, factor, units) {
    units -= this.zUnits;
    const enabled = units !== 0;

    const m = object.material;

    m.polygonOffset = enabled;
    if (enabled) {
      m.polygonOffsetFactor = factor;
      return (m.polygonOffsetUnits = units);
    }
  }

  _show(object, transparent, blending, order) {
    // Force transparent to true to ensure all renderables drawn in order
    transparent = true;

    const m = object.material;

    object.renderOrder = -order;
    object.visible = true;
    m.transparent = transparent;
    m.blending = blending;

    return null;
  }

  _hide(object) {
    return (object.visible = false);
  }

  _vertexColor(color, mask) {
    if (!color && !mask) {
      return;
    }

    const v = this.shaders.shader();

    if (color) {
      v.require(color);
      v.pipe("mesh.vertex.color", this.uniforms);
    }

    if (mask) {
      v.require(mask);
      v.pipe("mesh.vertex.mask", this.uniforms);
    }

    return v;
  }

  _vertexPosition(position, material, map, channels, stpq) {
    let defs;
    const v = this.shaders.shader();

    if (map || (material && material !== true)) {
      defs = {};
      if (channels > 0 || stpq) {
        defs.POSITION_MAP = "";
      }
      if (channels > 0) {
        defs[
          ["POSITION_U", "POSITION_UV", "POSITION_UVW", "POSITION_UVWO"][
            channels - 1
          ]
        ] = "";
      }
      if (stpq) {
        defs.POSITION_STPQ = "";
      }
    }

    v.require(position);
    return v.pipe("mesh.vertex.position", this.uniforms, defs);
  }

  _fragmentColor(
    hasStyle,
    material,
    color,
    mask,
    map,
    channels,
    stpq,
    combine,
    linear
  ) {
    const f = this.shaders.shader();

    // metacode is terrible
    let join = false;
    let gamma = false;

    const defs = {};
    if (channels > 0) {
      defs[
        ["POSITION_U", "POSITION_UV", "POSITION_UVW", "POSITION_UVWO"][
          channels - 1
        ]
      ] = "";
    }
    if (stpq) {
      defs.POSITION_STPQ = "";
    }

    if (hasStyle) {
      f.pipe("style.color", this.uniforms);
      join = true;

      if (color || map || material) {
        if (!linear || color) {
          f.pipe("mesh.gamma.in");
        }
        gamma = true;
      }
    }

    if (color) {
      f.isolate();
      f.pipe("mesh.fragment.color", this.uniforms);
      if (!linear || join) {
        f.pipe("mesh.gamma.in");
      }
      f.end();
      if (join) {
        f.pipe(binaryOperator("vec4", "*"));
      }

      if (linear && join) {
        f.pipe("mesh.gamma.out");
      }

      join = true;
      gamma = true;
    }

    if (map) {
      if (!join && combine) {
        f.pipe(constant("vec4", "vec4(1.0)"));
      }

      f.isolate();
      f.require(map);
      f.pipe("mesh.fragment.map", this.uniforms, defs);
      if (!linear) {
        f.pipe("mesh.gamma.in");
      }
      f.end();

      if (combine) {
        f.pipe(combine);
      } else {
        if (join) {
          f.pipe(binaryOperator("vec4", "*"));
        }
      }

      join = true;
      gamma = true;
    }

    if (material) {
      if (!join) {
        f.pipe(constant("vec4", "vec4(1.0)"));
      }
      if (material === true) {
        f.pipe("mesh.fragment.shaded", this.uniforms);
      } else {
        f.require(material);
        f.pipe("mesh.fragment.material", this.uniforms, defs);
      }

      gamma = true;
    }

    if (gamma && !linear) {
      f.pipe("mesh.gamma.out");
    }

    if (mask) {
      f.pipe("mesh.fragment.mask", this.uniforms);
      if (join) {
        f.pipe(binaryOperator("vec4", "*"));
      }
    }

    return f;
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/arrow.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Arrow extends Base {
  constructor(renderer, shaders, options) {
    let f;
    super(renderer, shaders, options);

    let { uniforms } = options;

    const { material, position, color, mask, map, combine, stpq, linear } =
      options;
    if (uniforms == null) {
      uniforms = {};
    }

    const hasStyle = uniforms.styleColor != null;

    this.geometry = new ArrowGeometry({
      sides: options.sides,
      samples: options.samples,
      strips: options.strips,
      ribbons: options.ribbons,
      layers: options.layers,
      anchor: options.anchor,
      flip: options.flip,
      closed: options.closed,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    const defs = {};
    if (closed) {
      defs["ARROW_CLOSED"] = "";
    }

    const factory = shaders.material();

    const v = factory.vertex;

    v.pipe(this._vertexColor(color, mask));

    v.require(this._vertexPosition(position, material, map, 1, stpq));
    v.pipe("arrow.position", this.uniforms, defs);
    v.pipe("project.position", this.uniforms);

    factory.fragment = f = this._fragmentColor(
      hasStyle,
      material,
      color,
      mask,
      map,
      1,
      stpq,
      combine,
      linear
    );

    f.pipe("fragment.color", this.uniforms);

    const opts = factory.link({
      side: external_THREE_.DoubleSide,
    });
    this.material = this._material(opts);

    const object = new external_THREE_.Mesh(this.geometry, this.material);
    object.frustumCulled = false;
    object.matrixAutoUpdate = false;
    object.userData = opts;

    this._raw(object);
    this.renders = [object];
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.renders = this.geometry = this.material = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/texture/backedtexture.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


/*
Manually allocated GL texture for data streaming, locally backed.

Allows partial updates via subImage.
Contains local copy of its data to allow quick resizing without gl.copyTexImage2d
(which requires render-to-framebuffer)
*/
class BackedTexture extends DataTexture {
  constructor(renderer, width, height, channels, options) {
    super(renderer, width, height, channels, options);
    this.data = new this.ctor(this.n);
  }

  resize(width, height) {
    const old = this.data;
    const oldWidth = this.width;
    const oldHeight = this.height;

    this.width = width;
    this.height = height;
    this.n = width * height * this.channels;
    this.data = new this.ctor(this.n);

    const { gl } = this;
    const state = this.renderer.state;
    state.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      this.format,
      width,
      height,
      0,
      this.format,
      this.type,
      this.data
    );

    this.uniforms.dataResolution.value.set(1 / width, 1 / height);

    return this.write(old, 0, 0, oldWidth, oldHeight);
  }

  write(src, x, y, w, h) {
    let j;
    const { width } = this;
    const dst = this.data;
    const { channels } = this;

    let i = 0;
    if (width === w && x === 0) {
      j = y * w * channels;
      const n = w * h * channels;
      while (i < n) {
        dst[j++] = src[i++];
      }
    } else {
      const stride = width * channels;
      const ww = w * channels;
      const xx = x * channels;
      let yy = y;
      const yh = y + h;
      while (yy < yh) {
        let k = 0;
        j = xx + yy * stride;
        while (k++ < ww) {
          dst[j++] = src[i++];
        }
        yy++;
      }
    }

    return super.write(src, x, y, w, h);
  }

  dispose() {
    this.data = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/atlas.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */








/*
 * Dynamic sprite atlas
 *
 * - Allocates variable-sized sprites in rows
 * - Will grow itself when full
 */
class Atlas extends Renderable {
  constructor(renderer, shaders, options, build) {
    if (build == null) {
      build = true;
    }
    super(renderer, shaders);

    if (this.width == null) {
      this.width = options.width || 512;
    }
    if (this.height == null) {
      this.height = options.height || 512;
    }
    if (this.channels == null) {
      this.channels = options.channels || 4;
    }
    if (this.backed == null) {
      this.backed = options.backed || false;
    }
    this.samples = this.width * this.height;

    if (build) {
      this.build(options);
    }
  }

  shader(shader) {
    shader.pipe("map.2d.data", this.uniforms);
    shader.pipe("sample.2d", this.uniforms);
    if (this.channels < 4) {
      shader.pipe(
        swizzleVec4(["0000", "x000", "xw00", "xyz0"][this.channels])
      );
    }
    return shader;
  }

  build(options) {
    let klass;
    this.klass = klass = this.backed ? BackedTexture : DataTexture;
    this.texture = new klass(
      this.renderer,
      this.width,
      this.height,
      this.channels,
      options
    );

    this.uniforms = {
      dataPointer: {
        type: "v2",
        value: new external_THREE_.Vector2(0, 0),
      },
    };
    this._adopt(this.texture.uniforms);

    return this.reset();
  }

  reset() {
    this.rows = [];
    return (this.bottom = 0);
  }

  resize(width, height) {
    if (!this.backed) {
      throw new Error("Cannot resize unbacked texture atlas");
    }
    if (width > 2048 && height > 2048) {
      console.warn(`Giant text atlas ${width}x${height}.`);
    } else {
      console.info(`Resizing text atlas ${width}x${height}.`);
    }

    this.texture.resize(width, height);

    this.width = width;
    this.height = height;
    return (this.samples = width * height);
  }

  collapse(row) {
    let left;
    const { rows } = this;
    rows.splice(rows.indexOf(row), 1);
    this.bottom =
      (left = atlas_guard_(rows[rows.length - 1], (x) => x.bottom)) != null
        ? left
        : 0;
    if (this.last === row) {
      return (this.last = null);
    }
  }

  allocate(key, width, height, emit) {
    const w = this.width;
    const h = this.height;

    const max = height * 2;

    if (width > w) {
      this.resize(w * 2, h * 2);
      this.last = null;
      // Try again
      return this.allocate(key, width, height, emit);
    }

    // See if we can append to the last used row (fast code path)
    let row = this.last;
    if (row != null) {
      if (row.height >= height && row.height < max && row.width + width <= w) {
        row.append(key, width, height, emit);
        return;
      }
    }

    // Scan all rows and append to the first suitable one (slower code path)
    let bottom = 0;
    let index = -1;
    let top = 0;
    for (let i = 0; i < this.rows.length; i++) {
      // Measure gap between rows
      // Note suitable holes for later
      row = this.rows[i];
      const gap = row.top - bottom;
      if (gap >= height && index < 0) {
        index = i;
        top = bottom;
      }
      ({ bottom } = row);

      if (row.height >= height && row.height < max && row.width + width <= w) {
        row.append(key, width, height, emit);
        this.last = row;
        return;
      }
    }

    // New row (slowest path)
    if (index >= 0) {
      // Fill a gap
      row = new Row(top, height);
      this.rows.splice(index, 0, row);
      //console.log 'fill gap', row
    } else {
      // Append to bottom
      top = bottom;
      bottom += height;

      // Resize if atlas is full
      if (bottom >= h) {
        this.resize(w * 2, h * 2);
        this.last = null;
        // Try again
        return this.allocate(key, width, height, emit);
      }

      // Add new row to the end
      row = new Row(top, height);
      this.rows.push(row);
      this.bottom = bottom;
    }

    row.append(key, width, height, emit);
    this.last = row;
  }

  read() {
    return this.texture.textureObject;
  }

  write(data, x, y, w, h) {
    return this.texture.write(data, x, y, w, h);
  }

  dispose() {
    this.texture.dispose();
    this.data = null;
    return super.dispose();
  }
}

class Row {
  constructor(top, height) {
    this.top = top;
    this.bottom = top + height;
    this.width = 0;
    this.height = height;
    this.alive = 0;
    this.keys = [];
  }

  append(key, width, height, emit) {
    const x = this.width;
    const y = this.top;
    this.alive++;
    this.width += width;
    this.keys.push(key);
    return emit(this, x, y);
  }
}

function atlas_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./src/render/meshes/debug.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class Debug extends Base {
  constructor(renderer, shaders, options) {
    super(renderer, shaders, options);

    this.geometry = new external_THREE_.PlaneGeometry(1, 1);
    this.material = new external_THREE_.MeshBasicMaterial({ map: options.map });
    this.material.side = external_THREE_.DoubleSide;

    const object = new external_THREE_.Mesh(this.geometry, this.material);
    object.position.x += options.x || 0;
    object.position.y += options.y || 0;
    object.frustumCulled = false;
    object.scale.set(2, 2, 2);
    object.__debug = true;

    this.objects = [object];
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.objects = this.geometry = this.material = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/facegeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
(flat) Triangle fans arranged in items, columns and rows

+-+     +-+     +-+     +-+
|\\\    |\\\    |\\\    |\\\
+-+-+   +-+-+   +-+-+   +-+-+

+-+     +-+     +-+     +-+
|\\\    |\\\    |\\\    |\\\
+-+-+   +-+-+   +-+-+   +-+-+

+-+     +-+     +-+     +-+
|\\\    |\\\    |\\\    |\\\
+-+-+   +-+-+   +-+-+   +-+-+
*/

class FaceGeometry extends ClipGeometry {
  constructor(options) {
    let depth, height, items, sides, width;
    super(options);

    this._clipUniforms();

    this.items = items = +options.items || 2;
    this.width = width = +options.width || 1;
    this.height = height = +options.height || 1;
    this.depth = depth = +options.depth || 1;
    this.sides = sides = Math.max(0, items - 2);

    const samples = width * height * depth;
    const points = items * samples;
    const triangles = sides * samples;

    this.setIndex(new external_THREE_.BufferAttribute(new Uint32Array(triangles * 3), 1));

    this.setAttribute(
      "position4",
      new external_THREE_.BufferAttribute(new Float32Array(points * 4), 4)
    );

    const index = this._emitter("index");
    const position = this._emitter("position4");

    let base = 0;
    for (
      let i = 0, end = samples, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      for (
        let j = 0, end1 = sides, asc1 = 0 <= end1;
        asc1 ? j < end1 : j > end1;
        asc1 ? j++ : j--
      ) {
        index(base);
        index(base + j + 1);
        index(base + j + 2);
      }

      base += items;
    }

    for (
      let z = 0, end2 = depth, asc2 = 0 <= end2;
      asc2 ? z < end2 : z > end2;
      asc2 ? z++ : z--
    ) {
      for (
        let y = 0, end3 = height, asc3 = 0 <= end3;
        asc3 ? y < end3 : y > end3;
        asc3 ? y++ : y--
      ) {
        for (
          let x = 0, end4 = width, asc4 = 0 <= end4;
          asc4 ? x < end4 : x > end4;
          asc4 ? x++ : x--
        ) {
          for (
            let l = 0, end5 = items, asc5 = 0 <= end5;
            asc5 ? l < end5 : l > end5;
            asc5 ? l++ : l--
          ) {
            position(x, y, z, l);
          }
        }
      }
    }

    this._finalize();
    this.clip();
  }

  clip(width, height, depth, items) {
    if (width == null) {
      ({ width } = this);
    }
    if (height == null) {
      ({ height } = this);
    }
    if (depth == null) {
      ({ depth } = this);
    }
    if (items == null) {
      ({ items } = this);
    }
    const sides = Math.max(0, items - 2);

    this._clipGeometry(width, height, depth, items);
    return this._clipOffsets(
      3,
      width,
      height,
      depth,
      sides,
      this.width,
      this.height,
      this.depth,
      this.sides
    );
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/face.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class face_Face extends Base {
  constructor(renderer, shaders, options) {
    let f;
    super(renderer, shaders, options);

    let { uniforms, material } = options;
    const { position, color, mask, map, combine, stpq, linear } = options;

    if (uniforms == null) {
      uniforms = {};
    }
    if (material == null) {
      material = true;
    }

    const hasStyle = uniforms.styleColor != null;

    this.geometry = new FaceGeometry({
      items: options.items,
      width: options.width,
      height: options.height,
      depth: options.depth,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    const factory = shaders.material();

    const v = factory.vertex;

    v.pipe(this._vertexColor(color, mask));

    v.require(this._vertexPosition(position, material, map, 2, stpq));
    if (!material) {
      v.pipe("face.position", this.uniforms);
    }
    if (material) {
      v.pipe("face.position.normal", this.uniforms);
    }
    v.pipe("project.position", this.uniforms);

    factory.fragment = f = this._fragmentColor(
      hasStyle,
      material,
      color,
      mask,
      map,
      2,
      stpq,
      combine,
      linear
    );

    f.pipe("fragment.color", this.uniforms);

    const opts = factory.link({
      side: external_THREE_.DoubleSide,
    });
    this.material = this._material(opts);

    const object = new external_THREE_.Mesh(this.geometry, this.material);
    object.userData = opts;

    this._raw(object);
    this.renders = [object];
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.renders = this.geometry = this.material = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/linegeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
Line strips arranged in columns and rows

+----+ +----+ +----+ +----+

+----+ +----+ +----+ +----+

+----+ +----+ +----+ +----+
*/

class LineGeometry extends ClipGeometry {
  constructor(options) {
    let closed,
      detail,
      edge,
      joint,
      joints,
      l,
      layers,
      ribbons,
      samples,
      segments,
      strips,
      vertices,
      x,
      y,
      z;
    super(options);

    this._clipUniforms();

    this.closed = closed = options.closed || false;
    this.samples = samples = (+options.samples || 2) + (closed ? 1 : 0);
    this.strips = strips = +options.strips || 1;
    this.ribbons = ribbons = +options.ribbons || 1;
    this.layers = layers = +options.layers || 1;
    this.detail = detail = +options.detail || 1;

    const lines = samples - 1;
    this.joints = joints = detail - 1;

    this.vertices = vertices = (lines - (closed ? 0 : 1)) * joints + samples;
    this.segments = segments = (lines - (closed ? 0 : 1)) * joints + lines;

    const points = vertices * strips * ribbons * layers * 2;
    const quads = segments * strips * ribbons * layers;
    const triangles = quads * 2;

    this.setIndex(new external_THREE_.BufferAttribute(new Uint32Array(triangles * 3), 1));

    this.setAttribute(
      "position4",
      new external_THREE_.BufferAttribute(new Float32Array(points * 4), 4)
    );
    this.setAttribute(
      "line",
      new external_THREE_.BufferAttribute(new Float32Array(points * 1), 1)
    );
    if (detail > 1) {
      this.setAttribute(
        "joint",
        new external_THREE_.BufferAttribute(new Float32Array(points), 1)
      );
    }

    const index = this._emitter("index");
    const position = this._emitter("position4");
    const line = this._emitter("line");
    if (detail > 1) {
      joint = this._emitter("joint");
    }

    let base = 0;
    for (
      let i = 0, end = ribbons * layers, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      for (
        let j = 0, end1 = strips, asc1 = 0 <= end1;
        asc1 ? j < end1 : j > end1;
        asc1 ? j++ : j--
      ) {
        for (
          let k = 0, end2 = segments, asc2 = 0 <= end2;
          asc2 ? k < end2 : k > end2;
          asc2 ? k++ : k--
        ) {
          // note implied - 1
          index(base);
          index(base + 1);
          index(base + 2);

          index(base + 2);
          index(base + 1);
          index(base + 3);

          base += 2;
        }
        base += 2;
      }
    }

    const edger = closed
      ? () => 0
      : function (x) {
          if (x === 0) {
            return -1;
          } else if (x === samples - 1) {
            return 1;
          } else {
            return 0;
          }
        };

    if (detail > 1) {
      let asc3, end3;
      for (
        l = 0, end3 = layers, asc3 = 0 <= end3;
        asc3 ? l < end3 : l > end3;
        asc3 ? l++ : l--
      ) {
        let asc4, end4;
        for (
          z = 0, end4 = ribbons, asc4 = 0 <= end4;
          asc4 ? z < end4 : z > end4;
          asc4 ? z++ : z--
        ) {
          let asc5, end5;
          for (
            y = 0, end5 = strips, asc5 = 0 <= end5;
            asc5 ? y < end5 : y > end5;
            asc5 ? y++ : y--
          ) {
            let asc6, end6, i1;
            for (
              i1 = 0, x = i1, end6 = samples, asc6 = 0 <= end6;
              asc6 ? i1 < end6 : i1 > end6;
              asc6 ? i1++ : i1--, x = i1
            ) {
              edge = edger(x);

              if (edge !== 0) {
                position(x, y, z, l);
                position(x, y, z, l);

                line(1);
                line(-1);

                joint(0.5);
                joint(0.5);
              } else {
                for (
                  let m = 0, end7 = detail, asc7 = 0 <= end7;
                  asc7 ? m < end7 : m > end7;
                  asc7 ? m++ : m--
                ) {
                  position(x, y, z, l);
                  position(x, y, z, l);

                  line(1);
                  line(-1);

                  joint(m / joints);
                  joint(m / joints);
                }
              }
            }
          }
        }
      }
    } else {
      let asc8, end8;
      for (
        l = 0, end8 = layers, asc8 = 0 <= end8;
        asc8 ? l < end8 : l > end8;
        asc8 ? l++ : l--
      ) {
        let asc9, end9;
        for (
          z = 0, end9 = ribbons, asc9 = 0 <= end9;
          asc9 ? z < end9 : z > end9;
          asc9 ? z++ : z--
        ) {
          let asc10, end10;
          for (
            y = 0, end10 = strips, asc10 = 0 <= end10;
            asc10 ? y < end10 : y > end10;
            asc10 ? y++ : y--
          ) {
            let asc11, end11, j1;
            for (
              j1 = 0, x = j1, end11 = samples, asc11 = 0 <= end11;
              asc11 ? j1 < end11 : j1 > end11;
              asc11 ? j1++ : j1--, x = j1
            ) {
              position(x, y, z, l);
              position(x, y, z, l);

              line(1);
              line(-1);
            }
          }
        }
      }
    }

    this._finalize();
    this.clip();
  }

  clip(samples, strips, ribbons, layers) {
    if (samples == null) {
      samples = this.samples - this.closed;
    }
    if (strips == null) {
      ({ strips } = this);
    }
    if (ribbons == null) {
      ({ ribbons } = this);
    }
    if (layers == null) {
      ({ layers } = this);
    }

    const vertices = samples + (samples - (this.closed ? 0 : 2)) * this.joints;
    const segments = vertices - (this.closed ? 0 : 1);
    samples += this.closed;

    this._clipGeometry(samples, strips, ribbons, layers);
    return this._clipOffsets(
      6,
      segments,
      strips,
      ribbons,
      layers,
      this.segments,
      this.strips,
      this.ribbons,
      this.layers
    );
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/line.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class line_Line extends Base {
  constructor(renderer, shaders, options) {
    let left;
    super(renderer, shaders, options);

    let { uniforms, stroke, join } = options;

    const {
      material,
      position,
      color,
      mask,
      map,
      combine,
      stpq,
      linear,
      clip,
      proximity,
      closed,
    } = options;

    if (uniforms == null) {
      uniforms = {};
    }
    stroke = [null, "dotted", "dashed"][stroke];

    const hasStyle = uniforms.styleColor != null;

    // Line join
    join = (left = ["miter", "round", "bevel"][join]) != null ? left : "miter";
    const detail = { miter: 1, round: 4, bevel: 2 }[join];

    this.geometry = new LineGeometry({
      samples: options.samples,
      strips: options.strips,
      ribbons: options.ribbons,
      layers: options.layers,
      anchor: options.anchor,
      closed: options.closed,
      detail,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    const factory = shaders.material();

    const defs = {};
    if (stroke) {
      defs.LINE_STROKE = "";
    }
    if (clip) {
      defs.LINE_CLIP = "";
    }
    if (proximity != null) {
      defs.LINE_PROXIMITY = "";
    }

    defs["LINE_JOIN_" + join.toUpperCase()] = "";
    if (detail > 1) {
      defs["LINE_JOIN_DETAIL"] = detail;
    }
    if (closed) {
      defs["LINE_CLOSED"] = "";
    }

    const v = factory.vertex;

    v.pipe(this._vertexColor(color, mask));

    v.require(this._vertexPosition(position, material, map, 2, stpq));
    v.pipe("line.position", this.uniforms, defs);
    v.pipe("project.position", this.uniforms);

    const f = factory.fragment;
    if (stroke) {
      f.pipe(`fragment.clip.${stroke}`, this.uniforms);
    }
    if (clip) {
      f.pipe("fragment.clip.ends", this.uniforms);
    }
    if (proximity != null) {
      f.pipe("fragment.clip.proximity", this.uniforms);
    }

    f.pipe(
      this._fragmentColor(
        hasStyle,
        material,
        color,
        mask,
        map,
        2,
        stpq,
        combine,
        linear
      )
    );

    f.pipe("fragment.color", this.uniforms);

    const opts = factory.link({
      side: external_THREE_.DoubleSide,
    });
    this.material = this._material(opts);

    const object = new external_THREE_.Mesh(this.geometry, this.material);
    object.userData = opts;

    this._raw(object);
    this.renders = [object];
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.renders = this.geometry = this.material = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/matrixbuffer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
 * 2D + history array
 */
class MatrixBuffer extends DataBuffer {
  constructor(renderer, shaders, options) {
    const width = options.width || 1;
    const height = options.height || 1;
    const history = options.history || 1;

    options.depth = history;

    super(renderer, shaders, options, false);

    this.width = width;
    this.height = height;
    this.history = history;
    this.samples = width * height;
    this.wrap = history > 1;

    this.build(options);
  }

  build(_options) {
    super.build();

    this.index = 0;
    this.pad = { x: 0, y: 0 };
    return (this.streamer = this.generate(this.data));
  }

  getFilled() {
    return this.filled;
  }

  setActive(i, j) {
    let ref;
    return (
      ([this.pad.x, this.pad.y] = Array.from(
        (ref = [Math.max(0, this.width - i), Math.max(0, this.height - j)])
      )),
      ref
    );
  }

  fill() {
    let j, k, repeat;
    const { callback } = this;
    if (typeof callback.reset === "function") {
      callback.reset();
    }

    const { emit, skip, count, done, reset } = this.streamer;
    reset();

    const n = this.width;
    const pad = this.pad.x;
    const limit = this.samples - this.pad.y * n;

    let i = (j = k = 0);
    if (pad) {
      while (!done() && k < limit) {
        k++;
        repeat = callback(emit, i, j);
        if (++i === n - pad) {
          skip(pad);
          k += pad;
          i = 0;
          j++;
        }
        if (repeat === false) {
          break;
        }
      }
    } else {
      while (!done() && k < limit) {
        k++;
        repeat = callback(emit, i, j);
        if (++i === n) {
          i = 0;
          j++;
        }
        if (repeat === false) {
          break;
        }
      }
    }

    return Math.floor(count() / this.items);
  }

  write(n) {
    if (n == null) {
      n = this.samples;
    }
    n *= this.items;
    const width = this.width * this.items;
    const height = Math.ceil(n / width);

    this.texture.write(this.data, 0, this.index * this.height, width, height);
    this.dataPointer.set(0.5, this.index * this.height + 0.5);
    this.index = (this.index + this.history - 1) % this.history;
    return (this.filled = Math.min(this.history, this.filled + 1));
  }

  through(callback, target) {
    let dst, j, src;
    const { consume, skip, done } = (src = this.streamer);
    const { emit } = (dst = target.streamer);

    let i = (j = 0);

    let pipe = () => consume((x, y, z, w) => callback(emit, x, y, z, w, i, j));
    pipe = repeatCall(pipe, this.items);

    return () => {
      let k;
      src.reset();
      dst.reset();

      const n = this.width;
      const pad = this.pad.x;
      const limit = this.samples - this.pad.y * n;

      i = j = k = 0;
      if (pad) {
        while (!done() && k < limit) {
          k++;
          pipe();
          if (++i === n - pad) {
            skip(pad);
            i = 0;
            j++;
          }
        }
      } else {
        while (!done() && k < limit) {
          k++;
          pipe();
          if (++i === n) {
            i = 0;
            j++;
          }
        }
      }

      return src.count();
    };
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/texture/rendertarget.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
Virtual RenderTarget that cycles through multiple frames
Provides easy access to past rendered frames
@reads[] and @write contain WebGLRenderTargets whose internal pointers are rotated automatically
*/





class RenderTarget {
  constructor(gl, width, height, frames, options) {
    this.gl = gl;
    if (options == null) {
      options = {};
    }
    if (options.minFilter == null) {
      options.minFilter = external_THREE_.NearestFilter;
    }
    if (options.magFilter == null) {
      options.magFilter = external_THREE_.NearestFilter;
    }
    if (options.format == null) {
      options.format = external_THREE_.RGBAFormat;
    }
    if (options.type == null) {
      options.type = external_THREE_.UnsignedByteType;
    }

    this.options = options;

    this.width = width || 1;
    this.height = height || 1;
    this.frames = frames || 1;
    this.buffers = this.frames + 1;

    this.build();
  }

  build() {
    let i;
    const make = () =>
      new external_THREE_.WebGLRenderTarget(this.width, this.height, this.options);

    this.targets = (() => {
      let asc, end;
      const result = [];
      for (
        i = 0, end = this.buffers, asc = 0 <= end;
        asc ? i < end : i > end;
        asc ? i++ : i--
      ) {
        result.push(make());
      }
      return result;
    })();

    const acc = [];
    this.targets.forEach((target) => acc.push(target.texture));
    this.reads = acc;

    this.write = this.targets[this.buffers - 1];

    // Texture access uniforms
    this.uniforms = {
      dataResolution: {
        type: "v2",
        value: new external_THREE_.Vector2(1 / this.width, 1 / this.height),
      },
      dataTexture: {
        type: "t",
        value: this.reads[0],
      },
      dataTextures: {
        type: "tv",
        value: this.reads,
      },
    };
  }

  cycle() {
    this.targets.unshift(this.targets.pop());
    this.write = this.targets[this.buffers - 1];
    this.reads.unshift(this.reads.pop());
    this.uniforms.dataTexture.value = this.reads[0];
  }

  warmup(callback) {
    return (() => {
      const result = [];
      for (
        let i = 0, end = this.buffers, asc = 0 <= end;
        asc ? i < end : i > end;
        asc ? i++ : i--
      ) {
        callback(this.write);
        result.push(this.cycle());
      }
      return result;
    })();
  }

  dispose() {
    for (const target of Array.from(this.targets)) {
      target.dispose();
    }
    return (this.targets = this.reads = this.write = null);
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/rendertotexture.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */







/*
 * Render-To-Texture with history
 */
class RenderToTexture extends Renderable {
  constructor(renderer, shaders, options) {
    super(renderer, shaders);

    this.scene = options.scene != null ? options.scene : new external_THREE_.Scene();
    this.camera = options.camera;

    this.build(options);
  }

  shaderRelative(shader) {
    if (shader == null) {
      shader = this.shaders.shader();
    }
    return shader.pipe("sample.2d", this.uniforms);
  }

  shaderAbsolute(shader, frames, indices) {
    if (frames == null) {
      frames = 1;
    }
    if (indices == null) {
      indices = 4;
    }
    if (shader == null) {
      shader = this.shaders.shader();
    }
    if (frames <= 1) {
      if (indices > 2) {
        shader.pipe(truncateVec(indices, 2));
      }
      shader.pipe("map.2d.data", this.uniforms);
      return shader.pipe("sample.2d", this.uniforms);
    } else {
      const sample2DArray = glsl_sample2DArray(
        Math.min(frames, this.target.frames)
      );
      if (indices < 4) {
        shader.pipe(extendVec(indices, 4));
      }
      shader.pipe("map.xyzw.2dv");
      shader.split();
      shader.pipe("map.2d.data", this.uniforms);
      shader.pass();
      return shader.pipe(sample2DArray, this.uniforms);
    }
  }

  build(options) {
    if (!this.camera) {
      this.camera = new external_THREE_.PerspectiveCamera();
      this.camera.position.set(0, 0, 3);
      this.camera.lookAt(new external_THREE_.Vector3());
    }
    if (typeof this.scene.inject === "function") {
      this.scene.inject();
    }

    this.target = new RenderTarget(
      this.gl,
      options.width,
      options.height,
      options.frames,
      options
    );
    this.target.warmup((target) => this.renderer.setRenderTarget(target));
    this.renderer.setRenderTarget(null);

    this._adopt(this.target.uniforms);
    this._adopt({
      dataPointer: {
        type: "v2",
        value: new external_THREE_.Vector2(0.5, 0.5),
      },
    });

    return (this.filled = 0);
  }

  adopt(renderable) {
    return Array.from(renderable.renders).map((object) =>
      this.scene.add(object)
    );
  }
  unadopt(renderable) {
    return Array.from(renderable.renders).map((object) =>
      this.scene.remove(object)
    );
  }

  render(camera) {
    if (camera == null) {
      ({ camera } = this);
    }
    const currentTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(this.target.write);
    this.renderer.render(
      this.scene.scene != null ? this.scene.scene : this.scene,
      camera
    );
    this.renderer.setRenderTarget(currentTarget);

    this.target.cycle();
    if (this.filled < this.target.frames) {
      return this.filled++;
    }
  }

  read(frame) {
    if (frame == null) {
      frame = 0;
    }
    return this.target.reads[Math.abs(frame)];
  }

  getFrames() {
    return this.target.frames;
  }

  getFilled() {
    return this.filled;
  }

  dispose() {
    if (typeof this.scene.unject === "function") {
      this.scene.unject();
    }
    this.scene = this.camera = null;

    this.target.dispose();

    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/memo.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
 * Wrapped RTT for memoizing 4D arrays back to a 2D texture
 */
class memo_Memo extends RenderToTexture {
  constructor(renderer, shaders, options) {
    let _height, _width;
    const items = options.items || 1;
    const channels = options.channels || 4;
    const width = options.width || 1;
    const height = options.height || 1;
    const depth = options.depth || 1;

    // RGBFormat was removed in r137 of ThreeJS
    //options.format = [null, THREE.LuminanceFormat, THREE.LuminanceAlphaFormat, THREE.RGBFormat, THREE.RGBAFormat][@channels]
    options.format = external_THREE_.RGBAFormat;
    options.width = _width = items * width;
    options.height = _height = height * depth;
    options.frames = 1;

    delete options.items;
    delete options.depth;
    delete options.channels;

    super(renderer, shaders, options);

    if (this.items == null) {
      this.items = items;
    }
    if (this.channels == null) {
      this.channels = channels;
    }
    if (this.width == null) {
      this.width = width;
    }
    this._width = _width;
    if (this.height == null) {
      this.height = height;
    }
    this._height = _height;
    if (this.depth == null) {
      this.depth = depth;
    }

    this._adopt({
      textureItems: { type: "f", value: this.items },
      textureHeight: { type: "f", value: this.height },
    });
  }

  shaderAbsolute(shader) {
    if (shader == null) {
      shader = this.shaders.shader();
    }
    shader.pipe("map.xyzw.texture", this.uniforms);
    return super.shaderAbsolute(shader, 1, 2);
  }
}
//shader.pipe Util.GLSL.swizzleVec4 ['0000', 'x000', 'xw00', 'xyz0'][@channels] if @channels < 4

;// CONCATENATED MODULE: ./src/render/geometry/surfacegeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
Grid Surface

+----+----+----+----+
|    |    |    |    |
+----+----+----+----+
|    |    |    |    |
+----+----+----+----+

+----+----+----+----+
|    |    |    |    |
+----+----+----+----+
|    |    |    |    |
+----+----+----+----+
*/

class SurfaceGeometry extends ClipGeometry {
  constructor(options, build) {
    if (build == null) {
      build = true;
    }
    super();
    // TODO not great... but use this pattern, maybe, to defer construction if
    // options are missing, NOT the boolean.
    if (build) {
      this.construct(options);
    }
  }

  construct(options) {
    let closedX, closedY, height, layers, segmentsX, segmentsY, surfaces, width;
    this._clipUniforms();

    this.closedX = closedX = options.closedX || false;
    this.closedY = closedY = options.closedY || false;
    this.width = width = (+options.width || 2) + (closedX ? 1 : 0);
    this.height = height = (+options.height || 2) + (closedY ? 1 : 0);
    this.surfaces = surfaces = +options.surfaces || 1;
    this.layers = layers = +options.layers || 1;

    this.segmentsX = segmentsX = Math.max(0, width - 1);
    this.segmentsY = segmentsY = Math.max(0, height - 1);

    const points = width * height * surfaces * layers;
    const quads = segmentsX * segmentsY * surfaces * layers;
    const triangles = quads * 2;

    this.setIndex(new external_THREE_.BufferAttribute(new Uint32Array(triangles * 3), 1));

    this.setAttribute(
      "position4",
      new external_THREE_.BufferAttribute(new Float32Array(points * 4), 4)
    );
    this.setAttribute(
      "surface",
      new external_THREE_.BufferAttribute(new Float32Array(points * 2), 2)
    );

    const index = this._emitter("index");
    const position = this._emitter("position4");

    let base = 0;
    for (
      let i = 0, end = surfaces * layers, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      for (
        let j = 0, end1 = segmentsY, asc1 = 0 <= end1;
        asc1 ? j < end1 : j > end1;
        asc1 ? j++ : j--
      ) {
        for (
          let k = 0, end2 = segmentsX, asc2 = 0 <= end2;
          asc2 ? k < end2 : k > end2;
          asc2 ? k++ : k--
        ) {
          index(base);
          index(base + 1);
          index(base + width);

          index(base + width);
          index(base + 1);
          index(base + width + 1);

          base++;
        }
        base++;
      }
      base += width;
    }

    for (
      let l = 0, end3 = layers, asc3 = 0 <= end3;
      asc3 ? l < end3 : l > end3;
      asc3 ? l++ : l--
    ) {
      for (
        let z = 0, end4 = surfaces, asc4 = 0 <= end4;
        asc4 ? z < end4 : z > end4;
        asc4 ? z++ : z--
      ) {
        for (
          let i1 = 0, y = i1, end5 = height, asc5 = 0 <= end5;
          asc5 ? i1 < end5 : i1 > end5;
          asc5 ? i1++ : i1--, y = i1
        ) {
          for (
            let j1 = 0, x = j1, end6 = width, asc6 = 0 <= end6;
            asc6 ? j1 < end6 : j1 > end6;
            asc6 ? j1++ : j1--, x = j1
          ) {
            position(x, y, z, l);
          }
        }
      }
    }

    this._finalize();
    this.clip();
  }

  clip(width, height, surfaces, layers) {
    if (width == null) {
      width = this.width - this.closedX;
    }
    if (height == null) {
      height = this.height - this.closedY;
    }
    if (surfaces == null) {
      ({ surfaces } = this);
    }
    if (layers == null) {
      ({ layers } = this);
    }
    width += this.closedX;
    height += this.closedY;

    const segmentsX = Math.max(0, width - 1);
    const segmentsY = Math.max(0, height - 1);

    this._clipGeometry(width, height, surfaces, layers);
    return this._clipOffsets(
      6,
      segmentsX,
      segmentsY,
      surfaces,
      layers,
      this.segmentsX,
      this.segmentsY,
      this.surfaces,
      this.layers
    );
  }

  map(width, height, surfaces, layers) {
    if (width == null) {
      ({ width } = this);
    }
    if (height == null) {
      ({ height } = this);
    }
    if (surfaces == null) {
      ({ surfaces } = this);
    }
    if (layers == null) {
      ({ layers } = this);
    }
    return this._clipMap(width, height, surfaces, layers);
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/screengeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
Grid Surface in normalized screen space

+----+----+----+----+
|    |    |    |    |
+----+----+----+----+
|    |    |    |    |
+----+----+----+----+

+----+----+----+----+
|    |    |    |    |
+----+----+----+----+
|    |    |    |    |
+----+----+----+----+
*/

class ScreenGeometry extends SurfaceGeometry {
  constructor(options) {
    options.width = Math.max(2, +options.width != null ? +options.width : 2);
    options.height = Math.max(2, +options.height != null ? +options.height : 2);

    super(options, false);

    if (this.uniforms == null) {
      this.uniforms = {};
    }
    this.uniforms.geometryScale = {
      type: "v4",
      value: new external_THREE_.Vector4(),
    };

    this.cover();
    this.construct(options);
  }

  cover(scaleX, scaleY, scaleZ, scaleW) {
    if (scaleX == null) {
      scaleX = 1;
    }
    this.scaleX = scaleX;
    if (scaleY == null) {
      scaleY = 1;
    }
    this.scaleY = scaleY;
    if (scaleZ == null) {
      scaleZ = 1;
    }
    this.scaleZ = scaleZ;
    if (scaleW == null) {
      scaleW = 1;
    }
    this.scaleW = scaleW;
  }

  clip(width, height, surfaces, layers) {
    if (width == null) {
      ({ width } = this);
    }
    if (height == null) {
      ({ height } = this);
    }
    if (surfaces == null) {
      ({ surfaces } = this);
    }
    if (layers == null) {
      ({ layers } = this);
    }
    super.clip(width, height, surfaces, layers);

    const invert = (x) => 1 / Math.max(1, x - 1);
    return this.uniforms.geometryScale.value.set(
      invert(width) * this.scaleX,
      invert(height) * this.scaleY,
      invert(surfaces) * this.scaleZ,
      invert(layers) * this.scaleW
    );
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/screen.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Screen extends Base {
  constructor(renderer, shaders, options) {
    let f;
    super(renderer, shaders, options);

    let { uniforms } = options;
    const { map, combine, stpq, linear } = options;

    if (uniforms == null) {
      uniforms = {};
    }

    const hasStyle = uniforms.styleColor != null;

    this.geometry = new ScreenGeometry({
      width: options.width,
      height: options.height,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    const factory = shaders.material();

    const v = factory.vertex;
    v.pipe("raw.position.scale", this.uniforms);
    v.fan();
    v.pipe("stpq.xyzw.2d", this.uniforms);
    v.next();
    v.pipe("screen.position", this.uniforms);
    v.join();

    factory.fragment = f = this._fragmentColor(
      hasStyle,
      false,
      null,
      null,
      map,
      2,
      stpq,
      combine,
      linear
    );

    f.pipe("fragment.color", this.uniforms);

    const opts = factory.link({
      side: external_THREE_.DoubleSide,
    });
    this.material = this._material(opts);

    const object = new external_THREE_.Mesh(this.geometry, this.material);
    object.frustumCulled = false;
    object.userData = opts;

    this._raw(object);
    this.renders = [object];
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.renders = this.geometry = this.material = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/memoscreen.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




class MemoScreen extends Screen {
  constructor(renderer, shaders, options) {
    const { items, width, height, depth, stpq } = options;

    const inv = (x) => 1 / Math.max(1, x);
    const inv1 = (x) => 1 / Math.max(1, x - 1);

    const uniforms = {
      remapUVScale: {
        type: "v2",
        value: new external_THREE_.Vector2(items * width, height * depth),
      },
      remapModulus: {
        type: "v2",
        value: new external_THREE_.Vector2(items, height),
      },
      remapModulusInv: {
        type: "v2",
        value: new external_THREE_.Vector2(inv(items), inv(height)),
      },
      remapSTPQScale: {
        type: "v4",
        value: new external_THREE_.Vector4(inv1(width), inv1(height), inv1(depth), inv1(items)),
      },
    };

    const map = shaders.shader();
    map.pipe("screen.map.xyzw", uniforms);
    if (options.map != null) {
      // Need artifical STPQs because the screen is not the real geometry
      if (stpq) {
        map.pipe("screen.map.stpq", uniforms);
      }
      map.pipe(options.map);
    }

    super(renderer, shaders, { map, linear: true });
    this.memo = options;
    this.uniforms = uniforms;

    for (const object of Array.from(this.renders)) {
      object.transparent = false;
    }
  }

  cover(width, height, depth, items) {
    if (width == null) {
      ({ width } = this.memo);
    }
    if (height == null) {
      ({ height } = this.memo);
    }
    if (depth == null) {
      ({ depth } = this.memo);
    }
    if (items == null) {
      ({ items } = this.memo);
    }
    const inv1 = (x) => 1 / Math.max(1, x - 1);
    this.uniforms.remapSTPQScale.value.set(
      inv1(width),
      inv1(height),
      inv1(depth),
      inv1(items)
    );

    const x = width / this.memo.width;
    let y = depth / this.memo.depth;
    if (this.memo.depth === 1) {
      y = height / this.memo.height;
    }

    return this.geometry.cover(x, y);
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/spritegeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
Render points as quads

+----+  +----+  +----+  +----+
|    |  |    |  |    |  |    |
+----+  +----+  +----+  +----+

+----+  +----+  +----+  +----+
|    |  |    |  |    |  |    |
+----+  +----+  +----+  +----+

+----+  +----+  +----+  +----+
|    |  |    |  |    |  |    |
+----+  +----+  +----+  +----+

*/

class SpriteGeometry extends ClipGeometry {
  constructor(options) {
    let depth, height, items, width;
    super(options);

    this._clipUniforms();

    this.items = items = +options.items || 2;
    this.width = width = +options.width || 1;
    this.height = height = +options.height || 1;
    this.depth = depth = +options.depth || 1;

    const samples = items * width * height * depth;
    const points = samples * 4;
    const triangles = samples * 2;

    this.setIndex(new external_THREE_.BufferAttribute(new Uint32Array(triangles * 3), 1));

    this.setAttribute(
      "position4",
      new external_THREE_.BufferAttribute(new Float32Array(points * 4), 4)
    );
    this.setAttribute(
      "sprite",
      new external_THREE_.BufferAttribute(new Float32Array(points * 2), 2)
    );

    const index = this._emitter("index");
    const position = this._emitter("position4");
    const sprite = this._emitter("sprite");

    const quad = [
      [-1, -1],
      [-1, 1],
      [1, -1],
      [1, 1],
    ];

    let base = 0;
    for (
      let i = 0, end = samples, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      index(base);
      index(base + 1);
      index(base + 2);

      index(base + 1);
      index(base + 2);
      index(base + 3);

      base += 4;
    }

    for (
      let z = 0, end1 = depth, asc1 = 0 <= end1;
      asc1 ? z < end1 : z > end1;
      asc1 ? z++ : z--
    ) {
      for (
        let y = 0, end2 = height, asc2 = 0 <= end2;
        asc2 ? y < end2 : y > end2;
        asc2 ? y++ : y--
      ) {
        for (
          let x = 0, end3 = width, asc3 = 0 <= end3;
          asc3 ? x < end3 : x > end3;
          asc3 ? x++ : x--
        ) {
          for (
            let l = 0, end4 = items, asc4 = 0 <= end4;
            asc4 ? l < end4 : l > end4;
            asc4 ? l++ : l--
          ) {
            for (const v of Array.from(quad)) {
              position(x, y, z, l);
              sprite(v[0], v[1]);
            }
          }
        }
      }
    }

    this._finalize();
    this.clip();
  }

  clip(width, height, depth, items) {
    if (width == null) {
      ({ width } = this);
    }
    if (height == null) {
      ({ height } = this);
    }
    if (depth == null) {
      ({ depth } = this);
    }
    if (items == null) {
      ({ items } = this);
    }
    this._clipGeometry(width, height, depth, items);
    return this._clipOffsets(
      6,
      width,
      height,
      depth,
      items,
      this.width,
      this.height,
      this.depth,
      this.items
    );
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/point.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class point_Point extends Base {
  constructor(renderer, shaders, options) {
    let f, left;
    super(renderer, shaders, options);

    let { uniforms, shape, fill } = options;

    const {
      material,
      position,
      color,
      size,
      mask,
      map,
      combine,
      linear,
      optical,
      stpq,
    } = options;

    if (uniforms == null) {
      uniforms = {};
    }
    shape = +shape != null ? +shape : 0;
    if (fill == null) {
      fill = true;
    }

    const hasStyle = uniforms.styleColor != null;

    const shapes = [
      "circle",
      "square",
      "diamond",
      "up",
      "down",
      "left",
      "right",
    ];
    const passes = [
      "circle",
      "generic",
      "generic",
      "generic",
      "generic",
      "generic",
      "generic",
    ];
    const scales = [1.2, 1, 1.414, 1.16, 1.16, 1.16, 1.16];
    const pass = passes[shape] != null ? passes[shape] : passes[0];
    const _shape = shapes[shape] != null ? shapes[shape] : shapes[0];
    const _scale = (left = optical && scales[shape]) != null ? left : 1;
    const alpha = fill ? pass : `${pass}.hollow`;

    this.geometry = new SpriteGeometry({
      items: options.items,
      width: options.width,
      height: options.height,
      depth: options.depth,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    const defines = { POINT_SHAPE_SCALE: +(_scale + 0.00001) };

    // Shared vertex shader
    const factory = shaders.material();
    const v = factory.vertex;

    v.pipe(this._vertexColor(color, mask));

    // Point sizing
    if (size) {
      v.isolate();
      v.require(size);
      v.require("point.size.varying", this.uniforms);
      v.end();
    } else {
      v.require("point.size.uniform", this.uniforms);
    }

    v.require(this._vertexPosition(position, material, map, 2, stpq));

    v.pipe("point.position", this.uniforms, defines);
    v.pipe("project.position", this.uniforms);

    // Shared fragment shader
    factory.fragment = f = this._fragmentColor(
      hasStyle,
      material,
      color,
      mask,
      map,
      2,
      stpq,
      combine,
      linear
    );

    // Split fragment into edge and fill pass for better z layering
    const edgeFactory = shaders.material();
    edgeFactory.vertex.pipe(v);
    f = edgeFactory.fragment.pipe(factory.fragment);
    f.require(`point.mask.${_shape}`, this.uniforms);
    f.require(`point.alpha.${alpha}`, this.uniforms);
    f.pipe("point.edge", this.uniforms);

    const fillFactory = shaders.material();
    fillFactory.vertex.pipe(v);
    f = fillFactory.fragment.pipe(factory.fragment);
    f.require(`point.mask.${_shape}`, this.uniforms);
    f.require(`point.alpha.${alpha}`, this.uniforms);
    f.pipe("point.fill", this.uniforms);

    const fillOpts = fillFactory.link({
      side: external_THREE_.DoubleSide,
    });
    this.fillMaterial = this._material(fillOpts);

    const edgeOpts = edgeFactory.link({
      side: external_THREE_.DoubleSide,
    });
    this.edgeMaterial = this._material(edgeOpts);

    this.fillObject = new external_THREE_.Mesh(this.geometry, this.fillMaterial);
    this.edgeObject = new external_THREE_.Mesh(this.geometry, this.edgeMaterial);

    this._raw(this.fillObject);
    this.fillObject.userData = fillOpts;

    this._raw(this.edgeObject);
    this.edgeObject.userData = edgeOpts;

    this.renders = [this.fillObject, this.edgeObject];
  }

  show(transparent, blending, order, depth) {
    this._show(this.edgeObject, true, blending, order, depth);
    return this._show(this.fillObject, transparent, blending, order, depth);
  }

  dispose() {
    this.geometry.dispose();
    this.edgeMaterial.dispose();
    this.fillMaterial.dispose();
    this.renders =
      this.edgeObject =
      this.fillObject =
      this.geometry =
      this.edgeMaterial =
      this.fillMaterial =
        null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/pushbuffer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


/*
 * Buffer for CPU-side use
 */
class PushBuffer extends buffer_Buffer {
  constructor(renderer, shaders, options) {
    const width = options.width || 1;
    const height = options.height || 1;
    const depth = options.depth || 1;
    const samples = width * height * depth;

    if (!options.samples) {
      options.samples = samples;
    }

    super(renderer, shaders, options);

    this.width = width;
    this.height = height;
    this.depth = depth;
    if (this.samples == null) {
      this.samples = samples;
    }

    this.build(options);
  }

  build(_options) {
    this.data = [];
    this.data.length = this.samples;

    this.filled = 0;
    this.pad = { x: 0, y: 0, z: 0 };
    return (this.streamer = this.generate(this.data));
  }

  dispose() {
    this.data = null;
    return super.dispose();
  }

  getFilled() {
    return this.filled;
  }

  setActive(i, j, k) {
    let ref;
    return (
      ([this.pad.x, this.pad.y, this.pad.z] = Array.from(
        (ref = [this.width - i, this.height - j, this.depth - k])
      )),
      ref
    );
  }

  read() {
    return this.data;
  }

  copy(data) {
    const n = Math.min(data.length, this.samples);
    const d = this.data;
    return pushbuffer_range_(0, n, false).map((i) => (d[i] = data[i]));
  }

  fill() {
    let j, k, l, repeat;
    const { callback } = this;
    if (typeof callback.reset === "function") {
      callback.reset();
    }

    const { emit, skip, count, done, reset } = this.streamer;
    reset();

    const n = this.width;
    const m = this.height;
    const padX = this.pad.x;
    const padY = this.pad.y;
    const limit = this.samples - this.pad.z * n * m;

    let i = (j = k = l = 0);
    if (padX > 0 || padY > 0) {
      while (!done() && l < limit) {
        l++;
        repeat = callback(emit, i, j, k);
        if (++i === n - padX) {
          skip(padX);
          i = 0;
          if (++j === m - padY) {
            skip(n * padY);
            j = 0;
            k++;
          }
        }
        if (repeat === false) {
          break;
        }
      }
    } else {
      while (!done() && l < limit) {
        l++;
        repeat = callback(emit, i, j, k);
        if (++i === n) {
          i = 0;
          if (++j === m) {
            j = 0;
            k++;
          }
        }
        if (repeat === false) {
          break;
        }
      }
    }

    this.filled = 1;
    return count();
  }
}

function pushbuffer_range_(left, right, inclusive) {
  const range = [];
  const ascending = left < right;
  const end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}

;// CONCATENATED MODULE: ./src/render/buffer/readback.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */









/*
 * Readback up to 4D array of up to 4D data from GL
 */
class readback_Readback extends Renderable {
  constructor(renderer, shaders, options) {
    super(renderer, shaders);

    if (this.items == null) {
      this.items = options.items || 1;
    }
    if (this.channels == null) {
      this.channels = options.channels || 4;
    }
    if (this.width == null) {
      this.width = options.width || 1;
    }
    if (this.height == null) {
      this.height = options.height || 1;
    }
    if (this.depth == null) {
      this.depth = options.depth || 1;
    }
    if (this.type == null) {
      this.type = options.type || external_THREE_.FloatType;
    }
    if (this.stpq == null) {
      this.stpq = options.stpq || false;
    }
    this.isFloat = this.type === external_THREE_.FloatType;

    this.active = this.sampled = this.rect = this.pad = null;

    this.build(options);

    /*
    * log precision
    gl = @gl
    for name, pass of {Vertex: gl.VERTEX_SHADER, Fragment: gl.FRAGMENT_SHADER}
      bits = for prec in [gl.LOW_FLOAT, gl.MEDIUM_FLOAT, gl.HIGH_FLOAT]
        gl.getShaderPrecisionFormat(pass, prec).precision
      console.log name, 'shader precision',  bits
    */
  }

  build(options) {
    let channels, encoder, stretch;
    const { map } = options;
    const { indexer } = options;
    const isIndexed = indexer != null && !indexer.empty();

    let { stpq } = this;
    const { items, width, height, depth } = this;

    let sampler = map;
    if (isIndexed) {
      // Preserve original xyzw offset of datapoint to tie it back to the source

      // Modulus to pack xyzw into a single integer index
      this._adopt({
        indexModulus: {
          type: "v4",
          value: new external_THREE_.Vector4(items, items * width, items * width * height, 1),
        },
      });

      // Build shader to pack XYZ + index into a single RGBA
      sampler = this.shaders.shader();
      sampler.require(map);
      sampler.require(indexer);
      //sampler.require UGLSL.identity 'vec4'
      sampler.pipe("float.index.pack", this.uniforms);
    }

    if (this.isFloat && this.channels > 1) {
      // Memoize multi-channel float data into float buffer first
      this.floatMemo = new memo_Memo(this.renderer, this.shaders, {
        items,
        channels: 4, // non-RGBA render target not supported
        width,
        height,
        depth,
        history: 0,
        type: external_THREE_.FloatType,
      });

      this.floatCompose = new MemoScreen(this.renderer, this.shaders, {
        map: sampler,
        items,
        width,
        height,
        depth,
        stpq,
      });

      this.floatMemo.adopt(this.floatCompose);

      // Second pass won't need texture coordinates
      stpq = false;

      // Replace sampler with memoized sampler
      sampler = this.shaders.shader();
      this.floatMemo.shaderAbsolute(sampler);
    }

    if (this.isFloat) {
      // Encode float data into byte buffer
      stretch = this.channels;
      channels = 4; // one 32-bit float per pixel
    } else {
      // Render byte data directly
      stretch = 1;
      channels = this.channels;
    }

    if (stretch > 1) {
      // Stretch horizontally, sampling once per channel
      encoder = this.shaders.shader();
      encoder.pipe(mapByte2FloatOffset(stretch));
      encoder.require(sampler);
      encoder.pipe("float.stretch");
      encoder.pipe("float.encode");
      sampler = encoder;
    } else if (this.isFloat) {
      // Direct sampling
      encoder = this.shaders.shader();
      encoder.pipe(sampler);
      encoder.pipe(truncateVec(4, 1));
      encoder.pipe("float.encode");
      sampler = encoder;
    }

    // Memoize byte data
    this.byteMemo = new memo_Memo(this.renderer, this.shaders, {
      items: items * stretch,
      channels: channels, // non-RGBA render target not supported
      width,
      height,
      depth,
      history: 0,
      type: external_THREE_.UnsignedByteType,
    });

    this.byteCompose = new MemoScreen(this.renderer, this.shaders, {
      map: sampler,
      items: items * stretch,
      width,
      height,
      depth,
      stpq,
    });

    this.byteMemo.adopt(this.byteCompose);

    // CPU-side buffers
    const w = items * width * stretch;
    const h = height * depth;

    this.samples = this.width * this.height * this.depth;

    this.bytes = new Uint8Array(w * h * 4); // non-RGBA render target not supported
    if (this.isFloat) {
      this.floats = new Float32Array(this.bytes.buffer);
    }
    this.data = this.isFloat ? this.floats : this.bytes;
    this.streamer = this.generate(this.data);

    this.active = { items: 0, width: 0, height: 0, depth: 0 };
    this.sampled = { items: 0, width: 0, height: 0, depth: 0 };
    this.rect = { w: 0, h: 0 };
    this.pad = { x: 0, y: 0, z: 0, w: 0 };

    this.stretch = stretch;
    this.isIndexed = isIndexed;

    return this.setActive(items, width, height, depth);
  }

  generate(data) {
    return getStreamer(data, this.samples, 4, this.items);
  } // non-RGBA render target not supported

  setActive(items, width, height, depth) {
    let ref;
    if (
      items === this.active.items &&
      width === this.active.width &&
      height === this.active.height &&
      depth === this.active.depth
    ) {
      return;
    }

    // Actively sampled area
    [
      this.active.items,
      this.active.width,
      this.active.height,
      this.active.depth,
    ] = Array.from([items, width, height, depth]);

    // Render only necessary samples in RTTs
    if (this.floatCompose != null) {
      this.floatCompose.cover(width, height, depth);
    }
    if (this.byteCompose != null) {
      this.byteCompose.cover(width * this.stretch, height, depth);
    }

    // Calculate readback buffer geometry
    ({ items } = this);
    ({ width } = this.active);
    height = this.depth === 1 ? this.active.height : this.height;
    ({ depth } = this.active);
    const w = items * width * this.stretch;
    const h = height * depth;

    // Calculate array paddings on readback
    [
      this.sampled.items,
      this.sampled.width,
      this.sampled.height,
      this.sampled.depth,
    ] = Array.from([items, width, height, depth]);
    [this.rect.w, this.rect.h] = Array.from([w, h]);
    return (
      ([this.pad.x, this.pad.y, this.pad.z, this.pad.w] = Array.from(
        (ref = [
          this.sampled.width - this.active.width,
          this.sampled.height - this.active.height,
          this.sampled.depth - this.active.depth,
          this.sampled.items - this.active.items,
        ])
      )),
      ref
    );
  }

  update(camera) {
    if (this.floatMemo != null) {
      this.floatMemo.render(camera);
    }
    return this.byteMemo != null ? this.byteMemo.render(camera) : undefined;
  }

  post() {
    const currentTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(this.byteMemo.target.targets[0]);
    this.gl.readPixels(
      0,
      0,
      this.rect.w,
      this.rect.h,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      this.bytes
    );
    this.renderer.setRenderTarget(currentTarget);
  }

  readFloat(n) {
    return this.floatMemo != null ? this.floatMemo.read(n) : undefined;
  }
  readByte(n) {
    return this.byteMemo != null ? this.byteMemo.read(n) : undefined;
  }

  setCallback(callback) {
    this.emitter = this.callback(callback);
  }

  callback(callback) {
    if (!this.isIndexed) {
      return callback;
    }

    const n = this.width;
    const m = this.height;
    const p = this.items;

    // Decode packed index
    const f = function (x, y, z, w) {
      let idx = w;
      const ll = idx % p;
      idx = (idx - ll) / p;
      const ii = idx % n;
      idx = (idx - ii) / n;
      const jj = idx % m;
      idx = (idx - jj) / m;
      const kk = idx;

      return callback(x, y, z, w, ii, jj, kk, ll);
    };

    f.reset = () =>
      typeof callback.reset === "function" ? callback.reset() : undefined;
    return f;
  }

  iterate() {
    let j, k, l;
    let emit = this.emitter;
    if (typeof emit.reset === "function") {
      emit.reset();
    }

    const { consume, skip, count, done, reset } = this.streamer;
    reset();

    const n = this.sampled.width | 0;
    let m = this.sampled.height | 0;
    const o = this.sampled.depth | 0;
    const p = this.sampled.items | 0;
    const padX = this.pad.x | 0;
    const padY = this.pad.y | 0;
    const padZ = this.pad.z | 0;
    const padW = this.pad.w | 0;
    const limit = n * m * p * (o - padZ);

    if (!this.isIndexed) {
      const callback = emit;
      emit = (x, y, z, w) => callback(x, y, z, w, i, j, k, l);
    }

    let i = (j = k = l = m = 0);
    while (!done() && m < limit) {
      m++;
      const repeat = consume(emit);
      if (++l === p - padW) {
        skip(padX);
        l = 0;
        if (++i === n - padX) {
          skip(p * padX);
          i = 0;
          if (++j === m - padY) {
            skip(p * n * padY);
            j = 0;
            k++;
          }
        }
      }
      if (repeat === false) {
        break;
      }
    }

    return Math.floor(count() / p);
  }

  dispose() {
    if (this.floatMemo != null) {
      this.floatMemo.unadopt(this.floatCompose);
    }
    if (this.floatMemo != null) {
      this.floatMemo.dispose();
    }
    if (this.floatCompose != null) {
      this.floatCompose.dispose();
    }

    if (this.byteMemo != null) {
      this.byteMemo.unadopt(this.byteCompose);
    }
    if (this.byteMemo != null) {
      this.byteMemo.dispose();
    }
    if (this.byteCompose != null) {
      this.byteCompose.dispose();
    }

    return (this.floatMemo =
      this.byteMemo =
      this.floatCompose =
      this.byteCompose =
        null);
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/sprite.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class Sprite extends Base {
  constructor(renderer, shaders, options) {
    let f;
    super(renderer, shaders, options);

    let { uniforms } = options;
    const {
      material,
      position,
      sprite,
      map,
      combine,
      linear,
      color,
      mask,
      stpq,
    } = options;

    if (uniforms == null) {
      uniforms = {};
    }

    const hasStyle = uniforms.styleColor != null;

    this.geometry = new SpriteGeometry({
      items: options.items,
      width: options.width,
      height: options.height,
      depth: options.depth,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    // Shared vertex shader
    const factory = shaders.material();
    const v = factory.vertex;

    v.pipe(this._vertexColor(color, mask));

    v.require(this._vertexPosition(position, material, map, 2, stpq));
    v.require(sprite);
    v.pipe("sprite.position", this.uniforms);
    v.pipe("project.position", this.uniforms);

    // Shared fragment shader
    factory.fragment = f = this._fragmentColor(
      hasStyle,
      material,
      color,
      mask,
      map,
      2,
      stpq,
      combine,
      linear
    );

    // Split fragment into edge and fill pass for better z layering
    const edgeFactory = shaders.material();
    edgeFactory.vertex.pipe(v);
    edgeFactory.fragment.pipe(f);
    edgeFactory.fragment.pipe("fragment.transparent", this.uniforms);

    const fillFactory = shaders.material();
    fillFactory.vertex.pipe(v);
    fillFactory.fragment.pipe(f);
    fillFactory.fragment.pipe("fragment.solid", this.uniforms);

    const fillOpts = fillFactory.link({
      side: external_THREE_.DoubleSide,
    });
    this.fillMaterial = this._material(fillOpts);

    const edgeOpts = edgeFactory.link({
      side: external_THREE_.DoubleSide,
    });
    this.edgeMaterial = this._material(edgeOpts);

    this.fillObject = new external_THREE_.Mesh(this.geometry, this.fillMaterial);
    this.edgeObject = new external_THREE_.Mesh(this.geometry, this.edgeMaterial);

    this._raw(this.fillObject);
    this.fillObject.userData = fillOpts;

    this._raw(this.edgeObject);
    this.edgeObject.userData = edgeOpts;

    this.renders = [this.fillObject, this.edgeObject];
  }

  show(transparent, blending, order, depth) {
    this._show(this.edgeObject, true, blending, order, depth);
    return this._show(this.fillObject, transparent, blending, order, depth);
  }

  dispose() {
    this.geometry.dispose();
    this.edgeMaterial.dispose();
    this.fillMaterial.dispose();
    this.renders =
      this.geometry =
      this.edgeMaterial =
      this.fillMaterial =
      this.edgeObject =
      this.fillObject =
        null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/geometry/stripgeometry.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
Triangle strips arranged in items, columns and rows

+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+
| /| /| /   | /| /| /   | /| /| /   | /| /| /
+--+--+/    +--+--+/    +--+--+/    +--+--+/

+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+
| /| /| /   | /| /| /   | /| /| /   | /| /| /
+--+--+/    +--+--+/    +--+--+/    +--+--+/

+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+
| /| /| /   | /| /| /   | /| /| /   | /| /| /
+--+--+/    +--+--+/    +--+--+/    +--+--+/

*/

class StripGeometry extends ClipGeometry {
  constructor(options) {
    let depth, height, items, sides, width;
    super(options);

    this._clipUniforms();

    this.items = items = +options.items || 2;
    this.width = width = +options.width || 1;
    this.height = height = +options.height || 1;
    this.depth = depth = +options.depth || 1;
    this.sides = sides = Math.max(0, items - 2);

    const samples = width * height * depth;
    const points = items * samples;
    const triangles = sides * samples;

    this.setIndex(new external_THREE_.BufferAttribute(new Uint32Array(triangles * 3), 1));

    this.setAttribute(
      "position4",
      new external_THREE_.BufferAttribute(new Float32Array(points * 4), 4)
    );
    this.setAttribute(
      "strip",
      new external_THREE_.BufferAttribute(new Float32Array(points * 3), 3)
    );

    const index = this._emitter("index");
    const position = this._emitter("position4");
    const strip = this._emitter("strip");

    let base = 0;
    for (
      let i = 0, end = samples, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      let o = base;
      for (
        let j = 0, end1 = sides, asc1 = 0 <= end1;
        asc1 ? j < end1 : j > end1;
        asc1 ? j++ : j--
      ) {
        if (j & 1) {
          index(o + 1);
          index(o);
          index(o + 2);
        } else {
          index(o);
          index(o + 1);
          index(o + 2);
        }
        o++;
      }
      base += items;
    }

    const last = items - 1;
    for (
      let z = 0, end2 = depth, asc2 = 0 <= end2;
      asc2 ? z < end2 : z > end2;
      asc2 ? z++ : z--
    ) {
      for (
        let y = 0, end3 = height, asc3 = 0 <= end3;
        asc3 ? y < end3 : y > end3;
        asc3 ? y++ : y--
      ) {
        for (
          let x = 0, end4 = width, asc4 = 0 <= end4;
          asc4 ? x < end4 : x > end4;
          asc4 ? x++ : x--
        ) {
          let f = 1;

          position(x, y, z, 0);
          strip(1, 2, f);

          for (
            let l = 1, end5 = last, asc5 = 1 <= end5;
            asc5 ? l < end5 : l > end5;
            asc5 ? l++ : l--
          ) {
            position(x, y, z, l);
            strip(l - 1, l + 1, (f = -f));
          }

          position(x, y, z, last);
          strip(last - 2, last - 1, -f);
        }
      }
    }

    this._finalize();
    this.clip();
  }

  clip(width, height, depth, items) {
    if (width == null) {
      ({ width } = this);
    }
    if (height == null) {
      ({ height } = this);
    }
    if (depth == null) {
      ({ depth } = this);
    }
    if (items == null) {
      ({ items } = this);
    }
    const sides = Math.max(0, items - 2);

    this._clipGeometry(width, height, depth, items);
    return this._clipOffsets(
      3,
      width,
      height,
      depth,
      sides,
      this.width,
      this.height,
      this.depth,
      this.sides
    );
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/strip.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class strip_Strip extends Base {
  constructor(renderer, shaders, options) {
    let f;
    super(renderer, shaders, options);

    let { uniforms, material } = options;
    const { position, color, mask, map, combine, linear, stpq } = options;

    if (uniforms == null) {
      uniforms = {};
    }
    if (material == null) {
      material = true;
    }

    const hasStyle = uniforms.styleColor != null;

    this.geometry = new StripGeometry({
      items: options.items,
      width: options.width,
      height: options.height,
      depth: options.depth,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    const factory = shaders.material();

    const v = factory.vertex;

    v.pipe(this._vertexColor(color, mask));

    v.require(this._vertexPosition(position, material, map, 2, stpq));
    if (!material) {
      v.pipe("mesh.position", this.uniforms);
    }
    if (material) {
      v.pipe("strip.position.normal", this.uniforms);
    }
    v.pipe("project.position", this.uniforms);

    factory.fragment = f = this._fragmentColor(
      hasStyle,
      material,
      color,
      mask,
      map,
      2,
      stpq,
      combine,
      linear
    );

    f.pipe("fragment.color", this.uniforms);

    const opts = factory.link({
      side: external_THREE_.DoubleSide,
    });
    this.material = this._material(opts);

    const object = new external_THREE_.Mesh(this.geometry, this.material);
    object.userData = opts;

    this._raw(object);
    this.renders = [object];
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.renders = this.geometry = this.material = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/meshes/surface.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





class surface_Surface extends Base {
  constructor(renderer, shaders, options) {
    let f;
    super(renderer, shaders, options);

    let { uniforms, material } = options;

    const { position, color, normal, mask, map, combine, linear, stpq, intUV } =
      options;

    if (uniforms == null) {
      uniforms = {};
    }
    if (material == null) {
      material = true;
    }

    const hasStyle = uniforms.styleColor != null;

    this.geometry = new SurfaceGeometry({
      width: options.width,
      height: options.height,
      surfaces: options.surfaces,
      layers: options.layers,
      closedX: options.closedX,
      closedY: options.closedY,
    });

    this._adopt(uniforms);
    this._adopt(this.geometry.uniforms);

    const defs = {};
    if (options.closedX) {
      defs.SURFACE_CLOSED_X = "";
    }
    if (options.closedY) {
      defs.SURFACE_CLOSED_Y = "";
    }
    if (intUV) {
      defs.POSITION_UV_INT = "";
    }

    const factory = shaders.material();

    const v = factory.vertex;

    v.pipe(this._vertexColor(color, mask));

    v.require(this._vertexPosition(position, material, map, 2, stpq));

    if (normal) {
      v.require(normal);
      v.pipe("surface.position.normal", this.uniforms, defs);
    } else {
      if (!material) {
        v.pipe("surface.position", this.uniforms, defs);
      }
      if (material) {
        v.pipe("surface.position.shaded", this.uniforms, defs);
      }
    }
    v.pipe("project.position", this.uniforms);

    factory.fragment = f = this._fragmentColor(
      hasStyle,
      material,
      color,
      mask,
      map,
      2,
      stpq,
      combine,
      linear
    );

    f.pipe("fragment.color", this.uniforms);

    const opts = factory.link({
      side: external_THREE_.DoubleSide,
    });
    this.material = this._material(opts);

    const object = new external_THREE_.Mesh(this.geometry, this.material);
    object.userData = opts;

    this._raw(object);
    this.renders = [object];
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.renders = this.geometry = this.material = null;
    return super.dispose();
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/textatlas.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




const SCRATCH_SIZE = 512 / 16;

/*
 * Dynamic text atlas
 * - Stores entire strings as sprites
 * - Renders alpha mask (fast) or signed distance field (slow)
 * - Emits (x,y,width,height) pointers into the atlas
 */
class TextAtlas extends Atlas {
  constructor(renderer, shaders, options) {
    let left;
    if (!options.width) {
      options.width = 256;
    }
    if (!options.height) {
      options.height = 256;
    }
    options.type = external_THREE_.UnsignedByteType;
    options.channels = 1;
    options.backed = true;

    super(renderer, shaders, options, false);

    this.font = options.font != null ? options.font : ["sans-serif"];
    this.size = options.size || 24;
    this.style = options.style != null ? options.style : "normal";
    this.variant = options.variant != null ? options.variant : "normal";
    this.weight = options.weight != null ? options.weight : "normal";
    this.outline =
      (left = +(options.outline != null ? options.outline : 5)) != null
        ? left
        : 0;
    this.gamma = 1;

    if (typeof navigator !== "undefined") {
      const ua = navigator.userAgent;
      if (ua.match(/Chrome/) && ua.match(/OS X/)) {
        this.gamma = 0.5;
      }
    }

    this.scratchW = this.scratchH = 0;

    this.build(options);
  }

  build(options) {
    super.build(options);

    // Prepare line-height with room for outline
    let lineHeight = 16;
    lineHeight = this.size;
    lineHeight += 4 + 2 * Math.min(1, this.outline);
    const maxWidth = SCRATCH_SIZE * lineHeight;

    // Prepare scratch canvas
    const canvas = document.createElement("canvas");
    canvas.width = maxWidth;
    canvas.height = lineHeight;

    const quote = (str) => `${str.replace(/(['"\\])/g, "\\$1")}`;
    const font = this.font.map(quote).join(", ");

    const context = canvas.getContext("2d", { willReadFrequently: true });
    context.font = `${this.style} ${this.variant} ${this.weight} ${this.size}px ${font}`;
    context.fillStyle = "#FF0000";
    context.textAlign = "left";
    context.textBaseline = "bottom";
    context.lineJoin = "round";

    // debug: show scratch canvas
    /*
    document.body.appendChild canvas
    canvas.setAttribute('style', "position: absolute; top: 0; left: 0; z-index: 100; border: 1px solid red; background: rgba(255,0,255,.25);")
    */

    // Cache hex colors for distance field rendering
    const colors = [];
    const dilate = this.outline * 3;
    for (
      let i = 0, end = dilate, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      // 8 rgb levels = 1 step = .5 pixel increase
      const hex = (
        "00" + Math.max(0, -i * 8 + 128 - !i * 8).toString(16)
      ).slice(-2);
      colors.push("#" + hex + hex + hex);
    }

    const scratch = new Uint8Array(maxWidth * lineHeight * 2);

    this.canvas = canvas;
    this.context = context;
    this.lineHeight = lineHeight;
    this.maxWidth = maxWidth;
    this.colors = colors;
    this.scratch = scratch;

    this._allocate = this.allocate.bind(this);
    return (this._write = this.write.bind(this));
  }

  reset() {
    super.reset();
    return (this.mapped = {});
  }

  begin() {
    return Array.from(this.rows).map((row) => (row.alive = 0));
  }

  end() {
    const { mapped } = this;
    for (const row of Array.from(this.rows.slice())) {
      if (row.alive === 0) {
        for (const key of Array.from(row.keys)) {
          delete mapped[key];
        }
        this.collapse(row);
      }
    }
  }

  map(text, emit) {
    // See if already mapped into atlas
    const { mapped } = this;
    const c = mapped[text];
    if (c != null) {
      c.row.alive++;
      return emit(c.x, c.y, c.w, c.h);
    }

    // Draw text (don't recurse stack in @draw so it can be optimized cleanly)
    this.draw(text);
    const data = this.scratch;
    const w = this.scratchW;
    const h = this.scratchH;

    // Allocate and write into atlas
    const allocate = this._allocate;
    const write = this._write;
    return allocate(text, w, h, function (row, x, y) {
      mapped[text] = { x, y, w, h, row };
      write(data, x, y, w, h);
      return emit(x, y, w, h);
    });
  }

  draw(text) {
    let data, i, j;
    let w = this.width;
    const h = this.lineHeight;
    const o = this.outline;
    const ctx = this.context;
    const dst = this.scratch;
    const max = this.maxWidth;
    const { colors } = this;

    // Bottom aligned
    const x = o + 1;
    const y = Math.round(h * 1.05 - 1);

    // Measure text
    const m = ctx.measureText(text);
    w = Math.min(max, Math.ceil(m.width + 2 * x + 1));

    // Clear scratch area
    ctx.clearRect(0, 0, w, h);

    if (this.outline === 0) {
      // Alpha sprite (fast)
      let asc, end;
      ctx.fillText(text, x, y);
      ({ data } = ctx.getImageData(0, 0, w, h));
      j = 3; // Skip to alpha channel
      for (
        i = 0, end = data.length / 4, asc = 0 <= end;
        asc ? i < end : i > end;
        asc ? i++ : i--
      ) {
        //dst[i] = 255 * (i%2); # test pattern to check pixel perfect alignment
        dst[i] = data[j];
        j += 4;
      }

      this.scratchW = w;
      return (this.scratchH = h);
    } else {
      // Signed distance field sprite (approximation) (slow)

      // Draw strokes of decreasing width to create nested outlines (absolute distance)
      let asc1, start;
      let asc2, end1;
      ctx.globalCompositeOperation = "source-over";
      for (
        start = o + 1, i = start, asc1 = start <= 1;
        asc1 ? i <= 1 : i >= 1;
        asc1 ? i++ : i--
      ) {
        j = i > 1 ? i * 2 - 2 : i; // Eliminate odd strokes once past > 1px, don't need the detail
        ctx.strokeStyle = colors[j - 1];
        ctx.lineWidth = j;
        ctx.strokeText(text, x, y);
      }
      //console.log 'stroke', j, j+.5, colors[j]

      // Fill center with multiply blend #FF0000 to mark inside/outside
      ctx.globalCompositeOperation = "multiply";
      ctx.fillText(text, x, y);

      // Pull image data
      ({ data } = ctx.getImageData(0, 0, w, h));
      j = 0;
      const { gamma } = this;

      for (
        i = 0, end1 = data.length / 4, asc2 = 0 <= end1;
        asc2 ? i < end1 : i > end1;
        asc2 ? i++ : i--
      ) {
        // Get value + mask
        const a = data[j];
        let mask = a ? data[j + 1] / a : 1;
        if (gamma === 0.5) {
          mask = Math.sqrt(mask);
        }
        mask = Math.min(1, Math.max(0, mask));

        // Blend between positive/outside and negative/inside
        const b = 256 - a;
        const c = b + (a - b) * mask;

        // Clamp
        // (slight expansion to hide errors around the transition)
        dst[i] = Math.max(0, Math.min(255, c + 2));
        j += 4;
      }

      // Debug: copy back into canvas
      //
      // TODO hide behind debug flag or delete.
      /*
      j = 0
      for i in [0...data.length / 4]
        v = dst[i]
        *data[j] = v
        *data[j+1] = v
        data[j+2] = v
        data[j+3] = 255
        j += 4
      ctx.putImageData(imageData, 0, 0);
      */

      this.scratchW = w;
      return (this.scratchH = h);
    }
  }
}

;// CONCATENATED MODULE: ./src/render/buffer/voxelbuffer.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




//
// 3D array
//
class VoxelBuffer extends DataBuffer {
  build(_options) {
    super.build();
    this.pad = { x: 0, y: 0, z: 0 };
    return (this.streamer = this.generate(this.data));
  }

  setActive(i, j, k) {
    let ref;
    return (
      ([this.pad.x, this.pad.y, this.pad.z] = Array.from(
        (ref = [
          Math.max(0, this.width - i),
          Math.max(0, this.height - j),
          Math.max(0, this.depth - k),
        ])
      )),
      ref
    );
  }

  fill() {
    let j, k, l, repeat;
    const { callback } = this;
    if (typeof callback.reset === "function") {
      callback.reset();
    }

    const { emit, skip, count, done, reset } = this.streamer;
    reset();

    const n = this.width;
    const m = this.height;
    const padX = this.pad.x;
    const padY = this.pad.y;
    const limit = this.samples - this.pad.z * n * m;

    let i = (j = k = l = 0);
    if (padX > 0 || padY > 0) {
      while (!done() && l < limit) {
        l++;
        repeat = callback(emit, i, j, k);
        if (++i === n - padX) {
          skip(padX);
          l += padX;
          i = 0;
          if (++j === m - padY) {
            skip(n * padY);
            l += n * padY;
            j = 0;
            k++;
          }
        }
        if (repeat === false) {
          break;
        }
      }
    } else {
      while (!done() && l < limit) {
        l++;
        repeat = callback(emit, i, j, k);
        if (++i === n) {
          i = 0;
          if (++j === m) {
            j = 0;
            k++;
          }
        }
        if (repeat === false) {
          break;
        }
      }
    }

    return Math.floor(count() / this.items);
  }

  through(callback, target) {
    // must be identical sized buffers w/ identical active areas

    let dst, j, k, src;
    const { consume, done, skip } = (src = this.streamer);
    const { emit } = (dst = target.streamer);

    let i = (j = k = 0);

    let pipe = () =>
      consume((x, y, z, w) => callback(emit, x, y, z, w, i, j, k));
    pipe = repeatCall(pipe, this.items);

    return () => {
      let l;
      src.reset();
      dst.reset();
      const n = this.width;
      const m = this.height;
      const padX = this.pad.x;
      const padY = this.pad.y;
      const limit = this.samples - this.pad.z * n * m;

      i = j = k = l = 0;
      if (padX > 0 || padY > 0) {
        while (!done() && l < limit) {
          l++;
          pipe();
          if (++i === n - padX) {
            skip(padX);
            i = 0;
            if (++j === m - padY) {
              skip(n * padY);
              j = 0;
              k++;
            }
          }
        }
      } else {
        while (!done() && l < limit) {
          l++;
          pipe();
          if (++i === n) {
            i = 0;
            if (++j === m) {
              j = 0;
              k++;
            }
          }
        }
      }

      return src.count();
    };
  }
}

;// CONCATENATED MODULE: ./src/render/classes.js






















const render_classes_Classes = {
  sprite: Sprite,
  point: point_Point,
  line: line_Line,
  surface: surface_Surface,
  face: face_Face,
  strip: strip_Strip,
  arrow: Arrow,
  screen: Screen,
  memoScreen: MemoScreen,
  debug: Debug,
  dataBuffer: DataBuffer,
  arrayBuffer: ArrayBuffer_,
  matrixBuffer: MatrixBuffer,
  voxelBuffer: VoxelBuffer,
  pushBuffer: PushBuffer,
  renderToTexture: RenderToTexture,
  memo: memo_Memo,
  readback: readback_Readback,
  atlas: Atlas,
  textAtlas: TextAtlas,
  scene: Scene,
};

;// CONCATENATED MODULE: ./src/render/index.js





;// CONCATENATED MODULE: ./src/shaders/glsl/arrow.position.js
/* harmony default export */ const arrow_position = (/* glsl */`uniform float worldUnit;
uniform float lineDepth;
uniform float lineWidth;
uniform float focusDepth;

uniform vec4 geometryClip;
uniform float arrowSize;
uniform float arrowSpace;

attribute vec4 position4;
attribute vec3 arrow;
attribute vec2 attach;

// External
vec3 getPosition(vec4 xyzw, float canonical);

void getArrowGeometry(vec4 xyzw, float near, float mid, float far, out vec3 left, out vec3 right, out vec3 middle, out vec3 start) {
  right  = getPosition(xyzw, 1.0);
  left   = getPosition(vec4(near, xyzw.yzw), 0.0);
  middle = getPosition(vec4(mid,  xyzw.yzw), 0.0);
  start  = getPosition(vec4(far,  xyzw.yzw), 0.0);
}

mat4 getArrowMatrix(vec3 left, vec3 right, vec3 middle, vec3 start) {

  float depth = focusDepth;
  if (lineDepth < 1.0) {
    // Depth blending
    float z = max(0.00001, -right.z);
    depth = mix(z, focusDepth, lineDepth);
  }

  vec3 diff = left - right;
  float l = length(diff);
  if (l == 0.0) {
    return mat4(1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 0.0, 1.0);
  }

  // Construct TBN matrix around shaft
  vec3 t = normalize(diff);
  vec3 n = normalize(cross(t, t.yzx + vec3(.1, .2, .3)));
  vec3 b = cross(n, t);

  // Shrink arrows when vector gets too small
  // Approach linear scaling with cubic ease the smaller we get
  float size = arrowSize * lineWidth * worldUnit * depth * 1.25;
  l = max(length(right - middle), length(middle - start)) * 2.0 * arrowSpace;
  float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);
  float scale = 1.0 - mini * mini * mini;
  float range = size * scale;

  // Size to 2.5:1 ratio
  float rangeNB = range / 2.5;

  // Anchor at end position
  return mat4(vec4(n * rangeNB,  0),
              vec4(b * rangeNB,  0),
              vec4(t * range, 0),
              vec4(right,  1.0));
}

vec3 getArrowPosition() {
  vec3 left, right, middle, start;

  // Clip arrow position and attachment anchors to data
  vec4 p = min(geometryClip, position4);
  vec3 a = vec3(min(geometryClip.x, p.x + attach.x), geometryClip.x / 2.0, min(geometryClip.x, attach.y));

  getArrowGeometry(p, a.x, a.y, a.z, left, right, middle, start);
  mat4 matrix = getArrowMatrix(left, right, middle, start);

  return (matrix * vec4(arrow.xyz, 1.0)).xyz;

}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/axis.position.js
/* harmony default export */ const axis_position = (/* glsl */`uniform vec4 axisStep;
uniform vec4 axisPosition;

vec4 getAxisPosition(vec4 xyzw, inout vec4 stpq) {
  return axisStep * xyzw.x + axisPosition;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/cartesian4.position.js
/* harmony default export */ const cartesian4_position = (/* glsl */`uniform vec4 basisScale;
uniform vec4 basisOffset;
uniform vec4 viewScale;
uniform vec4 viewOffset;

vec4 getCartesian4Position(vec4 position, inout vec4 stpq) {
  return position * basisScale + basisOffset;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/cartesian.position.js
/* harmony default export */ const cartesian_position = (/* glsl */`uniform mat4 viewMatrix;

vec4 getCartesianPosition(vec4 position, inout vec4 stpq) {
  return viewMatrix * vec4(position.xyz, 1.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/clamp.position.js
/* harmony default export */ const clamp_position = (/* glsl */`uniform vec4 clampLimit;

vec4 getClampXYZW(vec4 xyzw) {
  return clamp(xyzw, vec4(0.0), clampLimit);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/color.opaque.js
/* harmony default export */ const color_opaque = (/* glsl */`vec4 opaqueColor(vec4 color) {
  return vec4(color.rgb, 1.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/face.position.js
/* harmony default export */ const face_position = (/* glsl */`uniform vec4 geometryClip;
attribute vec4 position4;

// External
vec3 getPosition(vec4 xyzw, float canonical);

vec3 getFacePosition() {
  vec4 p = min(geometryClip, position4);
  return getPosition(p, 1.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/face.position.normal.js
/* harmony default export */ const face_position_normal = (/* glsl */`attribute vec4 position4;

// External
vec3 getPosition(vec4 xyzw, float canonical);

varying vec3 vNormal;
varying vec3 vLight;
varying vec3 vPosition;

void getFaceGeometry(vec4 xyzw, out vec3 pos, out vec3 normal) {
  vec3 a, b, c;

  a   = getPosition(vec4(xyzw.xyz, 0.0), 0.0);
  b   = getPosition(vec4(xyzw.xyz, 1.0), 0.0);
  c   = getPosition(vec4(xyzw.xyz, 2.0), 0.0);

  pos = getPosition(xyzw, 1.0);
  normal = normalize(cross(c - a, b - a));
}

vec3 getFacePositionNormal() {
  vec3 center, normal;

  getFaceGeometry(position4, center, normal);
  vNormal   = normal;
  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);
  vPosition = -center;

  return center;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/float.encode.js
/* harmony default export */ const float_encode = (/* glsl */`/*
Float encoding technique by
Carlos Scheidegger
https://github.com/cscheid/lux/blob/master/src/shade/bits/encode_float.js

Conversion to GLSL by:
http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js
*/

float shift_right(float v, float amt) { 
  v = floor(v) + 0.5; 
  return floor(v / exp2(amt)); 
}

float shift_left(float v, float amt) { 
  return floor(v * exp2(amt) + 0.5); 
}

float mask_last(float v, float bits) { 
  return mod(v, shift_left(1.0, bits)); 
}

float extract_bits(float num, float from, float to) { 
  from = floor(from + 0.5); to = floor(to + 0.5); 
  return mask_last(shift_right(num, from), to - from); 
}

vec4 encode_float(float val) { 
  if (val == 0.0) return vec4(0, 0, 0, 0); 
  float valuesign = val > 0.0 ? 0.0 : 1.0; 
  val = abs(val); 
  float exponent = floor(log2(val)); 
  float biased_exponent = exponent + 127.0; 
  float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; 
  float t = biased_exponent / 2.0; 
  float last_bit_of_biased_exponent = fract(t) * 2.0; 
  float remaining_bits_of_biased_exponent = floor(t); 
  float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; 
  float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; 
  float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; 
  float byte1 = (valuesign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; 
  return vec4(byte4, byte3, byte2, byte1); 
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/float.index.pack.js
/* harmony default export */ const float_index_pack = (/* glsl */`uniform vec4 indexModulus;

vec4 getSample(vec4 xyzw);
vec4 getIndex(vec4 xyzw);

vec4 floatPackIndex(vec4 xyzw) {
  vec4 value = getSample(xyzw);
  vec4 index = getIndex(xyzw);

  vec4 offset = floor(index + .5) * indexModulus;
  vec2 sum2 = offset.xy + offset.zw;
  float sum = sum2.x + sum2.y;
  return vec4(value.xyz, sum);
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/float.stretch.js
/* harmony default export */ const float_stretch = (/* glsl */`vec4 getSample(vec4 xyzw);

float floatStretch(vec4 xyzw, float channelIndex) {
  vec4 sample = getSample(xyzw);
  vec2 xy = channelIndex > 1.5 ? sample.zw : sample.xy;
  return mod(channelIndex, 2.0) > .5 ? xy.y : xy.x;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.clip.dashed.js
/* harmony default export */ const fragment_clip_dashed = (/* glsl */`varying float vClipStrokeWidth;
varying float vClipStrokeIndex;
varying vec3  vClipStrokeEven;
varying vec3  vClipStrokeOdd;
varying vec3  vClipStrokePosition;

void clipStrokeFragment() {
  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;

  vec3 tangent;
  if (odd) {
    tangent = vClipStrokeOdd;
  }
  else {
    tangent = vClipStrokeEven;
  }

  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;
  if (mod(travel, 16.0) > 8.0) {
    discard;
  }
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.clip.dotted.js
/* harmony default export */ const fragment_clip_dotted = (/* glsl */`varying float vClipStrokeWidth;
varying float vClipStrokeIndex;
varying vec3  vClipStrokeEven;
varying vec3  vClipStrokeOdd;
varying vec3  vClipStrokePosition;

void clipStrokeFragment() {
  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;

  vec3 tangent;
  if (odd) {
    tangent = vClipStrokeOdd;
  }
  else {
    tangent = vClipStrokeEven;
  }

  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;
  if (mod(travel, 4.0) > 2.0) {
    discard;
  }
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.clip.ends.js
/* harmony default export */ const fragment_clip_ends = (/* glsl */`varying vec2 vClipEnds;

void clipEndsFragment() {
  if (vClipEnds.x < 0.0 || vClipEnds.y < 0.0) discard;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.clip.proximity.js
/* harmony default export */ const fragment_clip_proximity = (/* glsl */`varying float vClipProximity;

void clipProximityFragment() {
  if (vClipProximity >= 0.5) discard;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.color.js
/* harmony default export */ const fragment_color = (/* glsl */`void setFragmentColor(vec4 color) {
  gl_FragColor = color;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.map.rgba.js
/* harmony default export */ const fragment_map_rgba = (/* glsl */`vec4 fragmentRGBA(vec4 rgba, vec4 stpq) {
  return rgba;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.solid.js
/* harmony default export */ const fragment_solid = (/* glsl */`void setFragmentColor(vec4 color) {
  if (color.a < 1.0) discard;
  gl_FragColor = color;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/fragment.transparent.js
/* harmony default export */ const fragment_transparent = (/* glsl */`void setFragmentColor(vec4 color) {
  if (color.a >= 1.0) discard;
  gl_FragColor = color;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/grid.position.js
/* harmony default export */ const grid_position = (/* glsl */`uniform vec4 gridPosition;
uniform vec4 gridStep;
uniform vec4 gridAxis;

vec4 sampleData(vec2 xy);

vec4 getGridPosition(vec4 xyzw) {
  vec4 onAxis  = gridAxis * sampleData(vec2(xyzw.y, 0.0)).x;
  vec4 offAxis = gridStep * xyzw.x + gridPosition;
  return onAxis + offAxis;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/grow.position.js
/* harmony default export */ const grow_position = (/* glsl */`uniform float growScale;
uniform vec4  growMask;
uniform vec4  growAnchor;

vec4 getSample(vec4 xyzw);

vec4 getGrowSample(vec4 xyzw) {
  vec4 anchor = xyzw * growMask + growAnchor;

  vec4 position = getSample(xyzw);
  vec4 center = getSample(anchor);

  return mix(center, position, growScale);
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/join.position.js
/* harmony default export */ const join_position = (/* glsl */`uniform float joinStride;
uniform float joinStrideInv;

float getIndex(vec4 xyzw);
vec4 getRest(vec4 xyzw);
vec4 injectIndices(float a, float b);

vec4 getJoinXYZW(vec4 xyzw) {

  float a = getIndex(xyzw);
  float b = a * joinStrideInv;

  float integer  = floor(b);
  float fraction = b - integer;
  
  return injectIndices(fraction * joinStride, integer) + getRest(xyzw);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/label.alpha.js
/* harmony default export */ const label_alpha = (/* glsl */`varying float vPixelSize;

vec4 getLabelAlphaColor(vec4 color, vec4 sample) {
  float mask = clamp(sample.r * 1000.0, 0.0, 1.0);
  float alpha = (sample.r - .5) * vPixelSize + .5;
  float a = mask * alpha * color.a;
  if (a <= 0.0) discard;
  return vec4(color.xyz, a);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/label.map.js
/* harmony default export */ const label_map = (/* glsl */`vec2 mapUV(vec4 uvwo, vec4 stpq) {
  return uvwo.xy;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/label.outline.js
/* harmony default export */ const label_outline = (/* glsl */`uniform float outlineExpand;
uniform float outlineStep;
uniform vec3  outlineColor;

varying float vPixelSize;

const float PIXEL_STEP = 255.0 / 16.0;

vec4 getLabelOutlineColor(vec4 color, vec4 sample) {
  float ps = vPixelSize * PIXEL_STEP;
  float os = outlineStep;

  float sdf = sample.r - .5 + outlineExpand;
  vec2  sdfs = vec2(sdf, sdf + os);
  vec2  alpha = clamp(sdfs * ps + .5, 0.0, 1.0);

  if (alpha.y <= 0.0) {
    discard;
  }

  vec3 blend = color.xyz;
  if (alpha.y > alpha.x) {
    blend = sqrt(mix(outlineColor * outlineColor, blend * blend, alpha.x));
  }
  
  return vec4(blend, alpha.y * color.a);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/layer.position.js
/* harmony default export */ const layer_position = (/* glsl */`uniform vec4 layerScale;
uniform vec4 layerBias;

#define PROJECT_ORTHOGONAL

vec4 layerPosition(vec4 position, inout vec4 stpq) {
  return layerScale * position + layerBias;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/lerp.depth.js
/* harmony default export */ const lerp_depth = (/* glsl */`// External
vec4 sampleData(vec4 xyzw);

vec4 lerpDepth(vec4 xyzw) {
  float x = xyzw.z;
  float i = floor(x);
  float f = x - i;
    
  vec4 xyzw1 = vec4(xyzw.xy, i, xyzw.w);
  vec4 xyzw2 = vec4(xyzw.xy, i + 1.0, xyzw.w);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, f);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/lerp.height.js
/* harmony default export */ const lerp_height = (/* glsl */`// External
vec4 sampleData(vec4 xyzw);

vec4 lerpHeight(vec4 xyzw) {
  float x = xyzw.y;
  float i = floor(x);
  float f = x - i;
    
  vec4 xyzw1 = vec4(xyzw.x, i, xyzw.zw);
  vec4 xyzw2 = vec4(xyzw.x, i + 1.0, xyzw.zw);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, f);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/lerp.items.js
/* harmony default export */ const lerp_items = (/* glsl */`// External
vec4 sampleData(vec4 xyzw);

vec4 lerpItems(vec4 xyzw) {
  float x = xyzw.w;
  float i = floor(x);
  float f = x - i;
    
  vec4 xyzw1 = vec4(xyzw.xyz, i);
  vec4 xyzw2 = vec4(xyzw.xyz, i + 1.0);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, f);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/lerp.width.js
/* harmony default export */ const lerp_width = (/* glsl */`// External
vec4 sampleData(vec4 xyzw);

vec4 lerpWidth(vec4 xyzw) {
  float x = xyzw.x;
  float i = floor(x);
  float f = x - i;
    
  vec4 xyzw1 = vec4(i, xyzw.yzw);
  vec4 xyzw2 = vec4(i + 1.0, xyzw.yzw);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, f);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/line.position.js
/* harmony default export */ const line_position = (/* glsl */`// Units and calibration
uniform float worldUnit;
uniform float lineWidth;
uniform float lineDepth;
uniform float focusDepth;

// General data index
uniform vec4 geometryClip;
attribute vec4 position4;

// (Top/bottom -1,1)
attribute float line;

// 0...1 for round or bevel joins
#ifdef LINE_JOIN_DETAIL
attribute float joint;
#else
const float joint = 0.0;
#endif

// Knock out excessively long line segments (e.g. for asymtpotes)
#ifdef LINE_PROXIMITY
uniform float lineProximity;
varying float vClipProximity;
#endif

// Ghetto line stroking (local only, not global)
#ifdef LINE_STROKE
varying float vClipStrokeWidth;
varying float vClipStrokeIndex;
varying vec3  vClipStrokeEven;
varying vec3  vClipStrokeOdd;
varying vec3  vClipStrokePosition;
#endif

// External
vec3 getPosition(vec4 xyzw, float canonical);

// Clip line ends for arrows / decoration
#ifdef LINE_CLIP
uniform float clipRange;
uniform vec2  clipStyle;
uniform float clipSpace;

attribute vec2 strip;

varying vec2 vClipEnds;

void clipEnds(vec4 xyzw, vec3 center, vec3 pos) {

  // Sample start of line strip
  vec4 xyzwS = vec4(0.0, xyzw.yzw);
  vec3 start = getPosition(xyzwS, 0.0);

  // Sample middle of line strip
  vec4 xyzwM = vec4(geometryClip.x / 2.0, xyzw.yzw);
  vec3 middle = getPosition(xyzwM, 0.0);

#ifdef LINE_CLOSED
  vec3 end = start;
#else
  // Sample other end of line strip
  vec4 xyzwE = vec4(geometryClip.x, xyzw.yzw);
  vec3 end   = getPosition(xyzwE, 0.0);
#endif

  // Measure length
  float l = max(length(end - middle), length(middle - start)) * clipSpace * 2.0;

  // Arrow length (=2.5x radius)
  float arrowSize = 1.25 * clipRange * lineWidth * worldUnit;

#ifdef LINE_CLOSED
  // Clip around start/end
  end = start;
#endif

  vClipEnds = vec2(1.0);

  if (clipStyle.y > 0.0) {
    // Depth blend end
    float depth = focusDepth;
    if (lineDepth < 1.0) {
      float z = max(0.00001, -end.z);
      depth = mix(z, focusDepth, lineDepth);
    }

    // Absolute arrow length
    float size = arrowSize * depth;

    // Adjust clip range
    // Approach linear scaling with cubic ease the smaller we get
    float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);
    float scale = 1.0 - mini * mini * mini;
    float invrange = 1.0 / (size * scale);

    // Clip end
    vec3 diff = end - center;
    if(diff == vec3(0.0))
      vClipEnds.x = -1.0;
    else {
      diff = normalize(end - center);
      float d = dot(end - pos, diff);
      vClipEnds.x = d * invrange - 1.0;
    }
  }

  if (clipStyle.x > 0.0) {
    // Depth blend start
    float depth = focusDepth;
    if (lineDepth < 1.0) {
      float z = max(0.00001, -start.z);
      depth = mix(z, focusDepth, lineDepth);
    }

    // Absolute arrow length
    float size = arrowSize * depth;

    // Adjust clip range
    // Approach linear scaling with cubic ease the smaller we get
    float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);
    float scale = 1.0 - mini * mini * mini;
    float invrange = 1.0 / (size * scale);

    // Clip start
    vec3 diff = center - start;
    if(diff == vec3(0.0))
      vClipEnds.y = -1.0;
    else {
      diff = normalize(center - start);
      float d = dot(pos - start, diff);
      vClipEnds.y = d * invrange - 1.0;
    }
  }
}
#endif

// Adjust left/center/right to be inside near/far z range
const float epsilon = 1e-5;
void fixCenter(inout vec3 left, inout vec3 center, inout vec3 right) {
  if (center.z >= 0.0) {
    if (left.z < 0.0) {
      float d = (center.z + epsilon) / (center.z - left.z);
      center = mix(center, left, d);
    }
    else if (right.z < 0.0) {
      float d = (center.z + epsilon) / (center.z - right.z);
      center = mix(center, right, d);
    }
  }

  if (left.z >= 0.0) {
    if (center.z < 0.0) {
      float d = (left.z + epsilon) / (left.z - center.z);
      left = mix(left, center, d);
    }
  }

  if (right.z >= 0.0) {
    if (center.z < 0.0) {
      float d = (right.z + epsilon) / (right.z - center.z);
      right = mix(right, center, d);
    }
  }
}

vec4 wrapAround(vec4 xyzw) {
#ifdef LINE_CLOSED
  float gx = geometryClip.x;
  if (xyzw.x < 0.0) xyzw.x += gx;
  if (xyzw.x >= gx) xyzw.x -= gx;
#endif
  return xyzw;
}

// Sample the source data in an edge-aware manner
void getLineGeometry(vec4 xyzw, float edge, out vec3 left, out vec3 center, out vec3 right) {
  vec4 delta = vec4(1.0, 0.0, 0.0, 0.0);

  center = getPosition(xyzw, 1.0);
  left   = (edge > -0.5) ? getPosition(wrapAround(xyzw - delta), 0.0) : center;
  right  = (edge < 0.5)  ? getPosition(wrapAround(xyzw + delta), 0.0) : center;
}

// Calculate the position for a vertex along the line, including joins
vec3 getLineJoin(float edge, bool odd, vec3 left, vec3 center, vec3 right, float width, float offset, float joint) {
  vec2 join = vec2(1.0, 0.0);

  fixCenter(left, center, right);

  vec4 a = vec4(left.xy, right.xy);
  vec4 b = a / vec4(left.zz, right.zz);

  vec2 l = b.xy;
  vec2 r = b.zw;
  vec2 c = center.xy / center.z;

  vec4 d = vec4(l, c) - vec4(c, r);
  float l1 = dot(d.xy, d.xy);
  float l2 = dot(d.zw, d.zw);

  if (l1 + l2 > 0.0) {

    if (edge > 0.5 || l2 == 0.0) {
      vec2 nl = normalize(d.xy);
      vec2 tl = vec2(nl.y, -nl.x);

#ifdef LINE_PROXIMITY
      vClipProximity = 1.0;
#endif

#ifdef LINE_STROKE
      vClipStrokeEven = vClipStrokeOdd = normalize(left - center);
#endif
      join = tl;
    }
    else if (edge < -0.5 || l1 == 0.0) {
      vec2 nr = normalize(d.zw);
      vec2 tr = vec2(nr.y, -nr.x);

#ifdef LINE_PROXIMITY
      vClipProximity = 1.0;
#endif

#ifdef LINE_STROKE
      vClipStrokeEven = vClipStrokeOdd = normalize(center - right);
#endif
      join = tr;
    }
    else {
      // Limit join stretch for tiny segments
      float lmin2 = min(l1, l2) / (width * width);

      // Hide line segment if ratio of leg lengths exceeds promixity threshold
#ifdef LINE_PROXIMITY
      float lr     = l1 / l2;
      float rl     = l2 / l1;
      float ratio  = max(lr, rl);
      float thresh = lineProximity + 1.0;
      vClipProximity = (ratio > thresh * thresh) ? 1.0 : 0.0;
#endif

      // Calculate normals/tangents
      vec2 nl = normalize(d.xy);
      vec2 nr = normalize(d.zw);

      // Calculate tangents
      vec2 tl = vec2(nl.y, -nl.x);
      vec2 tr = vec2(nr.y, -nr.x);

#ifdef LINE_PROXIMITY
      // Mix tangents according to leg lengths
      vec2 tc = normalize(mix(tl, tr, l1/(l1+l2)));
#else
      // Average tangent
      vec2 tc = normalize(tl + tr);
#endif

      // Miter join
      float cosA   = dot(nl, tc);
      float sinA   = max(0.1, abs(dot(tl, tc)));
      float factor = cosA / sinA;
      float scale  = sqrt(1.0 + min(lmin2, factor * factor));

      // Stroke normals
#ifdef LINE_STROKE
      vec3 stroke1 = normalize(left - center);
      vec3 stroke2 = normalize(center - right);

      if (odd) {
        vClipStrokeEven = stroke1;
        vClipStrokeOdd  = stroke2;
      }
      else {
        vClipStrokeEven = stroke2;
        vClipStrokeOdd  = stroke1;
      }
#endif

#ifdef LINE_JOIN_MITER
      // Apply straight up miter
      join = tc * scale;
#endif

#ifdef LINE_JOIN_ROUND
      // Slerp bevel join into circular arc
      float dotProduct = dot(nl, nr);
      float angle = acos(dotProduct);
      float sinT  = sin(angle);
      join = (sin((1.0 - joint) * angle) * tl + sin(joint * angle) * tr) / sinT;
#endif

#ifdef LINE_JOIN_BEVEL
      // Direct bevel join between two flat ends
      float dotProduct = dot(nl, nr);
      join = mix(tl, tr, joint);
#endif

#ifdef LINE_JOIN_DETAIL
      // Check if on inside or outside of joint
      float crossProduct = nl.x * nr.y - nl.y * nr.x;
      if (offset * crossProduct < 0.0) {
        // For near-180-degree bends, correct back to a miter to avoid discontinuities
        float ratio = clamp(-dotProduct * 2.0 - 1.0, 0.0, 1.0);
        // Otherwise collapse the inside vertices into one.
        join = mix(tc * scale, join, ratio * ratio * ratio);
      }
#endif

    }
    return vec3(join, 0.0);
  }
  else {
    return vec3(0.0);
  }

}

// Calculate final line position
vec3 getLinePosition() {
  vec3 left, center, right, join;

  // Up/down along segment
  float offset = line;

  // Clip data
  vec4 p = min(geometryClip, position4);

  // Left/center/right
  float edge = 0.0;
#ifdef LINE_CLOSED
  if (p.x == geometryClip.x) p.x = 0.0;
#else
  if (p.x == geometryClip.x) edge = 1.0;
  if (p.x == 0.0) edge = -1.0;
#endif

  // Get position + adjacent neighbours
  getLineGeometry(p, edge, left, center, right);

#ifdef LINE_STROKE
  // Set parameters for line stroke fragment shader
  vClipStrokePosition = center;
  vClipStrokeIndex = p.x;
  bool odd = mod(p.x, 2.0) >= 1.0;
#else
  bool odd = true;
#endif

  // Divide line width up/down
  float width = lineWidth * 0.5;

  float depth = focusDepth;
  if (lineDepth < 1.0) {
    // Depth blending
    float z = max(0.00001, -center.z);
    depth = mix(z, focusDepth, lineDepth);
  }
  width *= depth;

  // Convert to world units
  width *= worldUnit;

  // Calculate line join
#ifdef LINE_CLOSED
  join = getLineJoin(0.0, odd, left, center, right, width, offset, joint);
#else
  join = getLineJoin(edge, odd, left, center, right, width, offset, joint);
#endif
  vec3 pos = center + join * offset * width;

#ifdef LINE_STROKE
  vClipStrokeWidth = width;
#endif

#ifdef LINE_CLIP
  clipEnds(p, center, pos);
#endif

  return pos;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/map.2d.data.js
/* harmony default export */ const map_2d_data = (/* glsl */`uniform vec2 dataResolution;
uniform vec2 dataPointer;

vec2 map2DData(vec2 xy) {
  return (xy + dataPointer) * dataResolution;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/map.2d.data.wrap.js
/* harmony default export */ const map_2d_data_wrap = (/* glsl */`uniform vec2 dataResolution;
uniform vec2 dataPointer;

vec2 map2DData(vec2 xy) {
  return fract((xy + dataPointer) * dataResolution);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/map.xyzw.2dv.js
/* harmony default export */ const map_xyzw_2dv = (/* glsl */`void mapXyzw2DV(vec4 xyzw, out vec2 xy, out float z) {
  xy = xyzw.xy;
  z  = xyzw.z;
}

`);

;// CONCATENATED MODULE: ./src/shaders/glsl/map.xyzw.align.js
/* harmony default export */ const map_xyzw_align = (/* glsl */`vec4 alignXYZW(vec4 xyzw) {
  return floor(xyzw + .5);
}

`);

;// CONCATENATED MODULE: ./src/shaders/glsl/map.xyzw.texture.js
/* harmony default export */ const map_xyzw_texture = (/* glsl */`uniform float textureItems;
uniform float textureHeight;

vec2 mapXyzwTexture(vec4 xyzw) {
  
  float x = xyzw.x;
  float y = xyzw.y;
  float z = xyzw.z;
  float i = xyzw.w;
  
  return vec2(i, y) + vec2(x, z) * vec2(textureItems, textureHeight);
}

`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.fragment.color.js
/* harmony default export */ const mesh_fragment_color = (/* glsl */`varying vec4 vColor;

vec4 getColor() {
  if (vColor.a <= 0.0) discard;
  return vColor;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.fragment.map.js
/* harmony default export */ const mesh_fragment_map = (/* glsl */`#ifdef POSITION_STPQ
varying vec4 vSTPQ;
#endif
#ifdef POSITION_U
varying float vU;
#endif
#ifdef POSITION_UV
varying vec2 vUV;
#endif
#ifdef POSITION_UVW
varying vec3 vUVW;
#endif
#ifdef POSITION_UVWO
varying vec4 vUVWO;
#endif

vec4 getSample(vec4 uvwo, vec4 stpq);

vec4 getMapColor() {
  #ifdef POSITION_STPQ
  vec4 stpq = vSTPQ;
  #else
  vec4 stpq = vec4(0.0);
  #endif

  #ifdef POSITION_U
  vec4 uvwo = vec4(vU, 0.0, 0.0, 0.0);
  #endif
  #ifdef POSITION_UV
  vec4 uvwo = vec4(vUV, 0.0, 0.0);
  #endif
  #ifdef POSITION_UVW
  vec4 uvwo = vec4(vUVW, 0.0);
  #endif
  #ifdef POSITION_UVWO
  vec4 uvwo = vec4(vUVWO);
  #endif

  return getSample(uvwo, stpq);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.fragment.mask.js
/* harmony default export */ const mesh_fragment_mask = (/* glsl */`varying float vMask;

float ease(float t) {
  t = clamp(t, 0.0, 1.0);
  return t * t * (3.0 - 2.0 * t);
}

vec4 maskColor() {
  if (vMask <= 0.0) discard;
  return vec4(vec3(1.0), ease(vMask));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.fragment.material.js
/* harmony default export */ const mesh_fragment_material = (/* glsl */`#ifdef POSITION_STPQ
varying vec4 vSTPQ;
#endif
#ifdef POSITION_U
varying float vU;
#endif
#ifdef POSITION_UV
varying vec2 vUV;
#endif
#ifdef POSITION_UVW
varying vec3 vUVW;
#endif
#ifdef POSITION_UVWO
varying vec4 vUVWO;
#endif

vec4 getSample(vec4 rgba, vec4 stpq);

vec4 getMaterialColor(vec4 rgba) {
  vec4 stpq = vec4(0.0);

  #ifdef POSITION_U
  stpq.x = vU;
  #endif
  #ifdef POSITION_UV
  stpq.xy = vUV;
  #endif
  #ifdef POSITION_UVW
  stpq.xyz = vUVW;
  #endif
  #ifdef POSITION_UVWO
  stpq = vUVWO;
  #endif

  #ifdef POSITION_STPQ
  stpq = vSTPQ;
  #endif

  return getSample(rgba, stpq);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.fragment.shaded.js
/* harmony default export */ const mesh_fragment_shaded = (/* glsl */`
#extension GL_OES_standard_derivatives : enable
varying vec3 vNormal;
varying vec3 vLight;
varying vec3 vPosition;

vec3 offSpecular(vec3 color) {
  vec3 c = 1.0 - color;
  return 1.0 - c * c;
}

vec4 getShadedColor(vec4 rgba) {
  
  vec3 color = rgba.xyz;
  vec3 color2 = offSpecular(rgba.xyz);

  vec3 normal = normalize(vNormal);
  vec3 light = normalize(vLight);
  vec3 position = normalize(vPosition);
  
  // Workaround to avoid gl_FrontFacing. See https://github.com/unconed/mathbox/pull/26
  vec3 pdx = dFdx(vPosition);
  vec3 pdy = dFdy(vPosition);
  bool frontFacting = dot(vNormal, cross(pdx, pdy)) > 0.0;

  float side = frontFacting ? 1.0 : -1.0;
  float cosine  = side * dot(normal, light);
  float diffuse = mix(max(0.0, cosine), .5 + .5 * cosine, .1);
  
  vec3  halfLight = normalize(light + position);
	float cosineHalf = max(0.0, side * dot(normal, halfLight));
	float specular = pow(cosineHalf, 16.0);
	
	return vec4(color * (diffuse * .9 + .05) + .25 * color2 * specular, rgba.a);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.fragment.texture.js
/* harmony default export */ const mesh_fragment_texture = (/* glsl */``);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.gamma.in.js
/* harmony default export */ const mesh_gamma_in = (/* glsl */`vec4 getGammaInColor(vec4 rgba) {
  return vec4(rgba.rgb * rgba.rgb, rgba.a);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.gamma.out.js
/* harmony default export */ const mesh_gamma_out = (/* glsl */`vec4 getGammaOutColor(vec4 rgba) {
  return vec4(sqrt(rgba.rgb), rgba.a);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.map.uvwo.js
/* harmony default export */ const mesh_map_uvwo = (/* glsl */`vec4 mapUVWO(vec4 uvwo, vec4 stpq) {
  return uvwo;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.position.js
/* harmony default export */ const mesh_position = (/* glsl */`uniform vec4 geometryClip;
attribute vec4 position4;

// External
vec3 getPosition(vec4 xyzw, float canonical);

vec3 getMeshPosition() {
  vec4 p = min(geometryClip, position4);
  return getPosition(p, 1.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.vertex.color.js
/* harmony default export */ const mesh_vertex_color = (/* glsl */`attribute vec4 position4;
uniform vec4 geometryClip;
varying vec4 vColor;

// External
vec4 getSample(vec4 xyzw);

void vertexColor() {
  vec4 p = min(geometryClip, position4);
  vColor = getSample(p);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.vertex.mask.js
/* harmony default export */ const mesh_vertex_mask = (/* glsl */`attribute vec4 position4;
uniform vec4 geometryResolution;
uniform vec4 geometryClip;
varying float vMask;

// External
float getSample(vec4 xyzw);

void maskLevel() {
  vec4 p = min(geometryClip, position4);
  vMask = getSample(p * geometryResolution);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/mesh.vertex.position.js
/* harmony default export */ const mesh_vertex_position = (/* glsl */`uniform vec4 geometryResolution;

#ifdef POSITION_STPQ
varying vec4 vSTPQ;
#endif
#ifdef POSITION_U
varying float vU;
#endif
#ifdef POSITION_UV
varying vec2 vUV;
#endif
#ifdef POSITION_UVW
varying vec3 vUVW;
#endif
#ifdef POSITION_UVWO
varying vec4 vUVWO;
#endif

// External
vec3 getPosition(vec4 xyzw, in vec4 stpqIn, out vec4 stpqOut);

vec3 getMeshPosition(vec4 xyzw, float canonical) {
  vec4 stpqOut, stpqIn = xyzw * geometryResolution;
  vec3 xyz = getPosition(xyzw, stpqIn, stpqOut);

  #ifdef POSITION_MAP
  if (canonical > 0.5) {
    #ifdef POSITION_STPQ
    vSTPQ = stpqOut;
    #endif
    #ifdef POSITION_U
    vU = stpqOut.x;
    #endif
    #ifdef POSITION_UV
    vUV = stpqOut.xy;
    #endif
    #ifdef POSITION_UVW
    vUVW = stpqOut.xyz;
    #endif
    #ifdef POSITION_UVWO
    vUVWO = stpqOut;
    #endif
  }
  #endif
  return xyz;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/move.position.js
/* harmony default export */ const move_position = (/* glsl */`uniform float transitionEnter;
uniform float transitionExit;
uniform vec4  transitionScale;
uniform vec4  transitionBias;
uniform float transitionSkew;
uniform float transitionActive;

uniform vec4  moveFrom;
uniform vec4  moveTo;

float ease(float t) {
  t = clamp(t, 0.0, 1.0);
  return 1.0 - (2.0 - t) * t;
}

vec4 getTransitionPosition(vec4 xyzw, inout vec4 stpq) {
  if (transitionActive < 0.5) return xyzw;

  float enter   = transitionEnter;
  float exit    = transitionExit;
  float skew    = transitionSkew;
  vec4  scale   = transitionScale;
  vec4  bias    = transitionBias;

  float factor  = 1.0 + skew;
  float offset  = dot(vec4(1.0), stpq * scale + bias);

  float a1 = ease(enter * factor - offset);
  float a2 = ease(exit  * factor + offset - skew);

  return xyzw + a1 * moveFrom + a2 * moveTo;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/object.mask.default.js
/* harmony default export */ const object_mask_default = (/* glsl */`vec4 getMask(vec4 xyzw) {
  return vec4(1.0);
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.alpha.circle.js
/* harmony default export */ const point_alpha_circle = (/* glsl */`varying float vPixelSize;

float getDiscAlpha(float mask) {
  // Approximation: 1 - x*x is approximately linear around x = 1 with slope 2
  return vPixelSize * (1.0 - mask);
  //  return vPixelSize * 2.0 * (1.0 - sqrt(mask));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.alpha.circle.hollow.js
/* harmony default export */ const point_alpha_circle_hollow = (/* glsl */`varying float vPixelSize;

float getDiscHollowAlpha(float mask) {
  return vPixelSize * (0.5 - 2.0 * abs(sqrt(mask) - .75));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.alpha.generic.js
/* harmony default export */ const point_alpha_generic = (/* glsl */`varying float vPixelSize;

float getGenericAlpha(float mask) {
  return vPixelSize * 2.0 * (1.0 - mask);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.alpha.generic.hollow.js
/* harmony default export */ const point_alpha_generic_hollow = (/* glsl */`varying float vPixelSize;

float getGenericHollowAlpha(float mask) {
  return vPixelSize * (0.5 - 2.0 * abs(mask - .75));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.edge.js
/* harmony default export */ const point_edge = (/* glsl */`varying vec2 vSprite;

float getSpriteMask(vec2 xy);
float getSpriteAlpha(float mask);

void setFragmentColorFill(vec4 color) {
  float mask = getSpriteMask(vSprite);
  if (mask > 1.0) {
    discard;
  }
  float alpha = getSpriteAlpha(mask);
  if (alpha >= 1.0) {
    discard;
  }
  gl_FragColor = vec4(color.rgb, alpha * color.a);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.fill.js
/* harmony default export */ const point_fill = (/* glsl */`varying vec2 vSprite;

float getSpriteMask(vec2 xy);
float getSpriteAlpha(float mask);

void setFragmentColorFill(vec4 color) {
  float mask = getSpriteMask(vSprite);
  if (mask > 1.0) {
    discard;
  }
  float alpha = getSpriteAlpha(mask);
  if (alpha < 1.0) {
    discard;
  }
  gl_FragColor = color;
}

`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.mask.circle.js
/* harmony default export */ const point_mask_circle = (/* glsl */`varying float vPixelSize;

float getCircleMask(vec2 uv) {
  return dot(uv, uv);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.mask.diamond.js
/* harmony default export */ const point_mask_diamond = (/* glsl */`varying float vPixelSize;

float getDiamondMask(vec2 uv) {
  vec2 a = abs(uv);
  return a.x + a.y;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.mask.down.js
/* harmony default export */ const point_mask_down = (/* glsl */`varying float vPixelSize;

float getTriangleDownMask(vec2 uv) {
  uv.y += .25;
  return max(uv.y, abs(uv.x) * .866 - uv.y * .5 + .6);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.mask.left.js
/* harmony default export */ const point_mask_left = (/* glsl */`varying float vPixelSize;

float getTriangleLeftMask(vec2 uv) {
  uv.x += .25;
  return max(uv.x, abs(uv.y) * .866 - uv.x * .5 + .6);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.mask.right.js
/* harmony default export */ const point_mask_right = (/* glsl */`varying float vPixelSize;

float getTriangleRightMask(vec2 uv) {
  uv.x -= .25;
  return max(-uv.x, abs(uv.y) * .866 + uv.x * .5 + .6);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.mask.square.js
/* harmony default export */ const point_mask_square = (/* glsl */`varying float vPixelSize;

float getSquareMask(vec2 uv) {
  vec2 a = abs(uv);
  return max(a.x, a.y);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.mask.up.js
/* harmony default export */ const point_mask_up = (/* glsl */`varying float vPixelSize;

float getTriangleUpMask(vec2 uv) {
  uv.y -= .25;
  return max(-uv.y, abs(uv.x) * .866 + uv.y * .5 + .6);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.position.js
/* harmony default export */ const point_position = (/* glsl */`uniform float pointDepth;

uniform float pixelUnit;
uniform float renderScale;
uniform float renderScaleInv;
uniform float focusDepth;

uniform vec4 geometryClip;
attribute vec4 position4;
attribute vec2 sprite;

varying vec2 vSprite;
varying float vPixelSize;

const float pointScale = POINT_SHAPE_SCALE;

// External
float getPointSize(vec4 xyzw);
vec3 getPosition(vec4 xyzw, float canonical);

vec3 getPointPosition() {
  // Discard out-of-range points by generating degenerate face
  if (
    position4.x > geometryClip.x ||
    position4.y > geometryClip.y ||
    position4.z > geometryClip.z ||
    position4.w > geometryClip.w
  ) return vec3(0.0, 0.0, 0.0);
  vec4 p = position4;

  vec3 center = getPosition(p, 1.0);

  // Depth blending
  // TODO: orthographic camera
  // Workaround: set depth = 0
  float z = -center.z;
  float depth = mix(z, focusDepth, pointDepth);

  // Match device/unit mapping
  // Sprite goes from -1..1, width = 2.
  float pointSize = getPointSize(p);
  float size = pointScale * pointSize * pixelUnit * .5;
  float depthSize = depth * size;

  // Pad sprite by half a pixel to make the anti-aliasing straddle the pixel edge
  // Note: pixelsize measures radius
  float pixelSize = .5 * (pointDepth > 0.0 ? depthSize / z : size);
  float paddedSize = pixelSize + 0.5;
  float padFactor = paddedSize / pixelSize;

  vPixelSize = paddedSize;
  vSprite    = sprite;

  return center + vec3(sprite * depthSize * renderScaleInv * padFactor, 0.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.size.uniform.js
/* harmony default export */ const point_size_uniform = (/* glsl */`uniform float pointSize;

float getPointSize(vec4 xyzw) {
  return pointSize;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/point.size.varying.js
/* harmony default export */ const point_size_varying = (/* glsl */`uniform float pointSize;

vec4 getSample(vec4 xyzw);

float getPointSize(vec4 xyzw) {
  return pointSize * getSample(xyzw).x;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/polar.position.js
/* harmony default export */ const polar_position = (/* glsl */`uniform float polarBend;
uniform float polarFocus;
uniform float polarAspect;
uniform float polarHelix;

uniform mat4 viewMatrix;

vec4 getPolarPosition(vec4 position, inout vec4 stpq) {
  if (polarBend > 0.0) {

    if (polarBend < 0.001) {
      // Factor out large addition/subtraction of polarFocus
      // to avoid numerical error
      // sin(x) ~ x
      // cos(x) ~ 1 - x * x / 2
      vec2 pb = position.xy * polarBend;
      float ppbbx = pb.x * pb.x;
      return viewMatrix * vec4(
        position.x * (1.0 - polarBend + (pb.y * polarAspect)),
        position.y * (1.0 - .5 * ppbbx) - (.5 * ppbbx) * polarFocus / polarAspect,
        position.z + position.x * polarHelix * polarBend,
        1.0
      );
    }
    else {
      vec2 xy = position.xy * vec2(polarBend, polarAspect);
      float radius = polarFocus + xy.y;
      return viewMatrix * vec4(
        sin(xy.x) * radius,
        (cos(xy.x) * radius - polarFocus) / polarAspect,
        position.z + position.x * polarHelix * polarBend,
        1.0
      );
    }
  }
  else {
    return viewMatrix * vec4(position.xyz, 1.0);
  }
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/project.position.js
/* harmony default export */ const project_position = (/* glsl */`uniform float styleZBias;
uniform float styleZIndex;

void setPosition(vec3 position) {

  #ifdef PROJECT_ORTHOGONAL
  // Orthogonal projection with depth preservation around z = 1
  vec4 pos = projectionMatrix * vec4(position, 1.0);
  pos.xy *= -position.z;
  #else
  // Normal perspective projection
  vec4 pos = projectionMatrix * vec4(position, 1.0);
  #endif

  // Apply relative Z bias
  float bias  = (1.0 - styleZBias / 32768.0);
  pos.z *= bias;

  // Apply large scale Z index changes
  if (styleZIndex > 0.0) {
    float z = pos.z / pos.w;
    pos.z = ((z + 1.0) / (styleZIndex + 1.0) - 1.0) * pos.w;
  }

  gl_Position = pos;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/project.readback.js
/* harmony default export */ const project_readback = (/* glsl */`// This is three.js' global uniform, missing from fragment shaders.
uniform mat4 projectionMatrix;

vec4 readbackPosition(vec3 position, vec4 stpq) {
  vec4 pos = projectionMatrix * vec4(position, 1.0);
  vec3 final = pos.xyz / pos.w;
  if (final.z < -1.0) {
    return vec4(0.0, 0.0, 0.0, -1.0);
  }
  else {
    return vec4(final, -position.z);
  }
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/raw.position.scale.js
/* harmony default export */ const raw_position_scale = (/* glsl */`uniform vec4 geometryScale;
attribute vec4 position4;

vec4 getRawPositionScale() {
  return geometryScale * position4;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/repeat.position.js
/* harmony default export */ const repeat_position = (/* glsl */`uniform vec4 repeatModulus;

vec4 getRepeatXYZW(vec4 xyzw) {
  return mod(xyzw + .5, repeatModulus) - .5;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/resample.padding.js
/* harmony default export */ const resample_padding = (/* glsl */`uniform vec4 resampleBias;

vec4 resamplePadding(vec4 xyzw) {
  return xyzw + resampleBias;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/resample.relative.js
/* harmony default export */ const resample_relative = (/* glsl */`uniform vec4 resampleFactor;

vec4 resampleRelative(vec4 xyzw) {
  return xyzw * resampleFactor;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/reveal.mask.js
/* harmony default export */ const reveal_mask = (/* glsl */`uniform float transitionEnter;
uniform float transitionExit;
uniform vec4  transitionScale;
uniform vec4  transitionBias;
uniform float transitionSkew;
uniform float transitionActive;

float getTransitionSDFMask(vec4 stpq) {
  if (transitionActive < 0.5) return 1.0;

  float enter   = transitionEnter;
  float exit    = transitionExit;
  float skew    = transitionSkew;
  vec4  scale   = transitionScale;
  vec4  bias    = transitionBias;

  float factor  = 1.0 + skew;
  float offset  = dot(vec4(1.0), stpq * scale + bias);

  vec2 d = vec2(enter, exit) * factor + vec2(-offset, offset - skew);
  if (exit  == 1.0) return d.x;
  if (enter == 1.0) return d.y;
  return min(d.x, d.y);
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/reverse.position.js
/* harmony default export */ const reverse_position = (/* glsl */`uniform vec4 reverseScale;
uniform vec4 reverseOffset;

vec4 getReverseOffset(vec4 xyzw) {
  return xyzw * reverseScale + reverseOffset;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/root.position.js
/* harmony default export */ const root_position = (/* glsl */`vec3 getRootPosition(vec4 position, in vec4 stpqIn, out vec4 stpqOut) {
  stpqOut = stpqIn; // avoid inout confusion
  return position.xyz;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/sample.2d.js
/* harmony default export */ const sample_2d = (/* glsl */`uniform sampler2D dataTexture;

vec4 sample2D(vec2 uv) {
  return texture2D(dataTexture, uv);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/scale.position.js
/* harmony default export */ const scale_position = (/* glsl */`uniform vec4 scaleAxis;
uniform vec4 scaleOffset;

vec4 sampleData(float x);

vec4 getScalePosition(vec4 xyzw) {
  return scaleAxis * sampleData(xyzw.x).x + scaleOffset;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/screen.map.stpq.js
/* harmony default export */ const screen_map_stpq = (/* glsl */`uniform vec4 remapSTPQScale;

vec4 screenMapSTPQ(vec4 xyzw, out vec4 stpq) {
  stpq = xyzw * remapSTPQScale;
  return xyzw;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/screen.map.xy.js
/* harmony default export */ const screen_map_xy = (/* glsl */`uniform vec2 remapUVScale;

vec4 screenMapXY(vec4 uvwo, vec4 stpq) {
  return vec4(floor(remapUVScale * uvwo.xy), 0.0, 0.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/screen.map.xyzw.js
/* harmony default export */ const screen_map_xyzw = (/* glsl */`uniform vec2 remapUVScale;
uniform vec2 remapModulus;
uniform vec2 remapModulusInv;

vec4 screenMapXYZW(vec4 uvwo, vec4 stpq) {
  vec2 st = floor(remapUVScale * uvwo.xy);
  vec2 xy = st * remapModulusInv;
  vec2 ixy = floor(xy);
  vec2 fxy = xy - ixy;
  vec2 zw = fxy * remapModulus;
  return vec4(ixy.x, zw.y, ixy.y, zw.x);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/screen.pass.uv.js
/* harmony default export */ const screen_pass_uv = (/* glsl */`vec2 screenPassUV(vec4 uvwo, vec4 stpq) {
  return uvwo.xy;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/screen.position.js
/* harmony default export */ const screen_position = (/* glsl */`void setScreenPosition(vec4 position) {
  gl_Position = vec4(position.xy * 2.0 - 1.0, 0.5, 1.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/slice.position.js
/* harmony default export */ const slice_position = (/* glsl */`uniform vec4 sliceOffset;

vec4 getSliceOffset(vec4 xyzw) {
  return xyzw + sliceOffset;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/spherical.position.js
/* harmony default export */ const spherical_position = (/* glsl */`uniform float sphericalBend;
uniform float sphericalFocus;
uniform float sphericalAspectX;
uniform float sphericalAspectY;
uniform float sphericalScaleY;

uniform mat4 viewMatrix;

vec4 getSphericalPosition(vec4 position, inout vec4 stpq) {
  if (sphericalBend > 0.0001) {

    vec3 xyz = position.xyz * vec3(sphericalBend, sphericalBend / sphericalAspectY * sphericalScaleY, sphericalAspectX);
    float radius = sphericalFocus + xyz.z;
    float cosine = cos(xyz.y) * radius;

    return viewMatrix * vec4(
      sin(xyz.x) * cosine,
      sin(xyz.y) * radius * sphericalAspectY,
      (cos(xyz.x) * cosine - sphericalFocus) / sphericalAspectX,
      1.0
    );
  }
  else {
    return viewMatrix * vec4(position.xyz, 1.0);
  }
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/split.position.js
/* harmony default export */ const split_position = (/* glsl */`uniform float splitStride;

vec2 getIndices(vec4 xyzw);
vec4 getRest(vec4 xyzw);
vec4 injectIndex(float v);

vec4 getSplitXYZW(vec4 xyzw) {
  vec2 uv = getIndices(xyzw);
  float offset = uv.x + uv.y * splitStride;
  return injectIndex(offset) + getRest(xyzw);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/spread.position.js
/* harmony default export */ const spread_position = (/* glsl */`uniform vec4 spreadOffset;
uniform mat4 spreadMatrix;

// External
vec4 getSample(vec4 xyzw);

vec4 getSpreadSample(vec4 xyzw) {
  vec4 sample = getSample(xyzw);
  return sample + spreadMatrix * (spreadOffset + xyzw);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/sprite.fragment.js
/* harmony default export */ const sprite_fragment = (/* glsl */`varying vec2 vSprite;

vec4 getSample(vec2 xy);

vec4 getSpriteColor() {
  return getSample(vSprite);
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/sprite.position.js
/* harmony default export */ const sprite_position = (/* glsl */`uniform vec2 spriteOffset;
uniform float spriteScale;
uniform float spriteDepth;
uniform float spriteSnap;

uniform vec2 renderOdd;
uniform float renderScale;
uniform float renderScaleInv;
uniform float pixelUnit;
uniform float focusDepth;

uniform vec4 geometryClip;
attribute vec4 position4;
attribute vec2 sprite;

varying float vPixelSize;

// External
vec3 getPosition(vec4 xyzw, float canonical);
vec4 getSprite(vec4 xyzw);

vec3 getSpritePosition() {
  // Clip points
  vec4 p = min(geometryClip, position4);
  float diff = length(position4 - p);
  if (diff > 0.0) {
    return vec3(0.0, 0.0, 1000.0);
  }

  // Make sprites
  vec3 center = getPosition(p, 1.0);
  vec4 atlas = getSprite(p);

  // Sprite goes from -1..1, width = 2.
  // -1..1 -> -0.5..0.5
  vec2 halfSprite = sprite * .5;
  vec2 halfFlipSprite = vec2(halfSprite.x, -halfSprite.y);

#ifdef POSITION_UV
  // Assign UVs
  vUV = atlas.xy + atlas.zw * (halfFlipSprite + .5);
#endif

  // Depth blending
  // TODO: orthographic camera
  // Workaround: set depth = 0
  float depth = focusDepth, z;
  z = -center.z;
  if (spriteDepth < 1.0) {
    depth = mix(z, focusDepth, spriteDepth);
  }
  
  // Match device/unit mapping 
  float size = pixelUnit * spriteScale;
  float depthSize = depth * size;

  // Calculate pixelSize for anti-aliasing
  float pixelSize = (spriteDepth > 0.0 ? depthSize / z : size);
  vPixelSize = pixelSize;

  // Position sprite
  vec2 atlasOdd = fract(atlas.zw / 2.0);
  vec2 offset = (spriteOffset + halfSprite * atlas.zw) * depthSize;
  if (spriteSnap > 0.5) {
    // Snap to pixel (w/ epsilon shift to avoid jitter)
    return vec3(((floor(center.xy / center.z * renderScale + 0.001) + renderOdd + atlasOdd) * center.z + offset) * renderScaleInv, center.z);
  }
  else {
    // Place directly
    return center + vec3(offset * renderScaleInv, 0.0);
  }

}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/stereographic4.position.js
/* harmony default export */ const stereographic4_position = (/* glsl */`uniform float stereoBend;
uniform vec4 basisScale;
uniform vec4 basisOffset;
uniform mat4 viewMatrix;
uniform vec2 view4D;

vec4 getStereographic4Position(vec4 position, inout vec4 stpq) {
  
  vec4 transformed;
  if (stereoBend > 0.0001) {

    float r = length(position);
    float w = r + position.w;
    vec4 project = vec4(position.xyz / w, r);
    
    transformed = mix(position, project, stereoBend);
  }
  else {
    transformed = position;
  }

  vec4 pos4 = transformed * basisScale - basisOffset;
  vec3 xyz = (viewMatrix * vec4(pos4.xyz, 1.0)).xyz;
  return vec4(xyz, pos4.w * view4D.y + view4D.x);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/stereographic.position.js
/* harmony default export */ const stereographic_position = (/* glsl */`uniform float stereoBend;

uniform mat4 viewMatrix;

vec4 getStereoPosition(vec4 position, inout vec4 stpq) {
  if (stereoBend > 0.0001) {

    vec3 pos = position.xyz;
    float r = length(pos);
    float z = r + pos.z;
    vec3 project = vec3(pos.xy / z, r);
    
    vec3 lerped = mix(pos, project, stereoBend);

    return viewMatrix * vec4(lerped, 1.0);
  }
  else {
    return viewMatrix * vec4(position.xyz, 1.0);
  }
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/stpq.sample.2d.js
/* harmony default export */ const stpq_sample_2d = (/* glsl */`varying vec2 vST;

vec4 getSample(vec2 st);

vec4 getSTSample() {
  return getSample(vST);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/stpq.xyzw.2d.js
/* harmony default export */ const stpq_xyzw_2d = (/* glsl */`varying vec2 vUV;

void setRawUV(vec4 xyzw) {
  vUV = xyzw.xy;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/strip.position.normal.js
/* harmony default export */ const strip_position_normal = (/* glsl */`uniform vec4 geometryClip;
attribute vec4 position4;
attribute vec3 strip;

// External
vec3 getPosition(vec4 xyzw, float canonical);

varying vec3 vNormal;
varying vec3 vLight;
varying vec3 vPosition;

void getStripGeometry(vec4 xyzw, vec3 strip, out vec3 pos, out vec3 normal) {
  vec3 a, b, c;

  a   = getPosition(xyzw, 1.0);
  b   = getPosition(vec4(xyzw.xyz, strip.x), 0.0);
  c   = getPosition(vec4(xyzw.xyz, strip.y), 0.0);

  normal = normalize(cross(c - a, b - a)) * strip.z;
  
  pos = a;
}

vec3 getStripPositionNormal() {
  vec3 center, normal;

  vec4 p = min(geometryClip, position4);

  getStripGeometry(p, strip, center, normal);
  vNormal   = normal;
  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);
  vPosition = -center;

  return center;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/style.color.js
/* harmony default export */ const style_color = (/* glsl */`uniform vec3 styleColor;
uniform float styleOpacity;

vec4 getStyleColor() {
  return vec4(styleColor, styleOpacity);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.depth.js
/* harmony default export */ const subdivide_depth = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideDepth(vec4 xyzw) {
  float x = xyzw.z;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  return sampleData(vec4(xyzw.xy, i + g, xyzw.w));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.depth.lerp.js
/* harmony default export */ const subdivide_depth_lerp = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideDepthLerp(vec4 xyzw) {
  float x = xyzw.z;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  vec4 xyzw1 = vec4(xyzw.xy, i, xyzw.w);
  vec4 xyzw2 = vec4(xyzw.xy, i + 1.0, xyzw.w);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, g);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.height.js
/* harmony default export */ const subdivide_height = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideHeight(vec4 xyzw) {
  float x = xyzw.y;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  return sampleData(vec4(xyzw.x, i + g, xyzw.zw));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.height.lerp.js
/* harmony default export */ const subdivide_height_lerp = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideHeightLerp(vec4 xyzw) {
  float x = xyzw.y;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  vec4 xyzw1 = vec4(xyzw.x, i, xyzw.zw);
  vec4 xyzw2 = vec4(xyzw.x, i + 1.0, xyzw.zw);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, g);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.items.js
/* harmony default export */ const subdivide_items = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideItems(vec4 xyzw) {
  float x = xyzw.w;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  return sampleData(vec4(xyzw.xyz, i + g));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.items.lerp.js
/* harmony default export */ const subdivide_items_lerp = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideItemsLerp(vec4 xyzw) {
  float x = xyzw.w;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  vec4 xyzw1 = vec4(xyzw.xyz, i);
  vec4 xyzw2 = vec4(xyzw.xyz, i + 1.0);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, g);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.width.js
/* harmony default export */ const subdivide_width = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideWidth(vec4 xyzw) {
  float x = xyzw.x;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  return sampleData(vec4(i + g, xyzw.yzw));
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/subdivide.width.lerp.js
/* harmony default export */ const subdivide_width_lerp = (/* glsl */`uniform float subdivideBevel;

// External
vec4 sampleData(vec4 xyzw);

vec4 subdivideWidthLerp(vec4 xyzw) {
  float x = xyzw.x;
  float i = floor(x);
  float f = x - i;

  float minf = subdivideBevel * min(f, 1.0 - f);
  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;

  vec4 xyzw1 = vec4(i, xyzw.yzw);
  vec4 xyzw2 = vec4(i + 1.0, xyzw.yzw);
  
  vec4 a = sampleData(xyzw1);
  vec4 b = sampleData(xyzw2);

  return mix(a, b, g);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/surface.mask.hollow.js
/* harmony default export */ const surface_mask_hollow = (/* glsl */`attribute vec4 position4;

float getSurfaceHollowMask(vec4 xyzw) {
  vec4 df = abs(fract(position4) - .5);
  vec2 df2 = min(df.xy, df.zw);
  float df3 = min(df2.x, df2.y);
  return df3;
}`);

;// CONCATENATED MODULE: ./src/shaders/glsl/surface.position.js
/* harmony default export */ const surface_position = (/* glsl */`uniform vec4 geometryClip;
uniform vec4 geometryResolution;
uniform vec4 mapSize;

attribute vec4 position4;

// External
vec3 getPosition(vec4 xyzw, float canonical);

vec3 getSurfacePosition() {
  vec4 p = min(geometryClip, position4);

#ifdef SURFACE_CLOSED_X
  if (p.x == geometryClip.x) p.x = 0.0;
#endif
#ifdef SURFACE_CLOSED_Y
  if (p.y == geometryClip.y) p.y = 0.0;
#endif

  vec3 xyz = getPosition(p, 1.0);

  // Overwrite UVs
#ifdef POSITION_UV
#ifdef POSITION_UV_INT
  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;
#else
  vUV = position4.xy * geometryResolution.xy;
#endif
#endif

  return xyz;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/surface.position.normal.js
/* harmony default export */ const surface_position_normal = (/* glsl */`uniform vec4 mapSize;
uniform vec4 geometryResolution;
uniform vec4 geometryClip;
attribute vec4 position4;

// External
vec3 getPosition(vec4 xyzw, float canonical);
vec3 getNormal(vec4 xyzw);

varying vec3 vNormal;
varying vec3 vLight;
varying vec3 vPosition;

vec3 getSurfacePositionNormal() {

  vec4 p = min(geometryClip, position4);
#ifdef SURFACE_CLOSED_X
  if (p.x == geometryClip.x) p.x = 0.0;
#endif
#ifdef SURFACE_CLOSED_Y
  if (p.y == geometryClip.y) p.y = 0.0;
#endif

  vec3 center = getPosition(p, 1.0);
  vNormal     = normalMatrix * normalize(getNormal(p));
  vLight      = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz); // hardcoded directional light
  vPosition   = -center;

#ifdef POSITION_UV
#ifdef POSITION_UV_INT
  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;
#else
  vUV = position4.xy * geometryResolution.xy;
#endif
#endif

  return center;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/surface.position.shaded.js
/* harmony default export */ const surface_position_shaded = (/* glsl */`uniform vec4 mapSize;
uniform vec4 geometryResolution;
uniform vec4 geometryClip;
attribute vec4 position4;

// External
vec3 getPosition(vec4 xyzw, float canonical);

vec4 wrapAround(vec4 xyzw) {
#ifdef SURFACE_CLOSED_X
  float gx = geometryClip.x;
  if (xyzw.x < 0.0) xyzw.x += gx;
  if (xyzw.x >= gx) xyzw.x -= gx;
#endif
#ifdef SURFACE_CLOSED_Y
  float gy = geometryClip.y;
  if (xyzw.y < 0.0) xyzw.y += gy;
  if (xyzw.y >= gy) xyzw.y -= gy;
#endif
  return xyzw;
}

void getSurfaceGeometry(vec4 xyzw, float edgeX, float edgeY, out vec3 left, out vec3 center, out vec3 right, out vec3 up, out vec3 down) {
  vec4 deltaX = vec4(1.0, 0.0, 0.0, 0.0);
  vec4 deltaY = vec4(0.0, 1.0, 0.0, 0.0);

  center =                  getPosition(xyzw, 1.0);
  left   =                  center;
  down   =                  center;
  right  = (edgeX < 0.5)  ? getPosition(wrapAround(xyzw + deltaX), 0.0) : (2.0 * center - getPosition(xyzw - deltaX, 0.0));
  up     = (edgeY < 0.5)  ? getPosition(wrapAround(xyzw + deltaY), 0.0) : (2.0 * center - getPosition(xyzw - deltaY, 0.0));
}

vec3 getSurfaceNormal(vec3 left, vec3 center, vec3 right, vec3 up, vec3 down) {
  vec3 dx = right - left;
  vec3 dy = up    - down;
  vec3 n = cross(dy, dx);
  if (length(n) > 0.0) {
    return normalize(n);
  }
  return vec3(0.0, 1.0, 0.0);
}

varying vec3 vNormal;
varying vec3 vLight;
varying vec3 vPosition;

vec3 getSurfacePositionShaded() {
  vec3 left, center, right, up, down;

  vec4 p = min(geometryClip, position4);
  vec2 surface = vec2(0.0);
#ifdef SURFACE_CLOSED_X
  if (p.x == geometryClip.x) p.x = 0.0;
#else
  if (p.x == geometryClip.x) surface.x = 1.0;
  //if (p.x == 0.0) surface.x = -1.0;
#endif
#ifdef SURFACE_CLOSED_Y
  if (p.y == geometryClip.y) p.y = 0.0;
#else
  if (p.y == geometryClip.y) surface.y = 1.0;
  //if (p.y == 0.0) surface.y = -1.0;
#endif

  getSurfaceGeometry(p, surface.x, surface.y, left, center, right, up, down);
  vNormal   = getSurfaceNormal(left, center, right, up, down);
  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz); // hardcoded directional light
  vPosition = -center;

#ifdef POSITION_UV
#ifdef POSITION_UV_INT
  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;
#else
  vUV = position4.xy * geometryResolution.xy;
#endif
#endif

  return center;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/ticks.position.js
/* harmony default export */ const ticks_position = (/* glsl */`uniform float worldUnit;
uniform float focusDepth;
uniform float tickSize;
uniform float tickEpsilon;
uniform vec3  tickNormal;
uniform vec2  tickStrip;

vec4 getSample(vec4 xyzw);

vec3 transformPosition(vec4 position, in vec4 stpqIn, out vec4 stpqOut);

vec3 getTickPosition(vec4 xyzw, in vec4 stpqIn, out vec4 stpqOut) {
  float epsilon = tickEpsilon;

  // determine tick direction
  float leftX  = max(tickStrip.x, xyzw.y - 1.0);
  float rightX = min(tickStrip.y, xyzw.y + 1.0);
  
  vec4 left    = getSample(vec4(leftX,  xyzw.zw, 0.0));
  vec4 right   = getSample(vec4(rightX, xyzw.zw, 0.0));
  vec4 diff    = right - left;

  vec3 normal  = cross(normalize(diff.xyz + vec3(diff.w)), tickNormal);
  float bias   = max(0.0, 1.0 - length(normal) * 2.0);
       normal  = mix(normal, tickNormal.yzx, bias * bias);
  
  // transform (point) and (point + delta)
  vec4 center  = getSample(vec4(xyzw.yzw, 0.0));
  vec4 delta   = vec4(normal, 0.0) * epsilon;

  vec4 a = center;
  vec4 b = center + delta;

  vec4 _;
  vec3 c = transformPosition(a, stpqIn, stpqOut);
  vec3 d = transformPosition(b, stpqIn, _);
  
  // sample on either side to create line
  float line = xyzw.x - .5;
  vec3  mid  = c;
  vec3  side = normalize(d - c);

  return mid + side * line * tickSize * worldUnit * focusDepth;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/transform3.position.js
/* harmony default export */ const transform3_position = (/* glsl */`uniform mat4 transformMatrix;

vec4 transformPosition(vec4 position, inout vec4 stpq) {
  return transformMatrix * vec4(position.xyz, 1.0);
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/transform4.position.js
/* harmony default export */ const transform4_position = (/* glsl */`uniform mat4 transformMatrix;
uniform vec4 transformOffset;

vec4 transformPosition(vec4 position, inout vec4 stpq) {
  return transformMatrix * position + transformOffset;
}
`);

;// CONCATENATED MODULE: ./src/shaders/glsl/view.position.js
/* harmony default export */ const view_position = (/* glsl */`// Implicit three.js uniform
// uniform mat4 viewMatrix;

vec4 getViewPosition(vec4 position, inout vec4 stpq) {
  return (viewMatrix * vec4(position.xyz, 1.0));
}
`);

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/graph/graph.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
  Graph of nodes with outlets
*/
class Graph {
  static initClass() {
    this.index = 0;

    this.IN = 0;
    this.OUT = 1;
  }
  // eslint-disable-next-line no-unused-vars
  static id(name) {
    return ++Graph.index;
  }

  constructor(nodes, parent = null) {
    this.parent = parent;
    this.id = Graph.id();
    this.nodes = [];
    nodes && this.add(nodes);
  }

  inputs() {
    const inputs = [];
    for (const node of Array.from(this.nodes)) {
      for (const outlet of Array.from(node.inputs)) {
        if (outlet.input === null) {
          inputs.push(outlet);
        }
      }
    }
    return inputs;
  }

  outputs() {
    const outputs = [];
    for (const node of Array.from(this.nodes)) {
      for (const outlet of Array.from(node.outputs)) {
        if (outlet.output.length === 0) {
          outputs.push(outlet);
        }
      }
    }
    return outputs;
  }

  getIn(name) {
    return Array.from(this.inputs()).filter(
      (outlet) => outlet.name === name
    )[0];
  }
  getOut(name) {
    return Array.from(this.outputs()).filter(
      (outlet) => outlet.name === name
    )[0];
  }

  add(node, ignore) {
    if (node.length) {
      for (const _node of Array.from(node)) {
        this.add(_node);
      }
      return;
    }

    if (node.graph && !ignore) {
      throw new Error("Adding node to two graphs at once");
    }

    node.graph = this;
    this.nodes.push(node);
  }

  remove(node, ignore) {
    if (node.length) {
      for (const _node of Array.from(node)) {
        this.remove(_node);
      }
      return;
    }

    if (node.graph !== this) {
      throw new Error("Removing node from wrong graph.");
    }

    ignore || node.disconnect();

    this.nodes.splice(this.nodes.indexOf(node), 1);
    node.graph = null;
  }

  adopt(node) {
    if (node.length) {
      for (const _node of Array.from(node)) {
        this.adopt(_node);
      }
      return;
    }

    node.graph.remove(node, true);
    this.add(node, true);
  }
}
Graph.initClass();

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/graph/outlet.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


/*
  In/out outlet on node
*/
class Outlet {
  static initClass() {
    this.index = 0;
  }
  static make(outlet, extra) {
    if (extra == null) {
      extra = {};
    }
    const meta = extra;
    if (outlet.meta != null) {
      for (const key in outlet.meta) {
        const value = outlet.meta[key];
        meta[key] = value;
      }
    }
    return new Outlet(
      outlet.inout,
      outlet.name,
      outlet.hint,
      outlet.type,
      meta
    );
  }
  static id(name) {
    return `_io_${++Outlet.index}_${name}`;
  }

  static hint(name) {
    name = name.replace(/^_io_[0-9]+_/, "");
    name = name.replace(/_i_o$/, "");
    return (name = name.replace(/(In|Out|Inout|InOut)$/, ""));
  }

  constructor(inout, name, hint, type, meta, id) {
    this.inout = inout;
    this.name = name;
    this.hint = hint;
    this.type = type;
    if (meta == null) {
      meta = {};
    }
    this.meta = meta;
    this.id = id;
    if (this.hint == null) {
      this.hint = Outlet.hint(this.name);
    }

    this.node = null;
    this.input = null;
    this.output = [];
    if (this.id == null) {
      this.id = Outlet.id(this.hint);
    }
  }

  // Change into given outlet without touching connections
  morph(outlet) {
    this.inout = outlet.inout;
    this.name = outlet.name;
    this.hint = outlet.hint;
    this.type = outlet.type;
    return (this.meta = outlet.meta);
  }

  // Copy with unique name and cloned metadata
  dupe(name) {
    if (name == null) {
      name = this.id;
    }
    const outlet = Outlet.make(this);
    outlet.name = name;
    return outlet;
  }

  // Connect to given outlet
  connect(outlet) {
    // Auto-reverse in/out to out/in
    if (this.inout === Graph.IN && outlet.inout === Graph.OUT) {
      return outlet.connect(this);
    }

    // Disallow bad combinations
    if (this.inout !== Graph.OUT || outlet.inout !== Graph.IN) {
      throw new Error("Can only connect out to in.");
    }

    // Check for existing connection
    if (outlet.input === this) {
      return;
    }

    // Disconnect existing connections
    outlet.disconnect();

    // Add new connection.
    outlet.input = this;
    return this.output.push(outlet);
  }

  // Disconnect given outlet (or all)
  disconnect(outlet) {
    // Disconnect input from the other side.
    if (this.input) {
      this.input.disconnect(this);
    }

    if (this.output.length) {
      if (outlet) {
        // Remove one outgoing connection.
        const index = this.output.indexOf(outlet);
        if (index >= 0) {
          this.output.splice(index, 1);
          return (outlet.input = null);
        }
      } else {
        // Remove all outgoing connections.
        for (outlet of Array.from(this.output)) {
          outlet.input = null;
        }
        return (this.output = []);
      }
    }
  }
}
Outlet.initClass();

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/graph/node.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



/*
 Node in graph.
*/
class graph_node_Node {
  static initClass() {
    this.index = 0;
  }
  static id(_name) {
    return ++graph_node_Node.index;
  }

  constructor(owner, outlets) {
    this.owner = owner;
    this.graph = null;
    this.inputs = [];
    this.outputs = [];
    this.all = [];
    this.outlets = null;
    this.id = graph_node_Node.id();

    this.setOutlets(outlets);
  }

  // Retrieve input
  getIn(name) {
    return Array.from(this.inputs).filter((outlet) => outlet.name === name)[0];
  }

  // Retrieve output
  getOut(name) {
    return Array.from(this.outputs).filter((outlet) => outlet.name === name)[0];
  }

  // Retrieve by name
  get(name) {
    return this.getIn(name) || this.getOut(name);
  }

  // Set new outlet definition
  setOutlets(outlets) {
    if (outlets != null) {
      // First init
      let outlet;
      if (this.outlets == null) {
        this.outlets = {};
        for (outlet of Array.from(outlets)) {
          if (!(outlet instanceof Outlet)) {
            outlet = Outlet.make(outlet);
          }
          this._add(outlet);
        }
        return;
      }

      // Return new/old outlet matching hash key
      const hash = (
        outlet // Match by name, direction and type.
      ) => [outlet.name, outlet.inout, outlet.type].join("-");

      // Build hash of new outlets
      const match = {};
      for (outlet of Array.from(outlets)) {
        match[hash(outlet)] = true;
      }

      // Remove missing outlets, record matches
      for (let key in this.outlets) {
        outlet = this.outlets[key];
        key = hash(outlet);
        if (match[key]) {
          match[key] = outlet;
        } else {
          this._remove(outlet);
        }
      }

      // Insert new outlets
      for (outlet of Array.from(outlets)) {
        // Find match by hash
        const existing = match[hash(outlet)];
        if (existing instanceof Outlet) {
          // Update existing outlets in place to retain connections.
          this._morph(existing, outlet);
        } else {
          // Spawn new outlet
          if (!(outlet instanceof Outlet)) {
            outlet = Outlet.make(outlet);
          }
          this._add(outlet);
        }
      }

      this;
    }
    return this.outlets;
  }

  // Connect to the target node by matching up inputs and outputs.
  connect(node, empty, force) {
    let dest, dests, hint, source, type;
    const outlets = {};
    const hints = {};

    const typeHint = (outlet) => type + "/" + outlet.hint;

    // Hash the types/hints of available target outlets.
    for (dest of Array.from(node.inputs)) {
      // Only autoconnect if not already connected
      let list;
      if (!force && dest.input) {
        continue;
      }

      // Match outlets by type/name hint, then type/position key
      ({ type } = dest);
      hint = typeHint(dest);

      if (!hints[hint]) {
        hints[hint] = dest;
      }
      outlets[type] = list = outlets[type] || [];
      list.push(dest);
    }

    // Available source outlets
    let sources = this.outputs;

    // Ignore connected source if only matching empties.
    sources = sources.filter((outlet) => !(empty && outlet.output.length));

    // Match hints first
    for (source of Array.from(sources.slice())) {
      // Match outlets by type and name
      ({ type } = source);
      hint = typeHint(source);
      dests = outlets[type];

      // Connect if found
      if ((dest = hints[hint])) {
        source.connect(dest);

        // Remove from potential set
        delete hints[hint];
        dests.splice(dests.indexOf(dest), 1);
        sources.splice(sources.indexOf(source), 1);
      }
    }

    // Match what's left
    if (!sources.length) {
      return this;
    }
    for (source of Array.from(sources.slice())) {
      ({ type } = source);
      dests = outlets[type];

      // Match outlets by type and order
      if (dests && dests.length) {
        // Link up and remove from potential set
        source.connect(dests.shift());
      }
    }

    return this;
  }

  // Disconnect entire node
  disconnect(_node) {
    let outlet;
    for (outlet of Array.from(this.inputs)) {
      outlet.disconnect();
    }
    for (outlet of Array.from(this.outputs)) {
      outlet.disconnect();
    }

    return this;
  }

  // Return hash key for outlet
  _key(outlet) {
    return [outlet.name, outlet.inout].join("-");
  }

  // Add outlet object to node
  _add(outlet) {
    const key = this._key(outlet);

    // Sanity checks
    if (outlet.node) {
      throw new Error("Adding outlet to two nodes at once.");
    }
    if (this.outlets[key]) {
      throw new Error(`Adding two identical outlets to same node. (${key})`);
    }

    // Link back outlet
    outlet.node = this;

    // Add to name hash and inout list
    if (outlet.inout === Graph.IN) {
      this.inputs.push(outlet);
    }
    if (outlet.inout === Graph.OUT) {
      this.outputs.push(outlet);
    }
    this.all.push(outlet);
    return (this.outlets[key] = outlet);
  }

  // Morph outlet to other
  _morph(existing, outlet) {
    let key = this._key(outlet);
    delete this.outlets[key];

    existing.morph(outlet);

    key = this._key(outlet);
    return (this.outlets[key] = outlet);
  }

  // Remove outlet object from node.
  _remove(outlet) {
    const key = this._key(outlet);

    // Sanity checks
    if (outlet.node !== this) {
      throw new Error("Removing outlet from wrong node.");
    }

    // Disconnect outlet.
    outlet.disconnect();

    // Unlink outlet.
    outlet.node = null;

    // Remove from name list and inout list.
    delete this.outlets[key];
    if (outlet.inout === Graph.IN) {
      this.inputs.splice(this.inputs.indexOf(outlet), 1);
    }
    if (outlet.inout === Graph.OUT) {
      this.outputs.splice(this.outputs.indexOf(outlet), 1);
    }
    this.all.splice(this.all.indexOf(outlet), 1);
    return this;
  }
}
graph_node_Node.initClass();

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/graph/index.js

const { IN, OUT } = Graph;





;// CONCATENATED MODULE: ./node_modules/shadergraph/src/linker/snippet.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
class Snippet {
  static initClass() {
    this.index = 0;
  }
  static namespace() {
    return `_sn_${++Snippet.index}_`;
  }

  static load(language, name, code) {
    const program = language.parse(name, code);
    const [sigs, compiler] = Array.from(language.compile(program));
    return new Snippet(language, sigs, compiler, name, code);
  }

  constructor(language, _signatures, _compiler, _name, _original) {
    this.language = language;
    this._signatures = _signatures;
    this._compiler = _compiler;
    this._name = _name;
    this._original = _original;
    this.namespace = null;
    this.code = null;

    this.main = null;
    this.entry = null;

    this.uniforms = null;
    this.externals = null;
    this.symbols = null;
    this.attributes = null;
    this.varyings = null;

    // Tidy up object for export
    if (!this.language) {
      delete this.language;
    }
    if (!this._signatures) {
      delete this._signatures;
    }
    if (!this._compiler) {
      delete this._compiler;
    }
    if (!this._original) {
      delete this._original;
    }

    // Insert snippet name if not provided
    if (!this._name) {
      this._name =
        this._signatures != null ? this._signatures.main.name : undefined;
    }
  }

  clone() {
    return new Snippet(
      this.language,
      this._signatures,
      this._compiler,
      this._name,
      this._original
    );
  }

  bind(config, uniforms, namespace, defines) {
    // Alt syntax (namespace, uniforms, defines)
    let def, left;
    let v;
    if (uniforms === "" + uniforms) {
      [namespace, uniforms, defines] = Array.from([
        uniforms,
        namespace != null ? namespace : {},
        defines != null ? defines : {},
      ]);
      // Alt syntax (uniforms, defines)
    } else if (namespace !== "" + namespace) {
      [defines, namespace] = Array.from([
        namespace != null ? namespace : {},
        undefined,
      ]);
    }

    // Prepare data structure
    this.main = this._signatures.main;
    this.namespace =
      (left = namespace != null ? namespace : this.namespace) != null
        ? left
        : Snippet.namespace();
    this.entry = this.namespace + this.main.name;

    this.uniforms = {};
    this.varyings = {};
    this.attributes = {};
    this.externals = {};
    this.symbols = [];
    const exist = {};
    const exceptions = {};

    // Handle globals and locals for prefixing
    const global = function (name) {
      exceptions[name] = true;
      return name;
    };
    const local = (name) => {
      return this.namespace + name;
    };

    // Apply config
    if (config.globals) {
      for (const key of Array.from(config.globals)) {
        global(key);
      }
    }
    const _u = config.globalUniforms ? global : local;
    const _v = config.globalVaryings ? global : local;
    const _a = config.globalAttributes ? global : local;
    const _e = local;

    // Build finalized properties
    const x = (def) => {
      return (exist[def.name] = true);
    };
    const u = (def, name) => {
      return (this.uniforms[_u(name != null ? name : def.name)] = def);
    };
    v = (def) => {
      return (this.varyings[_v(def.name)] = def);
    };
    const a = (def) => {
      return (this.attributes[_a(def.name)] = def);
    };
    const e = (def) => {
      const name = _e(def.name);
      this.externals[name] = def;
      return this.symbols.push(name);
    };

    const redef = (def) => ({
      type: def.type,
      name: def.name,
      value: def.value,
    });

    for (def of Array.from(this._signatures.uniform)) {
      x(def);
    }
    for (def of Array.from(this._signatures.uniform)) {
      u(redef(def));
    }
    for (def of Array.from(this._signatures.varying)) {
      v(redef(def));
    }
    for (def of Array.from(this._signatures.external)) {
      e(def);
    }
    for (def of Array.from(this._signatures.attribute)) {
      a(redef(def));
    }
    for (const name in uniforms) {
      def = uniforms[name];
      if (exist[name]) {
        u(def, name);
      }
    }

    this.body = this.code = this._compiler(this.namespace, exceptions, defines);

    // Adds defs to original snippet for inspection
    if (defines) {
      const defs = (() => {
        const result = [];
        for (const k in defines) {
          v = defines[k];
          result.push(`#define ${k} ${v}`);
        }
        return result;
      })().join("\n");
      if (defs.length) {
        this._original = [
          defs,
          "//----------------------------------------",
          this._original,
        ].join("\n");
      }
    }

    return null;
  }
}
Snippet.initClass();

// EXTERNAL MODULE: ./node_modules/shadergraph/src/linker/priority.js
var linker_priority = __webpack_require__(3981);
;// CONCATENATED MODULE: ./node_modules/shadergraph/src/linker/assemble.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



/*
  Program assembler

  Builds composite program that can act as new module/snippet
  Unconnected input/outputs and undefined callbacks are exposed in the new global/main scope
  If there is only one call with an identical call signature, a #define is output instead.
*/
const assemble = function (language, namespace, calls, requires) {
  const generate = language;

  const externals = {};
  const symbols = [];
  const uniforms = {};
  const varyings = {};
  const attributes = {};
  const library = {};

  const process = function () {
    let body;
    let ns;
    for (ns in requires) {
      const r = requires[ns];
      required(r.node, r.module);
    }

    [body, calls] = Array.from(handle(calls));
    if (namespace != null) {
      body.entry = namespace;
    }
    const main = generate.build(body, calls);

    const sorted = (() => {
      const result = [];
      for (ns in library) {
        const lib = library[ns];
        result.push(lib);
      }
      return result;
    })().sort((a, b) => linker_priority.compare(a.priority, b.priority));
    const includes = sorted.map((x) => x.code);
    includes.push(main.code);
    const code = generate.lines(includes);

    // Build new virtual snippet
    return {
      namespace: main.name,
      library, // Included library functions
      body: main.code, // Snippet body
      code, // Complete snippet (tests/debug)
      main, // Function signature
      entry: main.name, // Entry point name
      symbols,
      externals,
      uniforms,
      varyings,
      attributes,
    };
  };

  // Sort and process calls
  const handle = (calls) => {
    let c;
    calls = (() => {
      const result = [];
      for (const ns in calls) {
        c = calls[ns];
        result.push(c);
      }
      return result;
    })();
    calls.sort((a, b) => b.priority - a.priority);

    // Call module in DAG chain
    const call = (node, module, priority) => {
      include(node, module, priority);
      const { main } = module;
      const { entry } = module;

      const _lookup = (name) => lookup(node, name);
      const _dangling = (name) => isDangling(node, name);
      return generate.call(_lookup, _dangling, entry, main.signature, body);
    };

    const body = generate.body();
    for (c of Array.from(calls)) {
      call(c.node, c.module, c.priority);
    }

    return [body, calls];
  };

  // Adopt given code as a library at given priority
  const adopt = function (namespace, code, priority) {
    const record = library[namespace];
    if (record != null) {
      return (record.priority = linker_priority.max(record.priority, priority));
    } else {
      return (library[namespace] = { code, priority });
    }
  };

  // Include snippet for a call
  const include = function (node, module, priority) {
    let def, key;
    priority = linker_priority.make(priority);

    // Adopt snippet's libraries
    for (const ns in module.library) {
      const lib = module.library[ns];
      adopt(ns, lib.code, linker_priority.nest(priority, lib.priority));
    }

    // Adopt snippet body as library
    adopt(module.namespace, module.body, priority);

    // Adopt GL vars
    for (key in module.uniforms) {
      def = module.uniforms[key];
      uniforms[key] = def;
    }
    for (key in module.varyings) {
      def = module.varyings[key];
      varyings[key] = def;
    }
    for (key in module.attributes) {
      def = module.attributes[key];
      attributes[key] = def;
    }

    return required(node, module);
  };

  const required = (
    node,
    module // Adopt external symbols
  ) =>
    (() => {
      const result = [];
      for (const key of Array.from(module.symbols)) {
        const ext = module.externals[key];
        if (isDangling(node, ext.name)) {
          const copy = {};
          for (const k in ext) {
            const v = ext[k];
            copy[k] = v;
          }
          copy.name = lookup(node, ext.name);
          externals[key] = copy;
          result.push(symbols.push(key));
        } else {
          result.push(undefined);
        }
      }
      return result;
    })();

  // Check for dangling input/output
  const isDangling = function (node, name) {
    const outlet = node.get(name);

    if (outlet.inout === IN) {
      return outlet.input === null;
    } else if (outlet.inout === OUT) {
      return outlet.output.length === 0;
    }
  };

  // Look up unique name for outlet
  const lookup = function (node, name) {
    // Traverse graph edge
    let outlet = node.get(name);
    if (!outlet) {
      return null;
    }

    if (outlet.input) {
      outlet = outlet.input;
    }
    ({ name } = outlet);

    return outlet.id;
  };

  return process();
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/linker/program.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



/*
  Program assembly model

  Snippets are added to its queue, registering calls and code includes.
  Calls are de-duped and scheduled at the earliest point required for correct data flow.

  When assemble() is called, it builds a main() function to
  execute all calls in final order.

  The result is a new instance of Snippet that acts as if it
  was parsed from the combined source of the component
  nodes.
*/
class Program {
  static initClass() {
    this.index = 0;
  }
  static entry() {
    return `_pg_${++Program.index}_`;
  }

  // Program starts out empty, ready to compile starting from a particular block
  constructor(language, namespace, graph) {
    this.language = language;
    this.namespace = namespace;
    this.graph = graph;
    this.calls = {};
    this.requires = {};
  }

  // Call a given module at certain priority
  call(node, module, priority) {
    let exists;
    const ns = module.namespace;

    // Merge all calls down into one with the right priority
    if ((exists = this.calls[ns])) {
      exists.priority = Math.max(exists.priority, priority);
    } else {
      this.calls[ns] = { node, module, priority };
    }

    return this;
  }

  // Require a given (callback) module's externals
  require(node, module) {
    const ns = module.namespace;
    return (this.requires[ns] = { node, module });
  }

  // Compile queued ops into result
  assemble() {
    const data = assemble(
      this.language,
      this.namespace != null ? this.namespace : Program.entry,
      this.calls,
      this.requires
    );
    const snippet = new Snippet();
    for (const key in data) {
      snippet[key] = data[key];
    }
    snippet.graph = this.graph;
    return snippet;
  }
}
Program.initClass();

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/linker/link.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



/*
 Callback linker

 Imports given modules and generates linkages for registered callbacks.

 Builds composite program with single module as exported entry point
*/

const link_link = function (language, links, modules, exported) {
  const generate = language;
  let includes = [];

  const symbols = [];
  const externals = {};
  const uniforms = {};
  const attributes = {};
  const varyings = {};
  const library = {};

  const process = function () {
    const exports = generate.links(links);

    const header = [];
    if (exports.defs != null) {
      header.push(exports.defs);
    }
    if (exports.bodies != null) {
      header.push(exports.bodies);
    }

    for (const m of Array.from(modules)) {
      include(m.node, m.module, m.priority);
    }
    const sorted = (() => {
      const result = [];
      for (const ns in library) {
        const lib = library[ns];
        result.push(lib);
      }
      return result;
    })().sort((a, b) => linker_priority.compare(a.priority, b.priority));
    includes = sorted.map((x) => x.code);

    let code = generate.lines(includes);
    code = generate.defuse(code);
    if (header.length) {
      code = [generate.lines(header), code].join("\n");
    }
    code = generate.hoist(code);
    code = generate.dedupe(code);

    // Export module's externals
    const e = exported;
    return {
      namespace: e.main.name,
      code, // Complete snippet (tests/debug)
      main: e.main, // Function signature
      entry: e.main.name, // Entry point name
      externals,
      uniforms,
      attributes,
      varyings,
    };
  };

  // Adopt given code as a library at given priority
  const adopt = function (namespace, code, priority) {
    const record = library[namespace];
    if (record != null) {
      return (record.priority = linker_priority.max(record.priority, priority));
    } else {
      return (library[namespace] = { code, priority });
    }
  };

  // Include piece of code
  const include = function (node, module, priority) {
    let def, key;
    priority = linker_priority.make(priority);

    // Adopt snippet's libraries
    for (const ns in module.library) {
      const lib = module.library[ns];
      adopt(ns, lib.code, linker_priority.nest(priority, lib.priority));
    }

    // Adopt snippet body as library
    adopt(module.namespace, module.body, priority);

    // Adopt externals
    for (key in module.uniforms) {
      def = module.uniforms[key];
      uniforms[key] = def;
    }
    for (key in module.varyings) {
      def = module.varyings[key];
      varyings[key] = def;
    }
    for (key in module.attributes) {
      def = module.attributes[key];
      attributes[key] = def;
    }

    return (() => {
      const result = [];
      for (key of Array.from(module.symbols)) {
        const ext = module.externals[key];
        if (isDangling(node, ext.name)) {
          externals[key] = ext;
          result.push(symbols.push(key));
        } else {
          result.push(undefined);
        }
      }
      return result;
    })();
  };

  // Check for dangling input/output
  const isDangling = function (node, name) {
    const outlet = node.get(name);

    if (!outlet) {
      const module =
        (node.owner.snippet != null ? node.owner.snippet._name : undefined) !=
        null
          ? node.owner.snippet != null
            ? node.owner.snippet._name
            : undefined
          : node.owner.namespace;
      throw new Error(
        `Unable to link program. Unlinked callback \`${name}\` on \`${module}\``
      );
    }

    if (outlet.inout === IN) {
      return outlet.input === null;
    } else if (outlet.inout === OUT) {
      return outlet.output.length === 0;
    }
  };

  return process();
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/linker/layout.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



const debug = false;

/*
  Program linkage layout

  Entry points are added to its dependency graph
  Callbacks are linked either with a go-between function
  or a #define if the signatures are identical.
*/
class Layout {
  constructor(language, graph) {
    this.language = language;
    this.graph = graph;
    this.links = [];
    this.includes = [];
    this.modules = {};
    this.visits = {};
  }

  // Link up a given named external to this module's entry point
  callback(node, module, priority, name, external) {
    return this.links.push({ node, module, priority, name, external });
  }

  // Include this module of code
  include(node, module, priority) {
    let m;
    if ((m = this.modules[module.namespace]) != null) {
      return (m.priority = Math.max(priority, m.priority));
    } else {
      this.modules[module.namespace] = true;
      return this.includes.push({ node, module, priority });
    }
  }

  // Visit each namespace at most once to avoid infinite recursion
  visit(namespace) {
    debug && console.log("Visit", namespace, !this.visits[namespace]);
    if (this.visits[namespace]) {
      return false;
    }
    return (this.visits[namespace] = true);
  }

  // Compile queued ops into result
  link(module) {
    const data = link_link(this.language, this.links, this.includes, module);
    const snippet = new Snippet();
    for (const key in data) {
      snippet[key] = data[key];
    }
    snippet.graph = this.graph;
    return snippet;
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/linker/index.js


const { load } = Snippet;








;// CONCATENATED MODULE: ./node_modules/shadergraph/src/block/block.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining
 * DS104: Avoid inline assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




const block_debug = false;

class Block {
  static previous(outlet) {
    return outlet.input != null ? outlet.input.node.owner : undefined;
  }

  constructor(delay) {
    // Subclasses can pass `delay` to allow them to initialize before they call
    // `@construct`.
    if (delay == null) {
      delay = false;
    }
    if (!delay) {
      this.construct();
    }
  }

  construct() {
    let left;
    if (this.namespace == null) {
      this.namespace = Program.entry();
    }
    return (this.node = new graph_node_Node(
      this,
      (left =
        typeof this.makeOutlets === "function"
          ? this.makeOutlets()
          : undefined) != null
        ? left
        : {}
    ));
  }

  refresh() {
    let left;
    return this.node.setOutlets(
      (left =
        typeof this.makeOutlets === "function"
          ? this.makeOutlets()
          : undefined) != null
        ? left
        : {}
    );
  }

  clone() {
    return new Block();
  }

  // Compile a new program starting from this block
  compile(language, namespace) {
    const program = new Program(
      language,
      namespace != null ? namespace : Program.entry(),
      this.node.graph
    );
    this.call(program, 0);
    return program.assemble();
  }

  // Link up programs into a layout, starting from this block
  link(language, namespace) {
    const module = this.compile(language, namespace);

    const layout = new Layout(language, this.node.graph);
    this._include(module, layout, 0);
    this.export(layout, 0);
    return layout.link(module);
  }

  // Subclassed methods
  call(_program, _depth) {}
  callback(_layout, _depth, _name, _external, _outlet) {}
  export(_layout, _depth) {}

  // Info string for debugging
  _info(suffix) {
    let string =
      (this.node.owner.snippet != null
        ? this.node.owner.snippet._name
        : undefined) != null
        ? this.node.owner.snippet != null
          ? this.node.owner.snippet._name
          : undefined
        : this.node.owner.namespace;
    if (suffix != null) {
      return (string += "." + suffix);
    }
  }

  // Create an outlet for a signature definition
  _outlet(def, props) {
    const outlet = Outlet.make(def, props);
    outlet.meta.def = def;
    return outlet;
  }

  // Make a call to this module in the given program
  _call(module, program, depth) {
    return program.call(this.node, module, depth);
  }

  // Require this module's dependencies in the given program
  _require(module, program) {
    return program.require(this.node, module);
  }

  // Make a call to all connected inputs
  _inputs(module, program, depth) {
    return (() => {
      const result = [];
      for (const arg of Array.from(module.main.signature)) {
        const outlet = this.node.get(arg.name);
        result.push(
          block_guard_(Block.previous(outlet), (x) => x.call(program, depth + 1))
        );
      }
      return result;
    })();
  }

  // Insert callback to this module in the given layout
  _callback(module, layout, depth, name, external, outlet) {
    return layout.callback(this.node, module, depth, name, external, outlet);
  }

  // Include this module in the given layout
  _include(module, layout, depth) {
    return layout.include(this.node, module, depth);
  }

  // Link this module's connected callbacks
  _link(module, layout, depth) {
    block_debug && console.log("block::_link", this.toString(), module.namespace);
    return (() => {
      const result = [];
      for (const key of Array.from(module.symbols)) {
        const ext = module.externals[key];
        let outlet = this.node.get(ext.name);
        if (!outlet) {
          throw new OutletError(
            `External not found on ${this._info(ext.name)}`
          );
        }

        if (outlet.meta.child != null) {
          continue;
        }

        let parent = outlet;

        // eslint-disable-next-line prefer-const
        let block;
        while (!block && parent) {
          [parent, outlet] = Array.from([outlet.meta.parent, parent]);
        }

        block = Block.previous(outlet);
        if (!block) {
          throw new OutletError(
            `Missing connection on ${this._info(ext.name)}`
          );
        }

        block_debug && console.log("callback -> ", this.toString(), ext.name, outlet);
        block.callback(layout, depth + 1, key, ext, outlet.input);
        result.push(
          block != null ? block.export(layout, depth + 1) : undefined
        );
      }
      return result;
    })();
  }

  // Trace backwards to discover callbacks further up
  _trace(module, layout, depth) {
    block_debug && console.log("block::_trace", this.toString(), module.namespace);
    return (() => {
      const result = [];
      for (const arg of Array.from(module.main.signature)) {
        const outlet = this.node.get(arg.name);
        result.push(
          block_guard_(Block.previous(outlet), (x) => x.export(layout, depth + 1))
        );
      }
      return result;
    })();
  }
}

const OutletError = function (message) {
  const e = new Error(message);
  e.name = "OutletError";
  return e;
};

OutletError.prototype = new Error();

function block_guard_(value, transform) {
  return typeof value !== "undefined" && value !== null
    ? transform(value)
    : undefined;
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/block/call.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Call extends Block {
  constructor(snippet) {
    super(true);

    this.snippet = snippet;
    this.namespace = snippet.namespace;
    this.construct();
  }

  clone() {
    return new Call(this.snippet);
  }

  makeOutlets() {
    const main = this.snippet.main.signature;
    const { externals } = this.snippet;
    const { symbols } = this.snippet;

    const params = Array.from(main).map((outlet) =>
      this._outlet(outlet, { callback: false })
    );
    const callbacks = Array.from(symbols).map((key) =>
      this._outlet(externals[key], { callback: true })
    );

    return params.concat(callbacks);
  }

  call(program, depth) {
    this._call(this.snippet, program, depth);
    return this._inputs(this.snippet, program, depth);
  }

  export(layout, depth) {
    if (!layout.visit(this.namespace, depth)) {
      return;
    }

    this._link(this.snippet, layout, depth);
    return this._trace(this.snippet, layout, depth);
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/block/callback.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



/*
  Re-use a subgraph as a callback
*/
class Callback extends Block {
  constructor(graph) {
    super(true);
    this.graph = graph;
    this.construct();
  }

  refresh() {
    super.refresh();
    return delete this.subroutine;
  }

  clone() {
    return new Callback(this.graph);
  }

  makeOutlets() {
    let outlet;
    this.make();

    const outlets = [];
    let ins = [];
    let outs = [];

    // Pass-through existing callbacks
    // Collect open inputs/outputs
    const handle = (outlet, list) => {
      if (outlet.meta.callback) {
        if (outlet.inout === Graph.IN) {
          // Dupe outlet and create two-way link between cloned outlets
          const dupe = outlet.dupe();
          if (dupe.meta.child == null) {
            dupe.meta.child = outlet;
          }
          outlet.meta.parent = dupe;

          return outlets.push(dupe);
        }
      } else {
        return list.push(outlet.type);
      }
    };

    for (outlet of Array.from(this.graph.inputs())) {
      handle(outlet, ins);
    }
    for (outlet of Array.from(this.graph.outputs())) {
      handle(outlet, outs);
    }

    // Merge inputs/outputs into new callback signature
    ins = ins.join(",");
    outs = outs.join(",");
    const type = `(${ins})(${outs})`;

    outlets.push({
      name: "callback",
      type,
      inout: Graph.OUT,
      meta: {
        callback: true,
        def: this.subroutine.main,
      },
    });

    return outlets;
  }

  make() {
    return (this.subroutine = this.graph.compile(this.namespace));
  }

  export(layout, depth) {
    if (!layout.visit(this.namespace, depth)) {
      return;
    }

    this._link(this.subroutine, layout, depth);
    return this.graph.export(layout, depth);
  }

  call(program, depth) {
    return this._require(this.subroutine, program, depth);
  }

  callback(layout, depth, name, external, outlet) {
    this._include(this.subroutine, layout, depth);
    return this._callback(
      this.subroutine,
      layout,
      depth,
      name,
      external,
      outlet
    );
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/block/isolate.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



/*
  Isolate a subgraph as a single node
*/
class Isolate extends Block {
  constructor(graph) {
    super(true);
    this.graph = graph;
    this.construct();
  }

  refresh() {
    super.refresh();
    return delete this.subroutine;
  }

  clone() {
    return new Isolate(this.graph);
  }

  makeOutlets() {
    this.make();

    const outlets = [];

    const seen = {};
    const done = {};
    for (const set of ["inputs", "outputs"]) {
      for (const outlet of Array.from(this.graph[set]())) {
        // Preserve name of 'return' and 'callback' outlets
        let name = undefined;
        if (
          ["return", "callback"].includes(outlet.hint) &&
          outlet.inout === Graph.OUT
        ) {
          name = outlet.hint;
        }

        // Unless it already exists
        if (seen[name] != null) {
          name = undefined;
        }

        // Dupe outlet and remember link to original
        const dupe = outlet.dupe(name);
        if (dupe.meta.child == null) {
          dupe.meta.child = outlet;
        }
        outlet.meta.parent = dupe;
        if (name != null) {
          seen[name] = true;
        }
        done[outlet.name] = dupe;

        outlets.push(dupe);
      }
    }

    return outlets;
  }

  make() {
    return (this.subroutine = this.graph.compile(this.namespace));
  }

  call(program, depth) {
    this._call(this.subroutine, program, depth);
    return this._inputs(this.subroutine, program, depth);
  }

  export(layout, depth) {
    if (!layout.visit(this.namespace, depth)) {
      return;
    }

    // Link up with normal inputs
    this._link(this.subroutine, layout, depth);
    this._trace(this.subroutine, layout, depth);

    // Export callbacks needed to call the subroutine
    return this.graph.export(layout, depth);
  }

  callback(layout, depth, name, external, outlet) {
    outlet = outlet.meta.child;
    return outlet.node.owner.callback(layout, depth, name, external, outlet);
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/block/join.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


/*
  Join multiple disconnected nodes
*/
class join_Join extends Block {
  constructor(nodes) {
    super(true);
    this.nodes = nodes;
    this.construct();
  }

  clone() {
    return new join_Join(this.nodes);
  }

  makeOutlets() {
    return [];
  }

  call(program, depth) {
    return (() => {
      const result = [];
      for (const node of Array.from(this.nodes)) {
        const block = node.owner;
        result.push(block.call(program, depth));
      }
      return result;
    })();
  }

  export(layout, depth) {
    return (() => {
      const result = [];
      for (const node of Array.from(this.nodes)) {
        const block = node.owner;
        result.push(block.export(layout, depth));
      }
      return result;
    })();
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/block/index.js






;// CONCATENATED MODULE: ./node_modules/shadergraph/src/visualize/serialize.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// Dump graph for debug/visualization purposes


const serialize = function (graph) {
  const nodes = [];
  const links = [];

  for (const node of Array.from(graph.nodes)) {
    let outlet;
    const record = {
      // Data
      id: node.id,
      name: null,
      type: null,
      depth: null,
      graph: null,
      inputs: [],
      outputs: [],
    };

    nodes.push(record);

    const { inputs } = record;
    const { outputs } = record;

    const block = node.owner;

    if (block instanceof Call) {
      record.name = block.snippet._name;
      record.type = "call";
      record.code = block.snippet._original;
    } else if (block instanceof Callback) {
      record.name = "Callback";
      record.type = "callback";
      record.graph = serialize(block.graph);
    } else if (block instanceof Isolate) {
      record.name = "Isolate";
      record.type = "isolate";
      record.graph = serialize(block.graph);
    } else if (block instanceof join_Join) {
      record.name = "Join";
      record.type = "join";
    } else if (block != null) {
      if (record.name == null) {
        record.name = block.name != null ? block.name : block.type;
      }
      if (record.type == null) {
        record.type = block.type;
      }
      if (record.code == null) {
        record.code = block.code;
      }
      if (block.graph != null) {
        record.graph = serialize(block.graph);
      }
    }

    const format = function (type) {
      type = type.replace(")(", ")→(");
      return (type = type.replace("()", ""));
    };

    for (outlet of Array.from(node.inputs)) {
      inputs.push({
        id: outlet.id,
        name: outlet.name,
        type: format(outlet.type),
        open: outlet.input == null,
      });
    }

    for (outlet of Array.from(node.outputs)) {
      outputs.push({
        id: outlet.id,
        name: outlet.name,
        type: format(outlet.type),
        open: !outlet.output.length,
      });

      for (const other of Array.from(outlet.output)) {
        links.push({
          from: node.id,
          out: outlet.id,
          to: other.node.id,
          in: other.id,
          type: format(outlet.type),
        });
      }
    }
  }

  return { nodes, links };
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/factory/hash.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// Hash string into a 32-bit key (murmurhash3)
const c1 = 0xcc9e2d51;
const c2 = 0x1b873593;
const c3 = 0xe6546b64;
const c4 = 0x85ebca6b;
const c5 = 0xc2b2ae35;

// Fix imul in old/broken browsers
let imul = function (a, b) {
  const ah = (a >>> 16) & 0xffff;
  const al = a & 0xffff;
  const bh = (b >>> 16) & 0xffff;
  const bl = b & 0xffff;
  return (al * bl + (((ah * bl + al * bh) << 16) >>> 0)) | 0;
};

if (Math.imul != null) {
  const test = Math.imul(0xffffffff, 5);
  if (test === -5) {
    ({ imul } = Math);
  }
}

const hash = function (string) {
  let h;
  const n = string.length;
  let m = Math.floor(n / 2);
  let j = (h = 0);

  const next = () => string.charCodeAt(j++);
  const iterate = function (a, b) {
    let k = a | (b << 16); // two utf-16 words
    k ^= k << 9; // whitening for ascii-only strings

    k = imul(k, c1);
    k = (k << 15) | (k >>> 17);
    k = imul(k, c2);

    h ^= k;

    h = (h << 13) | (h >>> 19);
    h = imul(h, 5);
    return (h = (h + c3) | 0);
  };

  while (m--) {
    iterate(next(), next());
  }
  if (n & 1) {
    iterate(next(), 0);
  }

  h ^= n;
  h ^= h >>> 16;
  h = imul(h, c4);
  h ^= h >>> 13;
  h = imul(h, c5);

  return (h ^= h >>> 16);
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/visualize/markup.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


const trim = (string) => ("" + string).replace(/^\s+|\s+$/g, "");

const cssColor = (r, g, b, alpha) =>
  "rgba(" + [r, g, b, alpha].join(", ") + ")";

const hashColor = function (string, alpha) {
  if (alpha == null) {
    alpha = 1;
  }
  const color = hash(string) ^ 0x123456;

  let r = color & 0xff;
  let g = (color >>> 8) & 0xff;
  let b = (color >>> 16) & 0xff;

  const max = Math.max(r, g, b);
  const norm = 140 / max;
  const min = Math.round(max / 3);

  r = Math.min(255, Math.round(norm * Math.max(r, min)));
  g = Math.min(255, Math.round(norm * Math.max(g, min)));
  b = Math.min(255, Math.round(norm * Math.max(b, min)));

  return cssColor(r, g, b, alpha);
};

const escapeText = function (string) {
  string = string != null ? string : "";
  return string
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/'/g, "&#39;")
    .replace(/"/g, "&quot;");
};

const process = function (data) {
  const links = [];
  const el = _markup(data, links);
  el.update = () => connect(el, links);
  _activate(el);
  return el;
};

const _activate = function (el) {
  const codes = el.querySelectorAll(".shadergraph-code");
  return Array.from(codes).map((code) =>
    (function () {
      const popup = code;
      popup.parentNode.classList.add("shadergraph-has-code");
      return popup.parentNode.addEventListener(
        "click",
        (_event) =>
          (popup.style.display = {
            block: "none",
            none: "block",
          }[popup.style.display || "none"])
      );
    })()
  );
};

const _order = function (data) {
  let link, node;
  const nodeMap = {};
  const linkMap = {};
  for (node of Array.from(data.nodes)) {
    nodeMap[node.id] = node;
  }

  for (link of Array.from(data.links)) {
    if (linkMap[link.from] == null) {
      linkMap[link.from] = [];
    }
    linkMap[link.from].push(link);
  }

  const recurse = function (node, depth) {
    let next;
    if (depth == null) {
      depth = 0;
    }
    node.depth = Math.max(node.depth != null ? node.depth : 0, depth);
    if ((next = linkMap[node.id])) {
      for (link of Array.from(next)) {
        recurse(nodeMap[link.to], depth + 1);
      }
    }
    return null;
  };

  for (node of Array.from(data.nodes)) {
    if (node.depth == null) {
      recurse(node);
    }
  }

  return null;
};

const _markup = function (data, links) {
  let column;
  _order(data);

  const wrapper = document.createElement("div");
  wrapper.classList.add("shadergraph-graph");

  const columns = [];
  const outlets = {};

  for (const node of Array.from(data.nodes)) {
    let outlet;
    const block = document.createElement("div");
    block.classList.add("shadergraph-node");
    block.classList.add(`shadergraph-node-${node.type}`);

    block.innerHTML = `\
<div class="shadergraph-header">${escapeText(node.name)}</div>\
`;

    const addOutlet = function (outlet, inout) {
      const color = hashColor(outlet.type);

      const div = document.createElement("div");
      div.classList.add("shadergraph-outlet");
      div.classList.add(`shadergraph-outlet-${inout}`);
      div.innerHTML = `\
<div class="shadergraph-point" style="background: ${color}"></div>
<div class="shadergraph-type" style="color: ${color}">${escapeText(
        outlet.type
      )}</div>
<div class="shadergraph-name">${escapeText(outlet.name)}</div>\
`;
      block.appendChild(div);

      return (outlets[outlet.id] = div.querySelector(".shadergraph-point"));
    };

    for (outlet of Array.from(node.inputs)) {
      addOutlet(outlet, "in");
    }
    for (outlet of Array.from(node.outputs)) {
      addOutlet(outlet, "out");
    }

    if (node.graph != null) {
      block.appendChild(_markup(node.graph, links));
    } else {
      const clear = document.createElement("div");
      clear.classList.add("shadergraph-clear");
      block.appendChild(clear);
    }

    if (node.code != null) {
      const div = document.createElement("div");
      div.classList.add("shadergraph-code");
      div.innerHTML = escapeText(trim(node.code));
      block.appendChild(div);
    }

    column = columns[node.depth];
    if (column == null) {
      column = document.createElement("div");
      column.classList.add("shadergraph-column");
      columns[node.depth] = column;
    }
    column.appendChild(block);
  }

  for (column of Array.from(columns)) {
    if (column != null) {
      wrapper.appendChild(column);
    }
  }

  for (const link of Array.from(data.links)) {
    const color = hashColor(link.type);

    links.push({
      color,
      out: outlets[link.out],
      in: outlets[link.in],
    });
  }

  return wrapper;
};

const sqr = (x) => x * x;

const path = function (x1, y1, x2, y2) {
  let h;
  const dx = x2 - x1;
  const dy = y2 - y1;
  const d = Math.sqrt(sqr(dx) + sqr(dy));

  const vert = Math.abs(dy) > Math.abs(dx);
  if (vert) {
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;

    const f = dy > 0 ? 0.3 : -0.3;
    h = Math.min(Math.abs(dx) / 2, 20 + d / 8);

    return [
      "M",
      x1,
      y1,
      "C",
      x1 + h,
      y1 + ",",
      mx,
      my - d * f,
      mx,
      my,
      "C",
      mx,
      my + d * f,
      x2 - h,
      y2 + ",",
      x2,
      y2,
    ].join(" ");
  } else {
    h = Math.min(Math.abs(dx) / 2.5, 20 + d / 4);

    return ["M", x1, y1, "C", x1 + h, y1 + ",", x2 - h, y2 + ",", x2, y2].join(
      " "
    );
  }
};

const makeSVG = function (tag) {
  if (tag == null) {
    tag = "svg";
  }
  return document.createElementNS("http://www.w3.org/2000/svg", tag);
};

const connect = function (element, links) {
  let link;
  if (element.parentNode == null) {
    return;
  }

  const ref = element.getBoundingClientRect();

  for (link of Array.from(links)) {
    const a = link.out.getBoundingClientRect();
    const b = link.in.getBoundingClientRect();

    link.coords = {
      x1: (a.left + a.right) / 2 - ref.left,
      y1: (a.top + a.bottom) / 2 - ref.top,
      x2: (b.left + b.right) / 2 - ref.left,
      y2: (b.top + b.bottom) / 2 - ref.top,
    };
  }

  let svg = element.querySelector("svg");
  if (svg != null) {
    element.removeChild(svg);
  }

  let box = element;
  while (box.parentNode && box.offsetHeight === 0) {
    box = box.parentNode;
  }

  svg = makeSVG();
  svg.setAttribute("width", box.offsetWidth);
  svg.setAttribute("height", box.offsetHeight);

  for (link of Array.from(links)) {
    const c = link.coords;

    const line = makeSVG("path");
    line.setAttribute("d", path(c.x1, c.y1, c.x2, c.y2));
    line.setAttribute("stroke", link.color);
    line.setAttribute("stroke-width", 3);
    line.setAttribute("fill", "transparent");
    svg.appendChild(line);
  }

  return element.appendChild(svg);
};

const overlay = function (contents) {
  const div = document.createElement("div");
  div.setAttribute("class", "shadergraph-overlay");

  const close = document.createElement("div");
  close.setAttribute("class", "shadergraph-close");
  close.innerHTML = "&times;";

  const view = document.createElement("div");
  view.setAttribute("class", "shadergraph-view");

  const inside = document.createElement("div");
  inside.setAttribute("class", "shadergraph-inside");

  inside.appendChild(contents);
  view.appendChild(inside);
  div.appendChild(view);
  div.appendChild(close);

  close.addEventListener("click", () => div.parentNode.removeChild(div));

  return div;
};

const wrap = function (markup) {
  if (markup instanceof Node) {
    return markup;
  }
  const p = document.createElement("span");
  p.innerText = markup != null ? markup : "";
  return p;
};

const markup_merge = function (markup) {
  if (markup.length !== 1) {
    let el;
    const div = document.createElement("div");
    for (el of Array.from(markup)) {
      div.appendChild(wrap(el));
    }
    div.update = () =>
      (() => {
        const result = [];
        for (el of Array.from(markup)) {
          result.push(
            typeof el.update === "function" ? el.update() : undefined
          );
        }
        return result;
      })();
    return div;
  } else {
    return wrap(markup[0]);
  }
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/visualize/index.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




const visualize_serialize = serialize;
const markup = markup_namespaceObject;

const _visualize = function (graph) {
  if (!graph) {
    return;
  }
  if (!graph.nodes) {
    return graph;
  }

  const data = visualize_serialize(graph);
  return markup.process(data);
};

const resolve = function (arg) {
  if (arg == null) {
    return arg;
  }
  if (arg instanceof Array) {
    return arg.map(resolve);
  }
  if (arg.vertex != null && arg.fragment != null) {
    return [resolve(arg.vertex, resolve(arg.fragment))];
  }
  if (arg._graph != null) {
    return arg._graph;
  }
  if (arg.graph != null) {
    return arg.graph;
  }
  return arg;
};

const visualize_merge = function (args) {
  let out = [];
  for (const arg of Array.from(args)) {
    if (arg instanceof Array) {
      out = out.concat(visualize_merge(arg));
    } else if (arg != null) {
      out.push(arg);
    }
  }
  return out;
};

const visualize = function () {
  const list = visualize_merge(resolve([].slice.call(arguments)));
  return markup.merge(
    Array.from(list)
      .filter((graph) => graph)
      .map((graph) => _visualize(graph))
  );
};

const inspect = function () {
  const contents = visualize.apply(null, arguments);
  const element = markup.overlay(contents);

  for (const el of Array.from(
    document.querySelectorAll(".shadergraph-overlay")
  )) {
    el.remove();
  }
  document.body.appendChild(element);
  contents.update();

  return element;
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/factory/factory.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
  Chainable factory

  Exposes methods to build a graph incrementally
*/
class Factory {
  constructor(language, fetch, config) {
    this.language = language;
    this.fetch = fetch;
    this.config = config;
    this.graph();
  }

  // Combined call/concat shortcut
  pipe(name, uniforms, namespace, defines) {
    if (name instanceof Factory) {
      this._concat(name);
    } else if (name != null) {
      this._call(name, uniforms, namespace, defines);
    }
    return this;
  }

  // Old name
  call(name, uniforms, namespace, defines) {
    return this.pipe(name, uniforms, namespace, defines);
  }

  // Combined callback/import shortcut
  require(name, uniforms, namespace, defines) {
    if (name instanceof Factory) {
      this._import(name);
    } else if (name != null) {
      this.callback();
      this._call(name, uniforms, namespace, defines);
      this.end();
    }
    return this;
  }

  // Old name
  import(name, uniforms, namespace, defines) {
    return this.require(name, uniforms, namespace, defines);
  }

  // Create parallel branches that connect as one block to the end
  // (one outgoing connection per outlet)
  split() {
    this._group("_combine", true);
    return this;
  }

  // Create parallel branches that fan out from the end
  // (multiple outgoing connections per outlet)
  fan() {
    this._group("_combine", false);
    return this;
  }

  // Create isolated subgraph
  isolate() {
    this._group("_isolate");
    return this;
  }

  // Create callback subgraph
  callback() {
    this._group("_callback");
    return this;
  }

  // Next branch in group
  next() {
    this._next();
    return this;
  }

  // Connect branches to previous tail and add pass-through from end
  pass() {
    const pass = this._stack[2].end;
    this.end();
    this._state.end = this._state.end.concat(pass);
    return this;
  }

  // Leave nested branches and join up with main graph,
  // applying stored op along the way
  end() {
    const [sub, main] = Array.from(this._exit());
    const { op } = sub;
    if (this[op]) {
      this[op](sub, main);
    }
    return this;
  }

  // Old name
  join() {
    return this.end();
  }

  // Return finalized graph / reset factory
  graph() {
    // Pop remaining stack
    while ((this._stack != null ? this._stack.length : undefined) > 1) {
      this.end();
    }

    // Remember terminating node(s) of graph
    if (this._graph) {
      this._tail(this._state, this._graph);
    }

    const graph = this._graph;

    this._graph = new Graph();
    this._state = new State();
    this._stack = [this._state];

    return graph;
  }

  // Compile shortcut (graph is thrown away)
  compile(namespace) {
    if (namespace == null) {
      namespace = "main";
    }
    return this.graph().compile(namespace);
  }

  // Link shortcut (graph is thrown away)
  link(namespace) {
    if (namespace == null) {
      namespace = "main";
    }
    return this.graph().link(namespace);
  }

  // Serialize for debug
  serialize() {
    return visualize_serialize(this._graph);
  }

  // Return true if empty
  empty() {
    return this._graph.nodes.length === 0;
  }

  // Concatenate existing factory onto tail
  // Retains original factory
  _concat(factory) {
    // Ignore empty concat
    let block;
    if (factory._state.nodes.length === 0) {
      return this;
    }

    this._tail(factory._state, factory._graph);

    try {
      block = new Isolate(factory._graph);
    } catch (error) {
      if (this.config.autoInspect) {
        inspect(error, this._graph, factory);
      }
      throw error;
    }

    this._auto(block);
    return this;
  }

  // Add existing factory as callback
  // Retains original factory
  _import(factory) {
    // Check for empty require
    let block;
    if (factory._state.nodes.length === 0) {
      throw "Can't import empty callback";
    }

    this._tail(factory._state, factory._graph);

    try {
      block = new Callback(factory._graph);
    } catch (error) {
      if (this.config.autoInspect) {
        inspect(error, this._graph, factory);
      }
      throw error;
    }

    this._auto(block);
    return this;
  }

  // Connect parallel branches to tail
  _combine(sub, main) {
    for (const to of Array.from(sub.start)) {
      for (const from of Array.from(main.end)) {
        from.connect(to, sub.multi);
      }
    }

    main.end = sub.end;
    return (main.nodes = main.nodes.concat(sub.nodes));
  }

  // Make subgraph and connect to tail
  _isolate(sub, _main) {
    if (sub.nodes.length) {
      let block;
      const subgraph = this._subgraph(sub);
      this._tail(sub, subgraph);

      try {
        block = new Isolate(subgraph);
      } catch (error) {
        if (this.config.autoInspect) {
          inspect(error, this._graph, subgraph);
        }
        throw error;
      }

      return this._auto(block);
    }
  }

  // Convert to callback and connect to tail
  _callback(sub, _main) {
    if (sub.nodes.length) {
      let block;
      const subgraph = this._subgraph(sub);
      this._tail(sub, subgraph);

      try {
        block = new Callback(subgraph);
      } catch (error) {
        if (this.config.autoInspect) {
          inspect(error, this._graph, subgraph);
        }
        throw error;
      }

      return this._auto(block);
    }
  }

  // Create next call block
  _call(name, uniforms, namespace, defines) {
    const snippet = this.fetch(name);
    snippet.bind(this.config, uniforms, namespace, defines);
    const block = new Call(snippet);
    return this._auto(block);
  }

  // Move current state into subgraph
  _subgraph(sub) {
    const subgraph = new Graph(null, this._graph);
    subgraph.adopt(sub.nodes);
    return subgraph;
  }

  // Finalize graph tail
  _tail(state, graph) {
    // Merge (unique) terminating ends into single tail node if needed
    let tail = state.end.concat(state.tail);
    tail = tail.filter((node, i) => tail.indexOf(node) === i);

    if (tail.length > 1) {
      tail = new join_Join(tail);
      tail = [tail.node];
      this._graph.add(tail);
    }

    // Save single endpoint
    graph.tail = tail[0];
    state.end = tail;
    state.tail = [];

    if (!graph.tail) {
      throw new Error("Cannot finalize empty graph");
    }

    // Add compile/link/export/inspect shortcut methods
    graph.compile = (namespace) => {
      if (namespace == null) {
        namespace = "main";
      }
      try {
        return graph.tail.owner.compile(this.language, namespace);
      } catch (error) {
        if (this.config.autoInspect) {
          graph.inspect(error);
        }
        throw error;
      }
    };

    graph.link = (namespace) => {
      if (namespace == null) {
        namespace = "main";
      }
      try {
        return graph.tail.owner.link(this.language, namespace);
      } catch (error) {
        if (this.config.autoInspect) {
          graph.inspect(error);
        }
        throw error;
      }
    };

    graph.export = (layout, depth) => {
      return graph.tail.owner.export(layout, depth);
    };

    return (graph.inspect = (message = null) =>
      inspect(message, graph));
  }

  // Create group for branches or callbacks
  _group(op, multi) {
    this._push(op, multi); // Accumulator
    this._push(); // Current
    return this;
  }

  // Merge branch into accumulator and reset state
  _next() {
    const sub = this._pop();

    this._state.start = this._state.start.concat(sub.start);
    this._state.end = this._state.end.concat(sub.end);
    this._state.nodes = this._state.nodes.concat(sub.nodes);
    this._state.tail = this._state.tail.concat(sub.tail);

    return this._push();
  }

  // Exit nested branches
  _exit() {
    this._next();
    this._pop();
    return [this._pop(), this._state];
  }

  // State stack
  _push(op, multi) {
    this._stack.unshift(new State(op, multi));
    return (this._state = this._stack[0]);
  }

  _pop() {
    let left;
    this._state = this._stack[1];
    if (this._state == null) {
      this._state = new State();
    }
    return (left = this._stack.shift()) != null ? left : new State();
  }

  // Auto append or insert depending on whether we have inputs
  _auto(block) {
    if (block.node.inputs.length) {
      return this._append(block);
    } else {
      return this._insert(block);
    }
  }

  // Add block and connect to end
  _append(block) {
    let end;
    const { node } = block;
    this._graph.add(node);

    for (end of Array.from(this._state.end)) {
      end.connect(node);
    }

    if (!this._state.start.length) {
      this._state.start = [node];
    }
    this._state.end = [node];

    this._state.nodes.push(node);
    if (!node.outputs.length) {
      this._state.tail.push(node);
    }
  }

  // Add block and connect to start
  _prepend(block) {
    let start;
    const { node } = block;
    this._graph.add(node);

    for (start of Array.from(this._state.start)) {
      node.connect(start);
    }

    if (!this._state.end.length) {
      this._state.end = [node];
    }
    this._state.start = [node];

    this._state.nodes.push(node);
    if (!node.outputs.length) {
      this._state.tail.push(node);
    }
  }

  // Insert loose block
  _insert(block) {
    const { node } = block;
    this._graph.add(node);

    this._state.start.push(node);
    this._state.end.push(node);

    this._state.nodes.push(node);
    if (!node.outputs.length) {
      return this._state.tail.push(node);
    }
  }
}

class State {
  constructor(op = null, multi, start, end, nodes, tail) {
    this.op = op;
    if (multi == null) {
      multi = false;
    }
    this.multi = multi;
    if (start == null) {
      start = [];
    }
    this.start = start;
    if (end == null) {
      end = [];
    }
    this.end = end;
    if (nodes == null) {
      nodes = [];
    }
    this.nodes = nodes;
    if (tail == null) {
      tail = [];
    }
    this.tail = tail;
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/factory/material.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



const material_debug = false;

const tick = function () {
  const now = +new Date();
  return function (label) {
    const delta = +new Date() - now;
    console.log(label, delta + " ms");
    return delta;
  };
};

class Material {
  constructor(vertex, fragment) {
    this.vertex = vertex;
    this.fragment = fragment;
    if (material_debug) {
      this.tock = tick();
    }
  }

  build(options) {
    return this.link(options);
  }

  link(options) {
    if (options == null) {
      options = {};
    }
    const uniforms = {};
    const varyings = {};
    const attributes = {};

    const vertex = this.vertex.link("main");
    const fragment = this.fragment.link("main");

    for (const shader of [vertex, fragment]) {
      for (const key in shader.uniforms) {
        const value = shader.uniforms[key];
        uniforms[key] = value;
      }
      for (const key in shader.varyings) {
        const value = shader.varyings[key];
        varyings[key] = value;
      }
      for (const key in shader.attributes) {
        const value = shader.attributes[key];
        attributes[key] = value;
      }
    }

    options.vertexShader = vertex.code;
    options.vertexGraph = vertex.graph;
    options.fragmentShader = fragment.code;
    options.fragmentGraph = fragment.graph;
    options.attributes = attributes;
    options.uniforms = uniforms;
    options.varyings = varyings;
    options.inspect = () =>
      inspect(
        "Vertex Shader",
        vertex,
        "Fragment Shader",
        fragment.graph
      );

    if (material_debug) {
      this.tock("Material build");
    }

    return options;
  }

  inspect() {
    return inspect(
      "Vertex Shader",
      this.vertex,
      "Fragment Shader",
      this.fragment.graph
    );
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/factory/library.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
  Snippet library

  Takes:
    - Hash of snippets: named library
    - (name) -> getter: dynamic lookup
    - nothing:          no library, only pass in inline source code

  If 'name' contains any of "{;(#" it is assumed to be direct GLSL code.
*/
const library = function (language, snippets, load) {
  let callback = null;
  let used = {};

  if (snippets != null) {
    if (typeof snippets === "function") {
      callback = (name) => load(language, name, snippets(name));
    } else if (typeof snippets === "object") {
      callback = function (name) {
        if (snippets[name] == null) {
          throw new Error(`Unknown snippet \`${name}\``);
        }
        return load(language, name, snippets[name]);
      };
    }
  }

  const inline = (code) => load(language, "", code);

  if (callback == null) {
    return inline;
  }

  const fetch = function (name) {
    if (name.match(/[{;]/)) {
      return inline(name);
    }
    used[name] = true;
    return callback(name);
  };

  fetch.used = function (_used) {
    if (_used == null) {
      _used = used;
    }
    return (used = _used);
  };

  return fetch;
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/factory/queue.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// Least-recently-used queue for key expiry via linked list
const queue = function (limit) {
  if (limit == null) {
    limit = 100;
  }
  const map = {};

  let head = null;
  let tail = null;
  let count = 0;

  // Insert at front
  const add = function (item) {
    item.prev = null;
    item.next = head;

    if (head != null) {
      head.prev = item;
    }

    head = item;
    if (tail == null) {
      return (tail = item);
    }
  };

  // Remove from list
  const remove = function (item) {
    const { prev } = item;
    const { next } = item;

    if (prev != null) {
      prev.next = next;
    }
    if (next != null) {
      next.prev = prev;
    }

    if (head === item) {
      head = next;
    }
    if (tail === item) {
      return (tail = prev);
    }
  };

  // Push key to top of list
  return function (key) {
    let dead, item;
    if ((item = map[key]) && item !== head) {
      // Already in queue
      remove(item);
      add(item);
    } else {
      // Check capacity
      if (count === limit) {
        // Pop tail
        dead = tail.key;
        remove(tail);

        // Expire key
        delete map[dead];
      } else {
        count++;
      }

      // Replace head
      item = { next: head, prev: null, key };
      add(item);

      // Map record for lookup
      map[key] = item;
    }

    // Return expired key
    return dead;
  };
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/factory/cache.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
  Cache decorator
  Fetches snippets once, clones for reuse
  Inline code is hashed to avoid bloat
*/



const cache = function (fetch) {
  const cached = {};
  const push = queue(100);

  // Snippet factory
  return function (name) {
    const key = name.length > 32 ? "##" + hash(name).toString(16) : name;

    // Push new key onto queue, see if an old key expired
    const expire = push(key);
    if (expire != null) {
      delete cached[expire];
    }

    // Clone cached snippet
    if (cached[key] == null) {
      cached[key] = fetch(name);
    }
    return cached[key].clone();
  };
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/factory/index.js








;// CONCATENATED MODULE: ./node_modules/shadergraph/src/glsl/compile.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
/*
  Compile snippet back into GLSL, but with certain symbols replaced by prefixes / placeholders
*/

const compile_compile = function (program) {
  const { code, signatures } = program;

  // Prepare list of placeholders
  const placeholders = replaced(signatures);

  // Compile
  const assembler = string_compiler(code, placeholders);

  return [signatures, assembler];
};

const replaced = function (signatures) {
  const out = {};
  const s = (sig) => (out[sig.name] = true);

  s(signatures.main);

  // Prefix all global symbols
  for (const key of [
    "external",
    "internal",
    "varying",
    "uniform",
    "attribute",
  ]) {
    for (const sig of signatures[key]) {
      s(sig);
    }
  }

  return out;
};

/*
String-replacement based compiler
*/
const string_compiler = function (code, placeholders) {
  // Make regexp for finding placeholders
  // Replace on word boundaries
  let key;
  const re = new RegExp(
    "\\b(" +
      (() => {
        const result = [];
        for (key in placeholders) {
          result.push(key);
        }
        return result;
      })().join("|") +
      ")\\b",
    "g"
  );

  // Strip comments
  code = code.replace(/\/\/[^\n]*/g, "");
  code = code.replace(/\/\*([^*]|\*[^/])*\*\//g, "");

  // Strip all preprocessor commands (lazy)
  //code = code.replace /^#[^\n]*/mg, ''

  // Assembler function that takes namespace prefix and exceptions
  // and returns GLSL source code
  return function (prefix, exceptions, defines) {
    let key;
    if (prefix == null) {
      prefix = "";
    }
    if (exceptions == null) {
      exceptions = {};
    }
    if (defines == null) {
      defines = {};
    }
    const replace = {};
    for (key in placeholders) {
      replace[key] = exceptions[key] != null ? key : prefix + key;
    }

    const compiled = code.replace(re, (key) => replace[key]);

    const defs = (() => {
      const result1 = [];
      for (key in defines) {
        const value = defines[key];
        result1.push(`#define ${key} ${value}`);
      }
      return result1;
    })();
    if (defs.length) {
      defs.push("");
    }
    return defs.join("\n") + compiled;
  };
};

// EXTERNAL MODULE: ./node_modules/glsl-tokenizer/string.js
var string = __webpack_require__(9932);
var string_default = /*#__PURE__*/__webpack_require__.n(string);
// EXTERNAL MODULE: ./node_modules/@sicmutils/glsl-parser/direct.js
var direct = __webpack_require__(3036);
var direct_default = /*#__PURE__*/__webpack_require__.n(direct);
;// CONCATENATED MODULE: ./node_modules/three/src/math/Vector2.js
class Vector2 {

	constructor( x = 0, y = 0 ) {

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

Vector2.prototype.isVector2 = true;



;// CONCATENATED MODULE: ./node_modules/three/src/math/MathUtils.js
const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function MathUtils_clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}





;// CONCATENATED MODULE: ./node_modules/three/src/math/Quaternion.js


class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( MathUtils_clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt( 1 - u1 );
		const sqrtu1 = Math.sqrt( u1 );

		const u2 = 2 * Math.PI * Math.random();

		const u3 = 2 * Math.PI * Math.random();

		return this.set(
			sqrt1u1 * Math.cos( u2 ),
			sqrtu1 * Math.sin( u3 ),
			sqrtu1 * Math.cos( u3 ),
			sqrt1u1 * Math.sin( u2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;



;// CONCATENATED MODULE: ./node_modules/three/src/math/Vector3.js



class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( MathUtils_clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = ( Math.random() - 0.5 ) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt( 1 - u ** 2 );

		this.x = f * Math.cos( t );
		this.y = f * Math.sin( t );
		this.z = u;

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

Vector3.prototype.isVector3 = true;

const _vector = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();



;// CONCATENATED MODULE: ./node_modules/three/src/math/Vector4.js
class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

Vector4.prototype.isVector4 = true;



;// CONCATENATED MODULE: ./node_modules/three/src/math/Matrix3.js
class Matrix3 {

	constructor() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

Matrix3.prototype.isMatrix3 = true;



;// CONCATENATED MODULE: ./node_modules/three/src/math/Matrix4.js


class Matrix4_Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4_Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4_Matrix4.prototype.isMatrix4 = true;

const _v1 = /*@__PURE__*/ new Vector3();
const _m1 = /*@__PURE__*/ new Matrix4_Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();



;// CONCATENATED MODULE: ./node_modules/shadergraph/src/glsl/decl.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// AST node parsers







const decl = {};

decl.in = 0;
decl.out = 1;
decl.inout = 2;

const get = (n) => n.token.data;

decl.node = function (node) {
  if (
    (node.children[5] != null ? node.children[5].type : undefined) ===
    "function"
  ) {
    return decl.function(node);
  } else if ((node.token != null ? node.token.type : undefined) === "keyword") {
    return decl.external(node);
  }
};

decl.external = function (node) {
  //    console.log 'external', node
  let c = node.children;

  let storage = get(c[1]);
  const type = get(c[4]);
  const list = c[5];

  if (!["attribute", "uniform", "varying"].includes(storage)) {
    storage = "global";
  }

  const out = [];

  for (let i = 0; i < list.children.length; i++) {
    c = list.children[i];
    if (c.type === "ident") {
      const ident = get(c);
      const next = list.children[i + 1];
      const quant = (next != null ? next.type : undefined) === "quantifier";

      out.push({
        decl: "external",
        storage,
        type,
        ident,
        quant: !!quant,
        count: quant,
      });
    }
  }

  return out;
};

decl.function = function (node) {
  const c = node.children;

  //    console.log 'function', node

  const storage = get(c[1]);
  const type = get(c[4]);
  const func = c[5];
  const ident = get(func.children[0]);
  const args = func.children[1];
  const body = func.children[2];

  const decls = Array.from(args.children).map((child) => decl.argument(child));

  return [
    {
      decl: "function",
      storage,
      type,
      ident,
      body: !!body,
      args: decls,
    },
  ];
};

decl.argument = function (node) {
  const c = node.children;

  //    console.log 'argument', node

  const storage = get(c[1]);
  const inout = get(c[2]);
  const type = get(c[4]);
  const list = c[5];
  const ident = get(list.children[0]);
  const quant = list.children[1];

  const count = quant ? quant.children[0].token.data : undefined;

  return {
    decl: "argument",
    storage,
    inout,
    type,
    ident,
    quant: !!quant,
    count,
  };
};

decl.param = function (dir, storage, spec, quant, count) {
  let prefix = [];
  if (storage != null) {
    prefix.push(storage);
  }
  if (spec != null) {
    prefix.push(spec);
  }
  prefix.push("");

  prefix = prefix.join(" ");
  const suffix = quant ? "[" + count + "]" : "";
  if (dir !== "") {
    dir += " ";
  }

  const f = (name, long) => (long ? dir : "") + `${prefix}${name}${suffix}`;
  f.split = (dir) => decl.param(dir, storage, spec, quant, count);

  return f;
};

// Three.js sugar
const win = typeof window !== "undefined";
const threejs = win && !!window.THREE;

const defaults = {
  int: 0,
  float: 0,
  vec2: threejs ? Vector2 : null,
  vec3: threejs ? Vector3 : null,
  vec4: threejs ? Vector4 : null,
  mat2: null,
  mat3: threejs ? Matrix3 : null,
  mat4: threejs ? Matrix4_Matrix4 : null,
  sampler2D: 0,
  samplerCube: 0,
};

const three = {
  int: "i",
  float: "f",
  vec2: "v2",
  vec3: "v3",
  vec4: "v4",
  mat2: "m2",
  mat3: "m3",
  mat4: "m4",
  sampler2D: "t",
  samplerCube: "t",
};

decl.type = function (name, spec, quant, count, dir, storage) {
  const dirs = {
    in: decl.in,
    out: decl.out,
    inout: decl.inout,
  };

  const storages = { const: "const" };

  let type = three[spec];
  if (quant) {
    type += "v";
  }

  let value = defaults[spec];
  if (value != null ? value.call : undefined) {
    value = new value();
  }
  if (quant) {
    value = [value];
  }

  const inout = dirs[dir] != null ? dirs[dir] : dirs.in;
  storage = storages[storage];

  const param = decl.param(dir, storage, spec, quant, count);
  return new Definition(name, type, spec, param, value, inout);
};

class Definition {
  constructor(name, type, spec, param, value, inout, meta) {
    this.name = name;
    this.type = type;
    this.spec = spec;
    this.param = param;
    this.value = value;
    this.inout = inout;
    this.meta = meta;
  }

  split() {
    // Split inouts
    const isIn = this.meta.shadowed != null;
    const dir = isIn ? "in" : "out";
    const inout = isIn ? decl.in : decl.out;
    const param = this.param.split(dir);
    return new Definition(
      this.name,
      this.type,
      this.spec,
      param,
      this.value,
      inout
    );
  }

  copy(name, meta) {
    return new Definition(
      name != null ? name : this.name,
      this.type,
      this.spec,
      this.param,
      this.value,
      this.inout,
      meta
    );
  }
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/glsl/constants.js
const SHADOW_ARG = "_i_o";
const RETURN_ARG = "return";

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/glsl/parse.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS201: Simplify complex destructure assignments
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */





let parse_debug = false;

/*
parse GLSL into AST
extract all global symbols and make type signatures
*/
// Parse a GLSL snippet
const parse = function (name, code) {
  const ast = parseGLSL(name, code);
  return processAST(ast, code);
};

// Parse GLSL language into AST
const parseGLSL = function (name, code) {
  let ast, tock;
  let errors = [];
  if (parse_debug) {
    tock = parse_tick();
  }

  try {
    const tokens = string_default()(code);
    ast = direct_default()(tokens);
  } catch (e) {
    errors = [{ message: e }];
  }

  if (parse_debug) {
    tock("GLSL Tokenize & Parse");
  }

  const fmt = function (code) {
    code = code.split("\n");
    const max = ("" + code.length).length;
    const pad = function (v) {
      if ((v = "" + v).length < max) {
        return ("       " + v).slice(-max);
      } else {
        return v;
      }
    };
    return code.map((line, i) => `${pad(i + 1)}: ${line}`).join("\n");
  };

  if (!ast || errors.length) {
    if (!name) {
      name = "(inline code)";
    }
    console.warn(fmt(code));
    for (const error of errors) {
      console.error(`${name} -`, error.message);
    }
    throw new Error("GLSL parse error");
  }

  return ast;
};

// Process AST for compilation
const processAST = function (ast, code) {
  let tock;
  if (parse_debug) {
    tock = parse_tick();
  }

  // Walk AST tree and collect global declarations
  const symbols = [];
  walk(mapSymbols, collect(symbols), ast, "");

  // Sort symbols into bins
  const [main, internals, externals] = Array.from(sortSymbols(symbols));

  // Extract storage/type signatures of symbols
  const signatures = extractSignatures(main, internals, externals);

  if (parse_debug) {
    tock("GLSL AST");
  }

  return { ast, code, signatures };
};

// Extract functions and external symbols from AST
const mapSymbols = function (node, collect) {
  switch (node.type) {
    case "decl":
      collect(decl.node(node));
      return false;
  }
  return true;
};

const collect = (out) =>
  function (value) {
    if (value != null) {
      Array.from(value).map((obj) => out.push(obj));
    }
  };

// Identify internals, externals and main function
const sortSymbols = function (symbols) {
  let main = null;
  const internals = [];
  let externals = [];
  const maybe = {};
  let found = false;

  for (const s of Array.from(symbols)) {
    if (!s.body) {
      // Unmarked globals are definitely internal
      if (s.storage === "global") {
        internals.push(s);

        // Possible external
      } else {
        externals.push(s);
        maybe[s.ident] = true;
      }
    } else {
      // Remove earlier forward declaration
      if (maybe[s.ident]) {
        externals = Array.from(externals).filter((e) => e.ident !== s.ident);
        delete maybe[s.ident];
      }

      // Internal function
      internals.push(s);

      // Last function is main
      // unless there is a function called 'main'
      if (s.ident === "main") {
        main = s;
        found = true;
      } else if (!found) {
        main = s;
      }
    }
  }

  return [main, internals, externals];
};

// Generate type signatures and appropriate ins/outs
const extractSignatures = function (main, internals, externals) {
  let symbol;
  const sigs = {
    uniform: [],
    attribute: [],
    varying: [],
    external: [],
    internal: [],
    global: [],
    main: null,
  };

  const defn = (symbol) =>
    decl.type(
      symbol.ident,
      symbol.type,
      symbol.quant,
      symbol.count,
      symbol.inout,
      symbol.storage
    );

  const func = function (symbol, inout) {
    let d;
    const signature = Array.from(symbol.args).map((arg) => defn(arg));

    // Split inouts into in and out
    for (d of Array.from(signature)) {
      if (d.inout === decl.inout) {
        const a = d;
        const b = d.copy();

        a.inout = decl["in"];
        b.inout = decl.out;
        b.meta = { shadow: a.name };
        b.name += SHADOW_ARG;
        a.meta = { shadowed: b.name };

        signature.push(b);
      }
    }

    // Add output for return type
    if (symbol.type !== "void") {
      signature.unshift(decl.type(RETURN_ARG, symbol.type, false, "", "out"));
    }

    // Make type string
    const inTypes = (() => {
      const result = [];
      for (d of Array.from(signature)) {
        if (d.inout === decl["in"]) {
          result.push(d.type);
        }
      }
      return result;
    })().join(",");
    const outTypes = (() => {
      const result1 = [];
      for (d of Array.from(signature)) {
        if (d.inout === decl.out) {
          result1.push(d.type);
        }
      }
      return result1;
    })().join(",");
    const type = `(${inTypes})(${outTypes})`;

    return {
      name: symbol.ident,
      type,
      signature,
      inout,
      spec: symbol.type,
    };
  };

  // Main
  sigs.main = func(main, decl.out);

  // Internals (for name replacement only)
  for (symbol of Array.from(internals)) {
    sigs.internal.push({
      name: symbol.ident,
    });
  }

  // Externals
  for (symbol of Array.from(externals)) {
    let def;
    switch (symbol.decl) {
      // Uniforms/attributes/varyings
      case "external":
        def = defn(symbol);
        sigs[symbol.storage].push(def);
        break;

      // Callbacks
      case "function":
        def = func(symbol, decl["in"]);
        sigs.external.push(def);
        break;
    }
  }

  return sigs;
};

// Walk AST, apply map and collect values
parse_debug = false;

const walk = function (map, collect, node, indent) {
  parse_debug &&
    console.log(
      indent,
      node.type,
      node.token != null ? node.token.data : undefined,
      node.token != null ? node.token.type : undefined
    );

  const recurse = map(node, collect);

  if (recurse) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      walk(map, collect, child, indent + "  ", parse_debug);
    }
  }

  return null;
};

// #####

const parse_tick = function () {
  const now = +new Date();
  return function (label) {
    const delta = +new Date() - now;
    console.log(label, delta + " ms");
    return delta;
  };
};

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/glsl/generate.js
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */




/*
  GLSL code generator for compiler and linker stubs
*/

// Check if shadow outlet
function unshadow(name) {
  const real = name.replace(SHADOW_ARG, "");
  if (real !== name) {
    return real;
  } else {
    return null;
  }
}

// Line joiners
function lines(lines) {
  return lines.join("\n");
}
function list(lines) {
  return lines.join(", ");
}
function statements(lines) {
  return lines.join(";\n");
}

// Function body
function body(entry) {
  return {
    entry,
    type: "void",
    params: [],
    signature: [],
    return: "",
    vars: {},
    calls: [],
    post: [],
    chain: {},
  };
}

// Symbol define
function generate_define(a, b) {
  return `#define ${a} ${b}`;
}

// Function define
function fn(type, entry, params, vars, calls) {
  return `${type} ${entry}(${params}) {\n${vars}${calls}}`;
}

// Function invocation
function invoke(ret, entry, args) {
  ret = ret ? `${ret} = ` : "";
  args = list(args);
  return `  ${ret}${entry}(${args})`;
}

// Compare two signatures
function same(a, b) {
  for (let i = 0; i < a.length; i++) {
    const A = a[i];
    const B = b[i];
    if (!B) {
      return false;
    }
    if (A.type !== B.type) {
      return false;
    }
    if ((A.name === RETURN_ARG) !== (B.name === RETURN_ARG)) {
      return false;
    }
  }
  return true;
}

// Generate call signature for module invocation
function call(lookup, dangling, entry, signature, body) {
  const args = [];
  let ret = "";

  for (let arg of Array.from(signature)) {
    let id, shadow;
    const { name } = arg;

    let copy = (id = lookup(name));
    let other = null;
    let meta = null;
    let omit = false;

    const isReturn = name === RETURN_ARG;

    // Shadowed inout: input side
    if ((shadow = arg.meta != null ? arg.meta.shadowed : undefined)) {
      other = lookup(shadow);
      if (other) {
        body.vars[other] = "  " + arg.param(other);
        body.calls.push(`  ${other} = ${id}`);

        if (!dangling(shadow)) {
          arg = arg.split();
        } else {
          meta = { shadowed: other };
        }
      }
    }

    // Shadowed inout: output side
    if ((shadow = arg.meta != null ? arg.meta.shadow : undefined)) {
      other = lookup(shadow);
      if (other) {
        if (!dangling(shadow)) {
          arg = arg.split();
          omit = true;
        } else {
          meta = { shadow: other };
          continue;
        }
      }
    }

    if (isReturn) {
      // Capture return value
      ret = id;
    } else if (!omit) {
      // Pass all non return, non shadow args in
      args.push(other != null ? other : id);
    }

    // Export argument if unconnected
    if (dangling(name)) {
      let op = "push";
      if (isReturn) {
        if (body.return === "") {
          op = "unshift";
          // Preserve 'return' arg name
          copy = name;
          body.type = arg.spec;
          body.return = `  return ${id}`;
          body.vars[id] = "  " + arg.param(id);
        } else {
          body.vars[id] = "  " + arg.param(id);
          body.params.push(arg.param(id, true));
        }
      } else {
        body.params.push(arg.param(id, true));
      }

      // Copy argument into new signature
      arg = arg.copy(copy, meta);
      body.signature[op](arg);
    } else {
      body.vars[id] = "  " + arg.param(id);
    }
  }

  return body.calls.push(invoke(ret, entry, args));
}

// Assemble main() function from body and call reference
function build(body, calls) {
  const { entry } = body;
  let code = null;

  // Check if we're only calling one snippet with identical signature
  // and not building void main();
  if (calls && calls.length === 1 && entry !== "main") {
    const b = calls[0].module;

    if (same(body.signature, b.main.signature)) {
      code = generate_define(entry, b.entry);
    }
  }

  // Otherwise build function body
  if (code == null) {
    let vars = (() => {
      const result = [];
      for (const v in body.vars) {
        const decl = body.vars[v];
        result.push(decl);
      }
      return result;
    })();
    ({ calls } = body);
    const { post } = body;
    let { params } = body;
    const { type } = body;
    const ret = body.return;

    calls = calls.concat(post);
    if (ret !== "") {
      calls.push(ret);
    }
    calls.push("");

    if (vars.length) {
      vars.push("");
      vars = statements(vars) + "\n";
    } else {
      vars = "";
    }

    calls = statements(calls);
    params = list(params);

    code = fn(type, entry, params, vars, calls);
  }

  return {
    signature: body.signature,
    code,
    name: entry,
  };
}

// Build links to other callbacks
function links(links) {
  const out = {
    defs: [],
    bodies: [],
  };

  for (const l of Array.from(links)) {
    generate_link(l, out);
  }

  out.defs = lines(out.defs);
  out.bodies = statements(out.bodies);

  if (out.defs === "") {
    delete out.defs;
  }
  if (out.bodies === "") {
    delete out.bodies;
  }

  return out;
}

// Link a module's entry point as a callback
const generate_link = (link, out) => {
  let arg, list;
  const { module, name, external } = link;
  const { main } = module;
  const { entry } = module;

  // If signatures match, #define alias for the symbol
  if (same(main.signature, external.signature)) {
    return out.defs.push(generate_define(name, entry));
  }

  // Signatures differ, build one-line callback to match defined prototype

  // Map names to names
  const ins = [];
  const outs = [];
  let map = {};
  const returnVar = [module.namespace, RETURN_ARG].join("");

  for (arg of Array.from(external.signature)) {
    list = arg.inout === IN ? ins : outs;
    list.push(arg);
  }

  for (arg of Array.from(main.signature)) {
    list = arg.inout === IN ? ins : outs;
    const other = list.shift();
    let _name = other.name;

    // Avoid 'return' keyword
    if (_name === RETURN_ARG) {
      _name = returnVar;
    }

    map[arg.name] = _name;
  }

  // Build function prototype to invoke the other side
  let _lookup = (name) => map[name];
  const _dangling = () => true;

  const inner = body();
  call(_lookup, _dangling, entry, main.signature, inner);
  inner.entry = entry;

  // Avoid 'return' keyword
  map = { return: returnVar };
  _lookup = (name) => (map[name] != null ? map[name] : name);

  // Build wrapper function for the calling side
  const outer = body();
  call(_lookup, _dangling, entry, external.signature, outer);

  outer.calls = inner.calls;
  outer.entry = name;

  out.bodies.push(build(inner).code.split(" {")[0]);
  return out.bodies.push(build(outer).code);
};

// Remove all function prototypes to avoid redefinition errors
function defuse(code) {
  // Don't try this at home kids
  const re =
    /([A-Za-z0-9_]+\s+)?[A-Za-z0-9_]+\s+[A-Za-z0-9_]+\s*\([^)]*\)\s*;\s*/gm;
  const strip = (code) => code.replace(re, (_m) => "");

  // Split into scopes by braces
  const blocks = code.split(/(?=[{}])/g);
  let level = 0;
  for (let i = 0; i < blocks.length; i++) {
    const b = blocks[i];
    switch (b[0]) {
      case "{":
        level++;
        break;
      case "}":
        level--;
        break;
    }

    // Only mess with top level scope
    if (level === 0) {
      // Preprocessor lines will fuck us up. Split on them.
      const hash = b.split(/^[ \t]*#/m);
      for (let j = 0; j < hash.length; j++) {
        let line = hash[j];
        if (j > 0) {
          // Trim off preprocessor directive
          line = line.split(/\n/);
          const head = line.shift();
          const rest = line.join("\n");

          // Process rest
          hash[j] = [head, strip(rest)].join("\n");
        } else {
          // Process entire line
          hash[j] = strip(line);
        }
      }

      // Reassemble
      blocks[i] = hash.join("#");
    }
  }

  return (code = blocks.join(""));
}

// Remove duplicate uniforms / varyings / attributes
function dedupe(code) {
  const map = {};
  const re =
    /((attribute|uniform|varying)\s+)[A-Za-z0-9_]+\s+([A-Za-z0-9_]+)\s*(\[[^\]]*\]\s*)?;\s*/gm;
  return code.replace(re, function (m, qual, type, name, _struct) {
    if (map[name]) {
      return "";
    }
    map[name] = true;
    return m;
  });
}

// Move definitions to top so they compile properly
function hoist(code) {
  const filter = function (lines, re) {
    const defs = [];
    const out = [];
    for (const line of Array.from(lines)) {
      const list = line.match(re) ? defs : out;
      list.push(line);
    }

    return defs.concat(out);
  };

  let lines = code.split("\n");

  // Hoist symbol defines to the top so (re)definitions use the right alias
  lines = filter(lines, /^#define ([^ ]+ _pg_[0-9]+_|_pg_[0-9]+_ [^ ]+)$/);

  // Hoist extensions
  lines = filter(lines, /^#extension/);

  return lines.join("\n");
}

;// CONCATENATED MODULE: ./node_modules/shadergraph/src/glsl/index.js





;// CONCATENATED MODULE: ./node_modules/shadergraph/src/index.js
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */







const { library: src_library, cache: src_cache } = src_factory_namespaceObject;
const { visualize: src_visualize, inspect: src_inspect } = visualize_namespaceObject;
const { Snippet: src_Snippet } = linker_namespaceObject;

const src_merge = function (a, b = {}) {
  const out = {};
  for (let key in a) {
    out[key] = b[key] || a[key];
  }
  return out;
};

class ShaderGraph {
  constructor(snippets, config) {
    const defaults = {
      globalUniforms: false,
      globalVaryings: true,
      globalAttributes: true,
      globals: [],
      autoInspect: false,
    };

    this.config = src_merge(defaults, config);
    this.fetch = src_cache(src_library(src_glsl_namespaceObject, snippets, src_Snippet.load));
  }

  shader(config) {
    if (config == null) {
      config = {};
    }
    const _config = src_merge(this.config, config);
    return new Factory(src_glsl_namespaceObject, this.fetch, _config);
  }

  material(config) {
    return new Material(this.shader(config), this.shader(config));
  }

  inspect(shader) {
    return ShaderGraph.inspect(shader);
  }
  visualize(shader) {
    return ShaderGraph.visualize(shader);
  }

  // Static visualization method
  static inspect(shader) {
    return src_inspect(shader);
  }
  static visualize(shader) {
    return src_visualize(shader);
  }
}

// Expose class hierarchy
ShaderGraph.Block = Block;
ShaderGraph.Factory = src_factory_namespaceObject;
ShaderGraph.GLSL = src_glsl_namespaceObject;
ShaderGraph.Graph = src_graph_namespaceObject;
ShaderGraph.Linker = linker_namespaceObject;
ShaderGraph.Visualize = visualize_namespaceObject;

function src_load(snippets, config = {}) {
  return new ShaderGraph(snippets, config);
}

;// CONCATENATED MODULE: ./src/shaders/factory.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



const factory_Factory = function (snippets) {
  function fetch(name) {
    // Built-in library
    const s = snippets[name];
    if (s != null) {
      return s;
    }

    // Load from <script> tags by ID
    const ref = ["#", ".", ":", "["].includes(name[0]);
    const sel = ref ? name : `#${name}`;
    const element = document.querySelector(sel);
    if (element != null && element.tagName === "SCRIPT") {
      return element.textContent || element.innerText;
    }

    throw new Error(`Unknown shader \`${name}\``);
  }

  return src_load(fetch, { autoInspect: true });
};

;// CONCATENATED MODULE: ./src/shaders/index.js

















































































































const Snippets = {
  "arrow.position": arrow_position,
  "axis.position": axis_position,
  "cartesian.position": cartesian_position,
  "cartesian4.position": cartesian4_position,
  "clamp.position": clamp_position,
  "color.opaque": color_opaque,
  "face.position": face_position,
  "face.position.normal": face_position_normal,
  "float.encode": float_encode,
  "float.index.pack": float_index_pack,
  "float.stretch": float_stretch,
  "fragment.clip.dashed": fragment_clip_dashed,
  "fragment.clip.dotted": fragment_clip_dotted,
  "fragment.clip.ends": fragment_clip_ends,
  "fragment.clip.proximity": fragment_clip_proximity,
  "fragment.color": fragment_color,
  "fragment.map.rgba": fragment_map_rgba,
  "fragment.solid": fragment_solid,
  "fragment.transparent": fragment_transparent,
  "grid.position": grid_position,
  "grow.position": grow_position,
  "join.position": join_position,
  "label.alpha": label_alpha,
  "label.map": label_map,
  "label.outline": label_outline,
  "layer.position": layer_position,
  "lerp.depth": lerp_depth,
  "lerp.height": lerp_height,
  "lerp.items": lerp_items,
  "lerp.width": lerp_width,
  "line.position": line_position,
  "map.2d.data": map_2d_data,
  "map.2d.data.wrap": map_2d_data_wrap,
  "map.xyzw.2dv": map_xyzw_2dv,
  "map.xyzw.align": map_xyzw_align,
  "map.xyzw.texture": map_xyzw_texture,
  "mesh.fragment.color": mesh_fragment_color,
  "mesh.fragment.map": mesh_fragment_map,
  "mesh.fragment.mask": mesh_fragment_mask,
  "mesh.fragment.material": mesh_fragment_material,
  "mesh.fragment.shaded": mesh_fragment_shaded,
  "mesh.fragment.texture": mesh_fragment_texture,
  "mesh.gamma.in": mesh_gamma_in,
  "mesh.gamma.out": mesh_gamma_out,
  "mesh.map.uvwo": mesh_map_uvwo,
  "mesh.position": mesh_position,
  "mesh.vertex.color": mesh_vertex_color,
  "mesh.vertex.mask": mesh_vertex_mask,
  "mesh.vertex.position": mesh_vertex_position,
  "move.position": move_position,
  "object.mask.default": object_mask_default,
  "point.alpha.circle": point_alpha_circle,
  "point.alpha.circle.hollow": point_alpha_circle_hollow,
  "point.alpha.generic": point_alpha_generic,
  "point.alpha.generic.hollow": point_alpha_generic_hollow,
  "point.edge": point_edge,
  "point.fill": point_fill,
  "point.mask.circle": point_mask_circle,
  "point.mask.diamond": point_mask_diamond,
  "point.mask.down": point_mask_down,
  "point.mask.left": point_mask_left,
  "point.mask.right": point_mask_right,
  "point.mask.square": point_mask_square,
  "point.mask.up": point_mask_up,
  "point.position": point_position,
  "point.size.uniform": point_size_uniform,
  "point.size.varying": point_size_varying,
  "polar.position": polar_position,
  "project.position": project_position,
  "project.readback": project_readback,
  "raw.position.scale": raw_position_scale,
  "repeat.position": repeat_position,
  "resample.padding": resample_padding,
  "resample.relative": resample_relative,
  "reveal.mask": reveal_mask,
  "reverse.position": reverse_position,
  "root.position": root_position,
  "sample.2d": sample_2d,
  "scale.position": scale_position,
  "screen.map.stpq": screen_map_stpq,
  "screen.map.xy": screen_map_xy,
  "screen.map.xyzw": screen_map_xyzw,
  "screen.pass.uv": screen_pass_uv,
  "screen.position": screen_position,
  "slice.position": slice_position,
  "spherical.position": spherical_position,
  "split.position": split_position,
  "spread.position": spread_position,
  "sprite.fragment": sprite_fragment,
  "sprite.position": sprite_position,
  "stereographic.position": stereographic_position,
  "stereographic4.position": stereographic4_position,
  "stpq.sample.2d": stpq_sample_2d,
  "stpq.xyzw.2d": stpq_xyzw_2d,
  "strip.position.normal": strip_position_normal,
  "style.color": style_color,
  "subdivide.depth": subdivide_depth,
  "subdivide.depth.lerp": subdivide_depth_lerp,
  "subdivide.height": subdivide_height,
  "subdivide.height.lerp": subdivide_height_lerp,
  "subdivide.items": subdivide_items,
  "subdivide.items.lerp": subdivide_items_lerp,
  "subdivide.width": subdivide_width,
  "subdivide.width.lerp": subdivide_width_lerp,
  "surface.mask.hollow": surface_mask_hollow,
  "surface.position": surface_position,
  "surface.position.normal": surface_position_normal,
  "surface.position.shaded": surface_position_shaded,
  "ticks.position": ticks_position,
  "transform3.position": transform3_position,
  "transform4.position": transform4_position,
  "view.position": view_position,
};



;// CONCATENATED MODULE: ./src/stage/animator.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */


class Animator {
  constructor(context) {
    this.context = context;
    this.anims = [];
  }

  make(type, options) {
    const anim = new Animation(this, this.context.time, type, options);
    this.anims.push(anim);
    return anim;
  }

  unmake(anim) {
    return (this.anims = Array.from(this.anims).filter((a) => a !== anim));
  }

  update() {
    const { time } = this.context;
    return (this.anims = (() => {
      const result = [];
      for (const anim of Array.from(this.anims)) {
        if (anim.update(time) !== false) {
          result.push(anim);
        }
      }
      return result;
    })());
  }

  lerp(type, from, to, f, value) {
    if (value == null) {
      value = type.make();
    }

    // Use the most appropriate interpolation method for the type

    // Direct lerp operator
    if (type.lerp) {
      value = type.lerp(from, to, value, f);

      // Substitute emitter
    } else if (type.emitter) {
      const fromE = from.emitterFrom;
      const toE = to.emitterTo;

      if (fromE != null && toE != null && fromE === toE) {
        fromE.lerp(f);
        return fromE;
      } else {
        const emitter = type.emitter(from, to);
        from.emitterFrom = emitter;
        to.emitterTo = emitter;
        emitter.lerp(f);
        return emitter;
      }

      // Generic binary operator
    } else if (type.op) {
      const lerp = function (a, b) {
        if (a === +a && b === +b) {
          // Lerp numbers
          return a + (b - a) * f;
        } else {
          // No lerp
          if (f > 0.5) {
            return b;
          } else {
            return a;
          }
        }
      };

      value = type.op(from, to, value, lerp);

      // No lerp
    } else {
      value = f > 0.5 ? to : from;
    }

    return value;
  }
}

class Animation {
  constructor(animator, time, type, options) {
    this.animator = animator;
    this.time = time;
    this.type = type;
    this.options = options;
    this.value = this.type.make();
    this.target = this.type.make();

    this.queue = [];
  }

  dispose() {
    return this.animator.unmake(this);
  }

  set() {
    let { target } = this;
    let value = arguments.length > 1 ? [].slice.call(arguments) : arguments[0];

    let invalid = false;
    value = this.type.validate(value, target, () => (invalid = true));
    if (!invalid) {
      target = value;
    }

    this.cancel();
    this.target = this.value;
    this.value = target;
    return this.notify();
  }

  getTime() {
    const { clock } = this.options;
    const time = clock ? clock.getTime() : this.time;
    if (this.options.realtime) {
      return time.time;
    } else {
      return time.clock;
    }
  }

  cancel(from) {
    let stage;
    if (from == null) {
      from = this.getTime();
    }
    const { queue } = this;

    const cancelled = (() => {
      const result = [];
      for (stage of Array.from(queue)) {
        if (stage.end >= from) {
          result.push(stage);
        }
      }
      return result;
    })();
    this.queue = (() => {
      const result1 = [];
      for (stage of Array.from(queue)) {
        if (stage.end < from) {
          result1.push(stage);
        }
      }
      return result1;
    })();

    for (stage of Array.from(cancelled)) {
      if (typeof stage.complete === "function") {
        stage.complete(false);
      }
    }
    if (typeof this.options.complete === "function") {
      this.options.complete(false);
    }
  }

  notify() {
    return typeof this.options.step === "function"
      ? this.options.step(this.value)
      : undefined;
  }

  immediate(value, options) {
    const { duration, delay, ease, step, complete } = options;

    const time = this.getTime();

    const start = time + delay;
    const end = start + duration;

    let invalid = false;
    let target = this.type.make();
    value = this.type.validate(value, target, function () {
      invalid = true;
      return null;
    });
    if (value !== undefined && !invalid) {
      target = value;
    }

    this.cancel(start);
    return this.queue.push({
      from: null,
      to: target,
      start,
      end,
      ease,
      step,
      complete,
    });
  }

  update(time) {
    this.time = time;
    if (this.queue.length === 0) {
      return true;
    }

    const clock = this.getTime();
    let { value } = this;
    const { queue } = this;

    let active = false;
    while (!active) {
      const stage = queue[0];

      let { from } = stage;
      const { to, start, end, step, complete, ease } = stage;

      if (from == null) {
        from = stage.from = this.type.clone(this.value);
      }

      let f = clamp(
        (clock - start) / Math.max(0.00001, end - start) || 0,
        0,
        1
      );
      if (f === 0) {
        return;
      } // delayed animation not yet active

      const method = (() => {
        switch (ease) {
          case "linear":
          case 0:
            return null;
          case "cosine":
          case 1:
            return cosine;
          case "binary":
          case 2:
            return binary;
          case "hold":
          case 3:
            return hold;
          default:
            return cosine;
        }
      })();
      if (method != null) {
        f = method(f);
      }

      active = f < 1;
      value = active ? this.animator.lerp(this.type, from, to, f, value) : to;

      //console.log 'animation step', f, from, to, value
      if (typeof step === "function") {
        step(value);
      }

      if (!active) {
        if (typeof complete === "function") {
          complete(true);
        }
        if (typeof this.options.complete === "function") {
          this.options.complete(true);
        }
        queue.shift();
        if (queue.length === 0) {
          break;
        } // end of queue
      }
    }

    this.value = value;
    return this.notify();
  }
}

;// CONCATENATED MODULE: ./src/stage/api.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS104: Avoid inline assignments
 * DS202: Simplify dynamic range loops
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



class API {
  v2() {
    return this;
  }

  constructor(_context, _up, _targets) {
    this._context = _context;
    this._up = _up;
    this._targets = _targets;
    const root = this._context.controller.getRoot();

    if (this._targets == null) {
      this._targets = [root];
    }
    this.isRoot = this._targets.length === 1 && this._targets[0] === root;
    this.isLeaf =
      this._targets.length === 1 && this._targets[0].children == null;

    // Look like an array
    for (let i = 0; i < this._targets.length; i++) {
      const t = this._targets[i];
      this[i] = t;
    }
    this.length = this._targets.length;

    // Primitive factory. This is where all API methods are assigned.
    for (const type of Array.from(this._context.controller.getTypes())) {
      if (!["root"].includes(type)) {
        this[type] = (options, binds) => this.add(type, options, binds);
      }
    }
  }

  select(selector) {
    const targets = this._context.model.select(
      selector,
      !this.isRoot ? this._targets : null
    );
    return this._push(targets);
  }

  eq(index) {
    if (this._targets.length > index) {
      return this._push([this._targets[index]]);
    }
    return this._push([]);
  }

  filter(callback) {
    if (typeof callback === "string") {
      const matcher = this._context.model._matcher(callback);
      callback = (x) => matcher(x);
    }

    return this._push(this._targets.filter(callback));
  }

  map(callback) {
    return api_range_(0, this.length, false).map((i) =>
      callback(this[i], i, this)
    );
  }

  each(callback) {
    for (
      let i = 0, end = this.length, asc = 0 <= end;
      asc ? i < end : i > end;
      asc ? i++ : i--
    ) {
      callback(this[i], i, this);
    }
    return this;
  }

  add(type, options, binds) {
    // Make node/primitive
    const { controller } = this._context;

    // Auto-pop if targeting leaf
    if (this.isLeaf) {
      return this._pop().add(type, options, binds);
    }

    // Add to target
    const nodes = [];
    for (const target of this._targets) {
      const node = controller.make(type, options, binds);
      controller.add(node, target);
      nodes.push(node);
    }

    // Return changed selection
    return this._push(nodes);
  }

  remove(selector) {
    if (selector) {
      return this.select(selector).remove();
    }
    for (const target of Array.from(this._targets.slice().reverse())) {
      this._context.controller.remove(target);
    }
    return this._pop();
  }

  set(key, value) {
    for (const target of Array.from(this._targets)) {
      this._context.controller.set(target, key, value);
    }
    return this;
  }

  getAll(key) {
    return Array.from(this._targets).map((target) =>
      this._context.controller.get(target, key)
    );
  }

  get(key) {
    return this._targets[0] != null ? this._targets[0].get(key) : undefined;
  }

  evaluate(key, time) {
    return this._targets[0] != null
      ? this._targets[0].evaluate(key, time)
      : undefined;
  }

  bind(key, value) {
    for (const target of Array.from(this._targets)) {
      this._context.controller.bind(target, key, value);
    }
    return this;
  }

  unbind(key) {
    for (const target of Array.from(this._targets)) {
      this._context.controller.unbind(target, key);
    }
    return this;
  }

  end() {
    return (this.isLeaf ? this._pop() : this)._pop();
  }

  _push(targets) {
    return new API(this._context, this, targets);
  }
  _pop() {
    return this._up != null ? this._up : this;
  }
  _reset() {
    let left;
    return (left = this._up != null ? this._up.reset() : undefined) != null
      ? left
      : this;
  }

  // TODO is this okay??
  // eslint-disable-next-line no-dupe-class-members
  map(callback) {
    return this._targets.map(callback);
  }

  on() {
    const args = arguments;
    this._targets.map((x) => x.on.apply(x, args));
    return this;
  }

  off() {
    const args = arguments;
    this._targets.map((x) => x.off.apply(x, args));
    return this;
  }

  toString() {
    const tags = this._targets.map((x) => x.toString());
    if (this._targets.length > 1) {
      return `[${tags.join(", ")}]`;
    } else {
      return tags[0];
    }
  }

  toMarkup() {
    const tags = this._targets.map((x) => x.toMarkup());
    return tags.join("\n\n");
  }

  print() {
    prettyPrint(this._targets.map((x) => x.toMarkup()).join("\n\n"));
    return this;
  }

  debug() {
    const info = this.inspect();
    console.log("Renderables: ", info.renderables);
    console.log("Renders: ", info.renders);
    console.log("Shaders: ", info.shaders);

    const getName = (owner) => owner.constructor.name;

    const shaders = [];
    for (const shader of Array.from(info.shaders)) {
      const name = getName(shader.owner);
      shaders.push(`${name} - Vertex`);
      shaders.push(shader.vertex);
      shaders.push(`${name} - Fragment`);
      shaders.push(shader.fragment);
    }
    return src_inspect(shaders);
  }

  inspect(selector, trait, print) {
    let self;
    if (typeof trait === "boolean") {
      print = trait;
      trait = null;
    }
    if (print == null) {
      print = true;
    }

    // Recurse tree and extract all inserted renderables
    const map = (node) =>
      (node.controller != null ? node.controller.objects : undefined) != null
        ? node.controller != null
          ? node.controller.objects
          : undefined
        : [];
    const recurse = (self = function (node, list) {
      if (list == null) {
        list = [];
      }
      if (!trait || node.traits.hash[trait]) {
        list.push(map(node));
      }
      if (node.children != null) {
        for (const child of Array.from(node.children)) {
          self(child, list);
        }
      }
      return list;
    });

    // Flatten arrays
    const flatten = function (list) {
      list = list.reduce((a, b) => a.concat(b), []);
      return (list = list.filter((x, i) => x != null && list.indexOf(x) === i));
    };

    // Render descriptor
    const make = function (renderable, render) {
      const d = {};
      d.owner = renderable;
      d.geometry = render.geometry;
      d.material = render.material;
      d.vertex = render.userData.vertexGraph;
      d.fragment = render.userData.fragmentGraph;
      return d;
    };

    const info = {
      nodes: this._targets.slice(),
      renderables: [],
      renders: [],
      shaders: [],
    };

    // Inspect all targets
    for (const target of Array.from(this._targets)) {
      let renderables;
      if (print) {
        target.print(selector, "info");
      }

      const _info = {
        renderables: (renderables = flatten(recurse(target))),
        renders: flatten(renderables.map((x) => x.renders)),
        shaders: flatten(
          renderables.map((x) =>
            x.renders != null ? x.renders.map((r) => make(x, r)) : undefined
          )
        ),
      };

      for (const k in _info) {
        info[k] = info[k].concat(_info[k]);
      }
    }

    return info;
  }
}

function api_range_(left, right, inclusive) {
  const range = [];
  const ascending = left < right;
  const end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
    range.push(i);
  }
  return range;
}

;// CONCATENATED MODULE: ./src/stage/controller.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */

class Controller {
  constructor(model, primitives) {
    this.model = model;
    this.primitives = primitives;
  }

  getRoot() {
    return this.model.getRoot();
  }

  getTypes() {
    return this.primitives.getTypes();
  }

  make(type, options, binds) {
    return this.primitives.make(type, options, binds);
  }

  get(node, key) {
    return node.get(key);
  }

  set(node, key, value) {
    try {
      return node.set(key, value);
    } catch (e) {
      node.print(null, "warn");
      return console.error(e);
    }
  }

  bind(node, key, expr) {
    try {
      return node.bind(key, expr);
    } catch (e) {
      node.print(null, "warn");
      return console.error(e);
    }
  }

  unbind(node, key) {
    try {
      return node.unbind(key);
    } catch (e) {
      node.print(null, "warn");
      return console.error(e);
    }
  }

  add(node, target) {
    if (target == null) {
      target = this.model.getRoot();
    }
    return target.add(node);
  }

  remove(node) {
    const target = node.parent;
    if (target) {
      return target.remove(node);
    }
  }
}

;// CONCATENATED MODULE: ./src/stage/index.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.




;// CONCATENATED MODULE: ./src/util/index.js










const util_Axis = axis_namespaceObject;
const util_Data = data_namespaceObject;
const Ease = ease_namespaceObject;
const GLSL = glsl_namespaceObject;
const JS = js_namespaceObject;
const Pretty = pretty_namespaceObject;
const Three = three_namespaceObject;
const util_Ticks = util_ticks_namespaceObject;
const VDOM = vdom_namespaceObject;

;// CONCATENATED MODULE: ./src/context.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS206: Consider reworking classes to avoid initClass
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */











class Context {
  static initClass() {
    // Export for extending. TODO what is the story here, what is this syntax?
    this.Namespace = {
      Model: src_model_namespaceObject,
      Overlay: src_overlay_namespaceObject,
      Primitives: primitives_namespaceObject,
      Render: src_render_namespaceObject,
      Shaders: shaders_namespaceObject,
      Stage: stage_namespaceObject,
      Util: util_namespaceObject,
      DOM: VDOM,
    };
    this.Version = "2.3.1";
  }

  //-------------------------------------------------------------------

  // Set up entire environment
  constructor(renderer, scene = null, camera = null) {
    // DOM container
    let canvas;
    this.canvas = canvas = renderer.domElement;
    this.element = null;

    // Rendering factory
    this.shaders = factory_Factory(Snippets);

    this.renderables = new RenderFactory(
      render_classes_Classes,
      renderer,
      this.shaders
    );
    this.overlays = new OverlayFactory(Classes, canvas);

    this.scene = this.renderables.make("scene", { scene });
    this.camera = this.defaultCamera =
      camera != null ? camera : new external_THREE_.PerspectiveCamera();

    // Primitives factory
    this.attributes = new Attributes(primitives_Types, this);
    this.primitives = new PrimitiveFactory(primitives_Types, this);

    this.root = this.primitives.make("root");

    // Document model
    this.model = new Model(this.root);
    this.guard = new Guard();

    // Scene controllers
    this.controller = new Controller(this.model, this.primitives);
    this.animator = new Animator(this);

    // Public API
    this.api = new API(this);

    // Global clocks, one real-time and one adjustable
    this.speed = 1;
    this.time = {
      now: +new Date() / 1000,
      time: 0,
      delta: 0,
      clock: 0,
      step: 0,
    };
  }

  //-------------------------------------------------------------------
  // Lifecycle

  init() {
    this.scene.inject();
    this.overlays.inject();
    return this;
  }

  destroy() {
    this.scene.unject();
    this.overlays.unject();
    return this;
  }

  resize(size) {
    /*
    {
      viewWidth, viewHeight, renderWidth, renderHeight, aspect, pixelRatio
    }
    */
    if (size == null) {
      size = {};
    }
    if (size.renderWidth == null) {
      size.renderWidth =
        size.viewWidth != null ? size.viewWidth : (size.viewWidth = 1280);
    }
    if (size.renderHeight == null) {
      size.renderHeight =
        size.viewHeight != null ? size.viewHeight : (size.viewHeight = 720);
    }
    if (size.pixelRatio == null) {
      size.pixelRatio = size.renderWidth / Math.max(0.000001, size.viewWidth);
    }
    if (size.aspect == null) {
      size.aspect = size.viewWidth / Math.max(0.000001, size.viewHeight);
    }

    this.root.controller.resize(size);
    return this;
  }

  frame(time) {
    /*
    {
      now, clock, step
    }
    */
    this.pre(time);
    this.update();
    this.render();
    this.post();
    return this;
  }

  //-------------------------------------------------------------------
  // Broken down update/render cycle, for manual scheduling/invocation

  pre(time) {
    if (!time) {
      time = {
        now: +new Date() / 1000,
        time: 0,
        delta: 0,
        clock: 0,
        step: 0,
      };

      time.delta = this.time.now != null ? time.now - this.time.now : 0;

      // Check for stopped render loop, assume 1 60fps frame
      if (time.delta > 1) {
        time.delta = 1 / 60;
      }

      time.step = time.delta * this.speed;
      time.time = this.time.time + time.delta;
      time.clock = this.time.clock + time.step;
    }

    this.time = time;
    if (typeof this.root.controller.pre === "function") {
      this.root.controller.pre();
    }
    return this;
  }

  update() {
    this.animator.update();
    this.attributes.compute();

    this.guard.iterate({
      step: () => {
        let change = this.attributes.digest();
        return change || (change = this.model.digest());
      },
      last() {
        return {
          attribute: this.attributes.getLastTrigger(),
          model: this.model.getLastTrigger(),
        };
      },
    });

    if (typeof this.root.controller.update === "function") {
      this.root.controller.update();
    }

    this.camera = this.root.controller.getCamera();
    this.speed = this.root.controller.getSpeed();

    return this;
  }

  render() {
    if (typeof this.root.controller.render === "function") {
      this.root.controller.render();
    }
    this.scene.render();

    return this;
  }

  post() {
    if (typeof this.root.controller.post === "function") {
      this.root.controller.post();
    }
    return this;
  }

  //-------------------------------------------------------------------
  // Warmup mode, inserts only n objects into the scene per frame
  // Will render objects to offscreen 1x1 buffer to ensure shader is compiled even if invisible
  setWarmup(n) {
    this.scene.warmup(n);
    return this;
  }

  getPending() {
    return this.scene.pending.length;
  }
}
Context.initClass();

;// CONCATENATED MODULE: ./src/index.js
// TODO: This file was created by bulk-decaffeinate.
// Sanity-check the conversion and remove this comment.
/*
 * decaffeinate suggestions:
 * DS102: Remove unnecessary code created because of implicit returns
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */



// NOTE this import triggers the installation of all plugins as a side effect.













// Just because
const π = Math.PI;
const τ = π * 2;
const e = Math.E;
const src_Context = Context;
const version = Context.Version;
const src_Model = src_model_namespaceObject;
const src_Overlay = src_overlay_namespaceObject;
const Primitives = primitives_namespaceObject;
const Render = src_render_namespaceObject;
const Shaders = shaders_namespaceObject;
const Stage = stage_namespaceObject;
const Util = util_namespaceObject;
const src_DOM = VDOM;

const mathBox = function (options) {
  const three = new Bootstrap(options);

  if (!three.fallback) {
    if (!three.Time) {
      three.install("time");
    }
    if (!three.MathBox) {
      three.install(["mathbox", "splash"]);
    }
  }

  return three.mathbox != null ? three.mathbox : three;
};

// Load context and export namespace
// TODO suspicious... how can I export??
// for (let k in Context.Namespace) {
//   const v = Context.Namespace[k];
//   exports[k] = v;
// }

// Threestrap plugin
Bootstrap.registerPlugin("mathbox", {
  defaults: {
    init: true,
    warmup: 2,
    inspect: true,
    splash: true,
  },

  listen: ["ready", "pre", "update", "post", "resize"],

  // Install meta-API
  install(three) {
    let inited = false;
    this.first = true;

    return (three.MathBox = {
      // Init the mathbox context
      init: (options) => {
        if (inited) {
          return;
        }
        inited = true;

        const scene =
          (options != null ? options.scene : undefined) ||
          this.options.scene ||
          three.scene;
        const camera =
          (options != null ? options.camera : undefined) ||
          this.options.camera ||
          three.camera;

        this.context = new src_Context(three.renderer, scene, camera);

        // Enable handy destructuring
        this.context.api.three = three.three = three;
        this.context.api.mathbox = three.mathbox = this.context.api;

        // v1 compatibility
        this.context.api.start = () => three.Loop.start();
        this.context.api.stop = () => three.Loop.stop();

        // Initialize and set initial size
        this.context.init();
        this.context.resize(three.Size);

        // Set warmup mode and track pending objects
        this.context.setWarmup(this.options.warmup);
        this.pending = 0;
        this.warm = !this.options.warmup;

        console.log("MathBox²", version);
        three.trigger({
          type: "mathbox/init",
          version: version,
          context: this.context,
        });
      },

      // Destroy the mathbox context
      destroy: () => {
        if (!inited) {
          return;
        }
        inited = false;

        three.trigger({ type: "mathbox/destroy", context: this.context });

        this.context.destroy();

        delete three.mathbox;
        delete this.context.api.three;
        delete this.context;
      },

      object: () =>
        this.context != null ? this.context.scene.root : undefined,
    });
  },

  uninstall(three) {
    three.MathBox.destroy();
    delete three.MathBox;
  },

  // Ready event: right before mathbox() / THREE.bootstrap() returns
  ready(event, three) {
    if (this.options.init) {
      three.MathBox.init();

      return setTimeout(() => {
        if (this.options.inspect && three.MathBox) {
          return this.inspect(three);
        }
      });
    }
  },

  // Log scene for inspection
  inspect(three) {
    this.context.api.inspect();
    if (!this.options.warmup) {
      return this.info(three);
    }
  },

  info(three) {
    const fmt = function (x) {
      const out = [];
      while (x >= 1000) {
        out.unshift(("000" + (x % 1000)).slice(-3));
        x = Math.floor(x / 1000);
      }
      out.unshift(x);
      return out.join(",");
    };

    const info = three.renderer.info.render;
    console.log(
      "Geometry  ",
      fmt(info.triangles) + " triangles  ",
      fmt(info.points) + " points  ",
      fmt(info.lines) + " lines  ",
      fmt(info.calls) + " draw calls  "
    );
  },

  // Hook up context events
  resize(event, three) {
    return this.context != null ? this.context.resize(three.Size) : undefined;
  },

  pre(event, three) {
    return this.context != null ? this.context.pre(three.Time) : undefined;
  },

  update(event, three) {
    let camera;
    if (this.context != null) {
      this.context.update();
    }

    if (
      (camera = this.context != null ? this.context.camera : undefined) &&
      camera !== three.camera
    ) {
      three.camera = camera;
    }

    three.Time.set({ speed: this.context.speed });

    this.progress(this.context.getPending(), three);

    // Call render here instead of on:render because it renders off screen material
    // that needs to be available for rendering the actual frame.
    return this.context != null ? this.context.render() : undefined;
  },

  post(_event, _three) {
    return this.context != null ? this.context.post() : undefined;
  },

  // Warmup progress changed
  progress(remain, three) {
    if (!remain && !this.pending) {
      return;
    }

    // Latch max value until queue is emptied to get a total
    let pending = Math.max(remain + this.options.warmup, this.pending);

    // Send events for external progress reporting
    const current = pending - remain;
    const total = pending;
    three.trigger({
      type: "mathbox/progress",
      current: pending - remain,
      total: pending,
    });

    if (remain === 0) {
      pending = 0;
    }
    this.pending = pending;

    // Report once when loaded
    if (current === total && !this.warm) {
      this.warm = true;
      if (this.options.inspect) {
        this.info(three);
      }
    }
  },
});

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=mathbox.js.map